<html>
<head>
<title>Dockerfile - Docker Build - Docker Build Name | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>dock file-dock build-dock build name | circles-dock样式-dock build-dock build name | circles</h1>
<blockquote>原文：<a href="https://circleci.com/blog/multi-stage-docker-builds/#2017-07-18T03:00:00-07:00">https://circleci.com/blog/multi-stage-docker-builds/#2017-07-18T03:00:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        
          <p class="italic"><strong>来自出版商的说明:</strong>您已经找到了我们的一些旧内容，这些内容可能已经过时和/或不正确。尝试在<a href="https://circleci.com/docs/" target="_blank">我们的文档</a>或<a href="https://circleci.com/blog/">博客</a>中搜索最新信息。</p>
          <hr/>
        

        <p>Docker在2017年5月推出了多阶段构建。用最简单的话来说，这些是包含不止一个<code>FROM</code>语句的docker文件。稍加调整，您就可以在CircleCI 2.0上构建多级Dockerfiles。</p>



<p><em>查看<a href="https://circleci.com/blog/guide-to-using-docker-for-your-ci-cd-pipelines/">为您的CI/CD管道使用Docker的指南</a> </em></p>

<h2>什么是多阶段Docker构建？</h2>

<p>Docker新的多阶段构建允许docker文件变得更加强大，用一个docker文件提供复杂的构建。一个用例可能是，您通常有一个docker文件用于构建应用程序的源代码，然后有另一个文件用于运行和测试应用程序。这里有一个例子<code>Dockerfile</code>用多阶段构建来解决这个问题，这个例子是从<a href="https://docs.docker.com">docs.docker.com</a>那里借来的:</p>

<pre><code class="language-Dockerfile">FROM golang:1.8.3
WORKDIR /go/src/github.com/alexellis/href-counter/
RUN go get -d -v golang.org/x/net/html  
COPY app.go .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest  
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=0 /go/src/github.com/alexellis/href-counter/app .
CMD ["./app"]
</code></pre>

<p>这个Docker文件的第一个“阶段”是使用Docker库中的官方Go映像构建Go应用程序。然后，第二阶段从第一阶段(用<code>COPY --from=0</code>)复制新构建的二进制文件，并将其放在一个定制的Alpine映像中。结果是一个基于Alpine的Docker映像，任何人都可以使用它来运行这个Go应用程序，而不需要任何最初用于构建该应用程序的额外软件，例如Go工具链。</p>

<h3>命名阶段</h3>

<p>为了将我们构建的二进制文件复制到第二个阶段，我们使用了<code>COPY --from=0</code>,因为我们没有命名阶段，所以我们使用了它的索引号。相反，我们可以在<code>FROM</code>语句中命名一个阶段，然后在以后使用这个名称。所以我们可以从<code>FROM golang:1.8.3 as compile-stage</code>开始，在<code>COPY</code>语句中我们将使用<code>COPY --from=compile-stage</code>。</p>

<h2>基于CircleCI 2.0构建</h2>

<p>上面的Dockerfile示例可以用CircleCI 2.0构建，但是需要根据您使用的<a href="https://circleci.com/docs/glossary/#executor"> <code>executor</code> </a>进行配置更改。这是因为CircleCI上默认使用的Docker版本是Docker 17 . 03 . 0 Community Edition(CE)。Docker v17.05.0-ce及更新版本支持多阶段构建。<code>machine</code>和<code>docker</code>执行者都允许我们请求更新的Docker版本。</p>

<h3><code>docker</code> Executor</h3>

<p>我们可以在<code>setup_remote_docker</code>下设置Docker版本用于远程引擎:</p>

<pre><code>      - setup_remote_docker:
	      version: 17.05.0-ce
</code></pre>

<p>记住，当使用<code>docker</code>执行器和<code>setup_remote_docker</code>时，这只是为您提供了一个远程Docker引擎来连接。您的构建所使用的基本Docker映像仍然需要安装Docker客户端。更多关于这个以及Docker支持哪个版本的信息可以在<a href="https://circleci.com/docs/building-docker-images/">这里</a>找到。</p>

<h3><code>machine</code> Executor</h3>

<p><code>machine</code>执行器现在支持指定一个映像，类似于<code>docker</code>执行器的工作方式，但是使用我们的基本VM映像。默认图像不足以满足我们的用例，但“边缘”图像是:</p>

<pre><code>jobs:
  build:
    machine:
      image: circleci/classic:edge
</code></pre>

<p>这为我们提供了Docker v17.06.0-ce的机器VM。更多关于<code>machine</code>的执行者<a href="https://circleci.com/docs/configuration-reference/#machine">这里</a>。</p>

<p>使用Docker v17.05.0-ce和更新版本，您现在可以在CircleCI 2.0上构建多级Docker文件。</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>
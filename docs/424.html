<html>
<head>
<title>Managing CI/CD pipelines with Arm compute resource classes | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Arm计算资源类管理CI/CD管道| CircleCI</h1>
<blockquote>原文：<a href="https://circleci.com/blog/managing-ci-cd-pipelines-with-arm-compute-resource-classes/#2021-03-30T04:30:00-07:00">https://circleci.com/blog/managing-ci-cd-pipelines-with-arm-compute-resource-classes/#2021-03-30T04:30:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p><a href="https://en.wikipedia.org/wiki/ARM_architecture"> Arm处理器和架构</a>正变得广泛可用，因为开发团队将它们作为许多应用基础设施中的计算节点。需要以经济高效的方式运行微服务、应用服务器、数据库和其他工作负载的组织将继续转向Arm架构。需要基于Arm的计算的CircleCI客户已经可以使用自托管的runners，但是我们认识到更多的客户将需要使用基于Arm的计算来构建、测试和部署他们的应用。为了让开发人员能够在CI/CD管道中基于Arm的实例上运行代码，而无需自行维护基础设施，我们为所有CircleCI用户添加了<a href="https://circleci.com/docs/arm-resources/">新的基于Arm的资源类</a>。在本教程中，我将介绍新的<a href="https://circleci.com/docs/arm-resources/"> Arm资源类</a>，并演示如何在您的管道中使用它们来构建、测试和部署Arm应用程序。</p>

<h2>先决条件</h2>

<p>在开始学习本教程之前，您需要完成一些任务:</p>



<h2>Arm计算资源类</h2>

<p>本教程的以下部分将演示如何在基于Arm的执行器上配置和执行CI/CD管道，以及如何使用<a href="https://www.terraform.io/"> Terraform </a> an基础架构作为代码，基于<a href="https://aws.amazon.com/ec2/graviton/"> AWS Graviton2 </a>计算节点创建、部署和销毁<a href="https://aws.amazon.com/ecs/"> AWS ECS集群</a>。</p>

<h2>在config.yml中实现Arm计算</h2>

<p>下面的管道配置示例显示了如何定义Arm资源类。</p>

<pre><code>version: 2.1
orbs:
  node: circleci/node@4.2.0
jobs:
  run-tests:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
      - checkout
      - node/install-packages:
          override-ci-command: npm install
          cache-path: ~/project/node_modules
      - run:
          name: Run Unit Tests
          command: |
            ./node_modules/mocha/bin/mocha test/ --reporter mochawesome --reporter-options reportDir=test-results,reportFilename=test-results
      - store_test_results:
          path: test-results
      - store_artifacts:
          path: test-results          
  build_docker_image:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
      - checkout
      - run:
          name: "Build Docker Image ARM V8"
          command: |
            export TAG='0.1.&lt;&lt; pipeline.number &gt;&gt;'
            export IMAGE_NAME=$CIRCLE_PROJECT_REPONAME
            docker build -t $DOCKER_LOGIN/$IMAGE_NAME -t $DOCKER_LOGIN/$IMAGE_NAME:$TAG .
            echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin
            docker push -a $DOCKER_LOGIN/$IMAGE_NAME
workflows:
  build:
    jobs:
      - run-tests
      - build_docker_image
</code></pre>

<p>在这个代码示例中，<code>run-tests:</code>作业展示了如何指定一个机器执行器，并为它分配一个Arm计算节点资源类。<code>image:</code>键指定分配给执行器的操作系统。<code>resource_class:</code>指定使用哪个<a href="https://circleci.com/docs/configuration-reference/#resourceclass"> CircleCI资源类</a>。在这种情况下，我们使用的是<code>arm.medium</code>资源类类型，它支持管道在Arm架构和资源上执行和构建代码。<code>build_docker_image:</code>作业是使用<code>arm.medium</code>资源类构建支持Arm64的Docker映像的好方法，可以放心地部署到Arm计算基础设施，如<a href="https://aws.amazon.com/ec2/graviton/"> AWS Graviton2 </a>。</p>

<pre><code>  version: 2.1
  orbs:
    node: circleci/node@4.2.0
  commands:
    install_terraform:
      description: "specify terraform version &amp; architecture to use [amd64 or arm64]"
      parameters:
        version:
          type: string
          default: "0.13.5"
        arch:
          type: string
          default: "arm64"
      steps:
        - run:
            name: Install Terraform client
            command: |
              cd /tmp
              wget https://releases.hashicorp.com/terraform/&lt;&lt;
                parameters.version &gt;&gt;/terraform_&lt;&lt;
                parameters.version &gt;&gt;_linux_&lt;&lt; 
                parameters.arch &gt;&gt;.zip
              unzip terraform_&lt;&lt; parameters.version &gt;&gt;_linux_&lt;&lt;
                parameters.arch &gt;&gt;.zip
              sudo mv terraform /usr/local/bin
  jobs:
    run-tests:
      machine:
        image: ubuntu-2004:202101-01
      resource_class: arm.medium
      steps:
        - checkout
        - node/install-packages:
            override-ci-command: npm install
            cache-path: ~/project/node_modules
        - run:
            name: Run Unit Tests
            command: |
              ./node_modules/mocha/bin/mocha test/ --reporter mochawesome --reporter-options reportDir=test-results,reportFilename=test-results
        - store_test_results:
            path: test-results
        - store_artifacts:
            path: test-results          
    build_docker_image:
      machine:
        image: ubuntu-2004:202101-01
      resource_class: arm.medium
      steps:
        - checkout
        - run:
            name: "Build Docker Image ARM V8"
            command: |
              export TAG='0.1.&lt;&lt; pipeline.number &gt;&gt;'
              export IMAGE_NAME=$CIRCLE_PROJECT_REPONAME
              docker build -t $DOCKER_LOGIN/$IMAGE_NAME -t $DOCKER_LOGIN/$IMAGE_NAME:$TAG .
              echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin
              docker push -a $DOCKER_LOGIN/$IMAGE_NAME
    deploy_aws_ecs:
      machine:
        image: ubuntu-2004:202101-01
      resource_class: arm.medium
      steps:
        - checkout
        - run:
            name: Create .terraformrc file locally
            command: echo "credentials \"app.terraform.io\" {token = \"$TERRAFORM_TOKEN\"}" &gt; $HOME/.terraformrc
        - install_terraform:
            version: 0.14.2
            arch: arm64    
        - run:
            name: Deploy Application to AWS ECS Cluster
            command: |
              export TAG=0.1.&lt;&lt; pipeline.number &gt;&gt;
              export DOCKER_IMAGE_NAME="${DOCKER_LOGIN}/${CIRCLE_PROJECT_REPONAME}"
              cd terraform/aws/ecs
              terraform init
              terraform apply \
                -var docker_img_name=$DOCKER_IMAGE_NAME \
                -var docker_img_tag=$TAG \
                --auto-approve
    destroy_aws_ecs:
      machine:
        image: ubuntu-2004:202101-01
      resource_class: arm.medium
      steps:
        - checkout
        - run:
            name: Create .terraformrc file locally
            command: echo "credentials \"app.terraform.io\" {token = \"$TERRAFORM_TOKEN\"}" &gt; $HOME/.terraformrc
        - install_terraform:
            version: 0.14.2
            arch: arm64    
        - run:
            name: Destroy the AWS ECS Cluster
            command: |
              cd terraform/aws/ecs
              terraform init
              terraform destroy --auto-approve              
  workflows:
    build:
      jobs:
        - run-tests
        - build_docker_image
        - deploy_aws_ecs
        - approve_destroy:
            type: approval
            requires:
              - deploy_aws_ecs
        - destroy_aws_ecs:
            requires:
              - approve_destroy
</code></pre>

<h2>部署到AWS ECS</h2>

<p>上一节中的代码示例显示了如何在管道中利用Arm资源类。在这一节中，我将向您展示如何扩展代码来创建AWS资源，例如<a href="https://aws.amazon.com/ecs/"> ECS集群</a>。我将用底层的<a href="https://aws.amazon.com/ec2/graviton/"> AWS Graviton2 EC2 </a>计算节点创建这些资源，使用<a href="https://www.terraform.io/docs/cli-index.html"> Terraform </a>和基础设施作为代码。</p>

<pre><code>  version: 2.1
  orbs:
    node: circleci/node@4.2.0
  commands:
    install_terraform:
      description: "specify terraform version &amp; architecture to use [amd64 or arm64]"
      parameters:
        version:
          type: string
          default: "0.13.5"
        arch:
          type: string
          default: "arm64"
      steps:
        - run:
            name: Install Terraform client
            command: |
              cd /tmp
              wget https://releases.hashicorp.com/terraform/&lt;&lt;
                parameters.version &gt;&gt;/terraform_&lt;&lt;
                parameters.version &gt;&gt;_linux_&lt;&lt; 
                parameters.arch &gt;&gt;.zip
              unzip terraform_&lt;&lt; parameters.version &gt;&gt;_linux_&lt;&lt;
                parameters.arch &gt;&gt;.zip
              sudo mv terraform /usr/local/bin
  jobs:
    run-tests:
      machine:
        image: ubuntu-2004:202101-01
      resource_class: arm.medium
      steps:
        - checkout
        - node/install-packages:
            override-ci-command: npm install
            cache-path: ~/project/node_modules
        - run:
            name: Run Unit Tests
            command: |
              ./node_modules/mocha/bin/mocha test/ --reporter mochawesome --reporter-options reportDir=test-results,reportFilename=test-results
        - store_test_results:
            path: test-results
        - store_artifacts:
            path: test-results          
    build_docker_image:
      machine:
        image: ubuntu-2004:202101-01
      resource_class: arm.medium
      steps:
        - checkout
        - run:
            name: "Build Docker Image ARM V8"
            command: |
              export TAG='0.1.&lt;&lt; pipeline.number &gt;&gt;'
              export IMAGE_NAME=$CIRCLE_PROJECT_REPONAME
              docker build -t $DOCKER_LOGIN/$IMAGE_NAME -t $DOCKER_LOGIN/$IMAGE_NAME:$TAG .
              echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin
              docker push -a $DOCKER_LOGIN/$IMAGE_NAME
    deploy_aws_ecs:
      machine:
        image: ubuntu-2004:202101-01
      resource_class: arm.medium
      steps:
        - checkout
        - run:
            name: Create .terraformrc file locally
            command: echo "credentials \"app.terraform.io\" {token = \"$TERRAFORM_TOKEN\"}" &gt; $HOME/.terraformrc
        - install_terraform:
            version: 0.14.2
            arch: arm64    
        - run:
            name: Deploy Application to AWS ECS Cluster
            command: |
              export TAG=0.1.&lt;&lt; pipeline.number &gt;&gt;
              export DOCKER_IMAGE_NAME="${DOCKER_LOGIN}/${CIRCLE_PROJECT_REPONAME}"
              cd terraform/aws/ecs
              terraform init
              terraform apply \
                -var docker_img_name=$DOCKER_IMAGE_NAME \
                -var docker_img_tag=$TAG \
                --auto-approve
    destroy_aws_ecs:
      machine:
        image: ubuntu-2004:202101-01
      resource_class: arm.medium
      steps:
        - checkout
        - run:
            name: Create .terraformrc file locally
            command: echo "credentials \"app.terraform.io\" {token = \"$TERRAFORM_TOKEN\"}" &gt; $HOME/.terraformrc
        - install_terraform:
            version: 0.14.2
            arch: arm64    
        - run:
            name: Destroy the AWS ECS Cluster
            command: |
              cd terraform/aws/ecs
              terraform init
              terraform destroy --auto-approve              
  workflows:
    build:
      jobs:
        - run-tests
        - build_docker_image
        - deploy_aws_ecs
        - approve_destroy:
            type: approval
            requires:
              - deploy_aws_ecs
        - destroy_aws_ecs:
            requires:
              - approve_destroy
</code></pre>

<p>这段代码扩展了原始的管道配置示例。您可能已经注意到，已经定义了一些新的工作。<code>deploy_aws_ecs:</code>、<code>approve_destroy:</code>和<code>destroy_aws_ecs:</code>作业是这个扩展配置中的新元素。在我深入研究它们之前，我将描述一下<code>commands:</code>和<code>install_terraform:</code>元素。</p>

<h3>install_terraform:命令</h3>

<p>CircleCI能够使用<a href="https://circleci.com/docs/pipeline-variables/#pipeline-parameters-in-configuration">管道参数</a>封装和重用配置代码。<code>install_terraform:</code>命令是定义可重用管道代码的一个例子。如果您的管道重复执行特定的命令，我建议定义可重用的<code>command:</code>元素，以提供可扩展和集中管理的管道配置。<code>deploy_aws_ecs:</code>和<code>destroy_aws_ecs:</code>作业都执行Terraform代码，因此管道需要多次下载并安装<a href="https://www.terraform.io/docs/cli-index.html"> Terraform cli </a>。<code>install_terraform:</code>命令提供了宝贵的可重用性。</p>

<pre><code>  commands:
    install_terraform:
      description: "specify terraform version &amp; architecture to use [amd64 or arm64]"
      parameters:
        version:
          type: string
          default: "0.13.5"
        arch:
          type: string
          default: "arm64"
      steps:
        - run:
            name: Install Terraform client
            command: |
              cd /tmp
              wget https://releases.hashicorp.com/terraform/&lt;&lt;
                parameters.version &gt;&gt;/terraform_&lt;&lt;
                parameters.version &gt;&gt;_linux_&lt;&lt; 
                parameters.arch &gt;&gt;.zip
              unzip terraform_&lt;&lt; parameters.version &gt;&gt;_linux_&lt;&lt;
                parameters.arch &gt;&gt;.zip
              sudo mv terraform /usr/local/bin
</code></pre>

<p>该代码块定义了<code>install_terraform:</code>可重用命令。<code>parameters:</code>键维护一个参数列表。参数<code>version:</code>和<code>arch:</code>分别定义了Terraform CLI版本和CPU架构。这些参数下载并在执行器中安装客户机。因为这个代码块代表一个<code>command:</code>元素，所以必须定义一个命令<code>steps:</code>键。在前面的例子中，<code>run:</code>元素执行相应的<code>command:</code>键。该键使用<code>&lt;&lt; parameter.version &gt;&gt;</code>和<code>&lt;&lt; parameter.arch &gt;&gt;</code>变量下载特定的Terraform客户端，以指定客户端版本号和CPU架构。<a href="https://circleci.com/docs/pipeline-variables/#pipeline-parameters-in-configuration">管道参数</a>对于优化和集中管理管道配置中的功能非常有用。如果你想了解更多，你可以在这里得到所有的细节。</p>

<h3>部署_aws_ecs作业</h3>

<p>管道中定义的<code>deploy_aws_ecs:</code>作业利用基础设施作为代码来创建新的Amazon ECS集群。它包括所有必需的资源，如虚拟专用网络(VPC)、子网、路由表、应用程序负载平衡器和EC2自动扩展组。这项工作创建和调配部署和运行应用程序所需的所有基础架构。因为目标架构是Arm，所以AWS ECS集群必须由AWS Gravtion2 ECS计算节点组成。这些节点将在之前的流水线作业中执行基于Arm的Docker应用映像构建。</p>

<pre><code>  deploy_aws_ecs:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
      - checkout
      - run:
          name: Create .terraformrc file locally
          command: echo "credentials \"app.terraform.io\" {token = \"$TERRAFORM_TOKEN\"}" &gt; $HOME/.terraformrc
      - install_terraform:
          version: 0.14.2
          arch: arm64    
      - run:
          name: Deploy Application to AWS ECS Cluster
          command: |
            export TAG=0.1.&lt;&lt; pipeline.number &gt;&gt;
            export DOCKER_IMAGE_NAME="${DOCKER_LOGIN}/${CIRCLE_PROJECT_REPONAME}"
            cd terraform/aws/ecs
            terraform init
            terraform apply \
              -var docker_img_name=$DOCKER_IMAGE_NAME \
              -var docker_img_tag=$TAG \
              --auto-approve
</code></pre>

<p>这个代码块演示了如何使用我之前描述的<code>install_terraform:</code>命令。我们已经将<code>version:</code>参数设置为0.14.2，将<code>arch:</code>参数设置为arm64。最后的<code>run:</code>元素初始化terraform，然后代码使用相应的参数执行一个<code>terraform apply</code>命令，这些参数传递在管道运行中创建的Docker图像名称和标记的值。完成后，该作业将创建应用程序，并将其部署到基于AWS ECS Graviton2的全功能集群中。</p>

<h3>销毁_aws_ecs作业</h3>

<p>我们在<code>deploy_aws_ecs</code>中创建了AWS ECS基础架构。<code>destroy_aws_ecs</code>作业显然执行相反的操作，以编程方式破坏所有创建的基础设施和资源。这是终止不必要的基础设施的最干净的方法。</p>

<pre><code>  destroy_aws_ecs:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
      - checkout
      - run:
          name: Create .terraformrc file locally
          command: echo "credentials \"app.terraform.io\" {token = \"$TERRAFORM_TOKEN\"}" &gt; $HOME/.terraformrc
      - install_terraform:
          version: 0.14.2
          arch: arm64    
      - run:
          name: Destroy the AWS ECS Cluster
          command: |
            cd terraform/aws/ecs
            terraform init
            terraform destroy --auto-approve
</code></pre>

<p>在这个代码块中，除了最后一个<code>run:</code>元素之外，大部分作业定义与前一个相同。在这个元素中，我们发出了一个Terraform初始化和<code>terraform destroy</code>命令，正如所料，这个命令将销毁在前面的步骤中创建的所有资源。</p>

<h3>工作流:批准_销毁作业</h3>

<p>我将讨论的最后一项是在配置示例的<code>workflows:</code>元素中找到的<code>approve_destroy:</code>。该作业是一种<a href="https://circleci.com/docs/workflows/#holding-a-workflow-for-a-manual-approval">手动批准类型</a>，其中工作流将被有意停止并保持暂停状态，直到手动交互完成。在这种情况下，必须按下CircleCI仪表板上的按钮，以便执行<code>destroy-aws-ecs:</code>。如果没有这个批准作业，管道将自动触发销毁作业，并终止在以前的作业中创建的所有资源。在管道执行中需要手动干预或批准的情况下，批准类型的作业非常有用。</p>

<h2>结论</h2>

<p>CircleCI以Arm计算节点的形式推出了支持Arm的执行器，让开发人员能够访问Arm架构的管道。在本教程中，我演示了如何将CircleCI Arm计算节点实现为管道执行器。我还展示了如何使用Terraform和infrastructure作为代码将应用程序部署到由AWS Graviton2 EC2节点支持的AWS ECS集群。本教程中的所有代码示例都可以在GitHub 的arm-executors repo中找到，我强烈建议你去看看。我很想听到你的反馈、想法和意见，所以请发推特给我<a href="https://twitter.com/punkdata"> @punkdata </a>加入讨论。</p>

<p>感谢阅读！</p>



        
          
          
        
      </div>
    </div>    
</body>
</html>
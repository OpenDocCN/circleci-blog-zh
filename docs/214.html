<html>
<head>
<title>Creating custom Docker images to run your CI builds | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>创建自定义Docker映像以运行您的CI构建| CircleCI</h1>
<blockquote>原文：<a href="https://circleci.com/blog/creating-a-custom-docker-image-to-run-your-ci-builds/#2020-05-19T09:00:00-07:00">https://circleci.com/blog/creating-a-custom-docker-image-to-run-your-ci-builds/#2020-05-19T09:00:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>本指南提供了关于如何创建一个有效的Docker映像作为<a href="https://circleci.com/docs/executor-types/#using-docker"> Docker执行器</a>中的主映像的提示。作业中的所有步骤，包括orb命令，都将在该映像中执行。然而，本指南并不包括如何构建和发布Docker映像，然后在您的生产环境中使用或发布您的开源应用程序。</p>

<p><em>欲了解更多Docker内容，请访问<a href="https://circleci.com/blog/creating-a-custom-docker-image-to-run-your-ci-builds/">CI/CD管道Docker使用指南</a>。</em></p>

<p>我希望你问问自己，你确定要这么做吗？有许多人不想在运行时安装几个包，因为这会增加他们20-45秒的构建时间。然后，他们花几个小时想办法建立自己的Docker形象，然后花几个月甚至几年的时间来维护这个形象。有时候不值得努力。</p>

<p>在需要安装大量软件包、需要编译源代码或通过慢速连接下载的情况下，这是您自己的自定义Docker映像大放异彩的最佳时机。</p>

<p>还感兴趣吗？太好了，我们开始吧。</p>

<h2>编写Dockerfile文件</h2>

<p>一切都以Dockerfile开始和结束。这是创建Docker图像的蓝图。有关Docker文件的更多信息，请访问Docker的<a href="https://docs.docker.com/get-started/part2/">入门-第2部分</a>指南。</p>

<p>基本图像</p>

<p>Dockerfile通常以声明新图像将使用的基础图像的<code>FROM</code>语句开始。虽然不是必须的，但我们强烈建议使用CircleCI base便利图像作为您的基本图像。</p>

<pre><code>FROM cimg/base:stable
</code></pre>

<p>CircleCI基础映像是所有下一代便利映像的基础。你可以在这里了解更多关于所有新图片的信息<a href="https://circleci.com/blog/announcing-our-next-generation-convenience-images-smaller-faster-more-deterministic/">。它完全是为了在CircleCI上工作而设计的。它拥有我们大多数客户需要的所有必需的工具以及最常用的工具。例如，</a><a href="https://circleci.com/docs/configuration-reference/#checkout"> checkout </a>特殊步骤要求<code>git</code>安装在Docker映像中。<a href="https://circleci.com/docs/configuration-reference/#save_cache"> save_cache </a>和<a href="https://circleci.com/docs/configuration-reference/#persist_to_workspace"> persist_workspace </a>特殊步骤，以及它们的加载等价物，需要安装<code>tar</code>和<code>gzip</code>。我们的基本映像包括所有这些工具，并且我们确保随着额外需求的增加或删除，软件列表得到维护。</p>

<p>这个图像在我们的平台上也相当受欢迎，这意味着通过将您的图像基于我们的基础图像可以获得缓存优势。您可以在GitHub页面上了解更多关于CircleCI base便利图片以及如何使用它的信息。如果你选择使用不同的基本映像，我建议你至少访问一下GitHub页面看看我们安装了什么包，这样你就可以自己复制这个列表了。</p>

<h3>安装和下载软件</h3>

<pre><code>RUN sudo apt-get update &amp;&amp; sudo apt-get install -y \
        bison \
        llvm \
        zlib1g-dev \
        xz-utils &amp;&amp; \
    rm -rf /var/lib/apt/lists/*
</code></pre>

<p>在本例中，我们可以学习几个最佳实践:</p>
<ul>
  <li>当使用不以root用户身份运行的映像时，需要在一些命令前加上前缀<code>sudo</code>。</li>
  <li>在脚本场景中，总是使用<code>apt-get</code>而不是<code>apt</code>。前者更适合没有人类的环境，而后者更适合在你自己的本地计算机上摆弄。</li>
  <li>当用软件包管理器安装时，当软件包管理器试图询问一个问题时，像<code>-y</code>这样的标志被用来假定“是”。</li>
  <li>每行按字母顺序列出一个包。使用git和GitHub创造奇迹。这使得阅读源代码更加愉快，当查看PR差异时，可以非常清楚地看到哪些包被添加或删除。</li>
  <li>最后一行删除图像中的Apt缓存。这有助于缓存，但更重要的是减小了图像的大小。</li>
</ul>

<pre><code class="language-Dockerfile">ENV GO_VERSION=1.14.1
RUN curl -sSL "https://golang.org/dl/go${GO_VERSION}.linux-amd64.tar.gz" | \
    sudo tar -xz -C /usr/local/
</code></pre>

<p>这个例子给了我们另外两个提示:</p>
<ul>
  <li>将频繁变化的字符串设置为环境变量，可以更直观地管理变化。尤其是因为ENV指令在Docker中不算一个层。当该值在即将到来的<code>RUN</code>指令中被多次使用时，这种技术大大提高了效率。</li>
  <li>在这里，cURL下载了一个tarball，并将其直接传送到下一个命令tar中。这允许我们避免将文件保存到文件系统中，这样速度更快，也避免了事后清理tarball。在你不能使用这个技巧的情况下，不要忘记用<code>rm</code>删除tarball、zip包等来清理自己。</li>
</ul>

<h3>缓存和效率</h3>
<p>对于较大的图像，指令的顺序很重要。您希望<code>RUN</code>变化频繁的步骤靠近docker文件的底部，而变化不频繁的步骤应该靠近顶部。这是因为Docker按层缓存图像。每当一个层发生变化时，该层及其下的层都需要重新缓存。这种行为在Docker的<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/"> Dockerfile最佳实践指南</a>中有更详细的解释。</p>

<p>另一个效率项目是图像层应该尽可能的精简。不需要的文件应该在创建它的<code>RUN</code>步骤中删除，这样可以使该层的整体尺寸更小。</p>

<h2>维护形象</h2>
<p>创建自定义图像只是工作的一半。一旦该映像存在，就需要进行维护。随着您的CI需求的变化和增长，您的形象也需要随之调整。</p>

<h3>你的Dockerfile的家</h3>
<p>让你的docker文件处于版本控制之下。有些人喜欢将这个docker文件保存在与他们需要它的项目相同的存储库中。其他人，比如我自己，更喜欢把它放在自己的仓库里。</p>

<p>我更喜欢单独的回购途径，因为:</p>
<ul>
  <li>当它与项目在同一个repo中时，该项目的CircleCI配置会变得更加复杂。您不希望在每次提交主项目时都构建Docker映像。那是浪费时间，代价昂贵。为了避免这种情况，您需要在构建项目和图像时进行逻辑分离。</li>
  <li>作为一个独立的回购，它使得在您的公司或团队的多个项目中使用该图像变得更加容易。</li>
</ul>

<h3>保持Dockerfile文件最新</h3>
<p>当在docker文件中添加或删除内容时，用您的更改创建一个新的分支，检查并合并。标准的东西。Docker映像的某些部分会在Docker文件之外进行更新。我们如何保持这些部分的更新？</p>

<p>您的基础映像是它自己的项目，并按照自己的时间表进行更新。例如，CircleCI base便利映像每个月会进行一次稳定的更新。如果您下载并安装文件名为<code>example.com/download/some-thing-4.3.x.tar.gz</code>的软件，您将需要确保使用该软件可用的最新补丁版本更新您的映像。我们通过CircleCI <a href="https://circleci.com/docs/workflows/">计划工作流</a>来实现这一点。</p>

<p>使用预定的工作流程发布您的自定Docker图像可让您定期更新图像的背景部分，而无需您进行任何手动操作。这样做的频率取决于你的个人需求。CircleCI基础映像每月2日更新。如果你以此为基础，你自己在3号或5号安排的每月工作流程会很好。</p>

<h3>托管图像</h3>
<p>您可以选择在哪里托管您发布的Docker图像。存放Docker映像的地方称为Docker注册表。托管Docker映像的实际位置是Docker Hub。如果你对其他任何注册表都不熟悉，坚持使用DockerHub就没问题了。它可以免费使用，即使是私人图像。</p>

<p>如果您使用领先的云提供商进行托管，他们可能会有一个Docker注册表供您使用，我们可能会为该提供商提供一个<a href="https://circleci.com/orbs/"> CircleCI orb </a>,使所有这些设置更加容易。以下是主要的Docker注册表和相应的orb:</p>



<h2>讨论和反馈</h2>
<p>要进一步讨论这个话题或提出问题，请访问我们的<a href="https://discuss.circleci.com/"> CircleCI讨论</a>论坛。你可以找到我和CircleCI的用户，他们就像你一样，随时准备讨论和提供帮助。</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>
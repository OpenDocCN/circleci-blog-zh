<html>
<head>
<title>Infrastructure as Code part 1: create a Kubernetes cluster with Terraform | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>基础设施代码第1部分:用Terraform | CircleCI创建一个Kubernetes集群</h1>
<blockquote>原文：<a href="https://circleci.com/blog/learn-iac-part1/#2021-11-08T08:00:00-08:00">https://circleci.com/blog/learn-iac-part1/#2021-11-08T08:00:00-08:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>本系列向您展示如何开始使用基础设施即代码(IaC)。目标是通过教程和代码示例帮助开发人员加深对IaC的理解。</p>

<p>基础设施即代码(IaC)是现代<a href="https://circleci.com/continuous-integration/">持续集成</a>管道不可或缺的一部分。它是使用机器可读的定义文件管理和调配云和It资源的过程。IaC通过在代码中静态定义和声明计算资源，为组织提供了创建、管理和销毁这些资源的工具。</p>

<p>以下是本系列将涵盖的主题:</p>



<p>在本帖中，我将讨论如何使用<a href="https://www.terraform.io/"> HashiCorp的Terraform </a>来供应、部署和销毁基础设施资源。在我们开始之前，您需要在目标云提供商和服务中创建帐户，如<a href="https://cloud.google.com/free">谷歌云</a>和<a href="https://app.terraform.io/signup/account"> Terraform云</a>。然后你可以开始学习如何使用Terraform创建一个新的<a href="https://cloud.google.com/kubernetes-engine"> Google Kubernetes引擎(GKE)集群</a></p>

<h2>先决条件</h2>

<p>在开始之前，您需要准备好这些东西:</p>



<p>这篇文章使用了<a href="https://github.com/datapunkz/learn_iac">这个回购</a>的<code>part01</code>文件夹中的代码。不过首先，你需要创建GCP凭证，然后Terraform。</p>

<h2>创建GCP项目凭据</h2>
<p>GCP凭证将允许您使用IaC工具执行管理操作。要创建它们:</p>

<ol>
  <li>转到<a href="https://console.cloud.google.com/apis/credentials/serviceaccountkey">创建服务帐户密钥</a>页面</li>
  <li>选择默认服务帐户或创建一个新帐户</li>
  <li>选择JSON作为键类型</li>
  <li>点击<strong>创建</strong></li>
  <li>将这个JSON文件保存在<code>~/.config/gcloud/</code>目录中(可以重命名)</li>
</ol>

<h2>HashiCorp Terraform是如何工作的？</h2>

<p>HashiCorp Terraform 是一款开源工具，用于安全高效地构建、更改和管理基础设施。Terraform可以管理现有的服务提供商以及定制的内部解决方案。</p>

<p>Terraform使用配置文件来描述运行单个应用程序或整个数据中心所需的组件。它生成一个执行计划，描述它将做什么来达到期望的状态，然后执行它来构建该计划所描述的基础结构。随着配置的变化，Terraform会确定发生了哪些变化，并创建可用于更新基础架构资源的增量执行计划。</p>

<p>Terraform用于创建、管理和更新基础设施资源，如物理机、虚拟机、网络交换机、容器等。Terraform可以管理的组件包括低级基础架构组件，如计算实例、存储和网络，以及高级组件，如DNS条目和SaaS功能。</p>

<p>几乎任何基础设施类型都可以在Terraform中表示为资源。</p>

<h3>什么是Terraform提供商？</h3>

<p>提供者负责理解API交互和公开资源。提供商可以是IaaS(阿里云、AWS、GCP、微软Azure、OpenStack)、PaaS(比如Heroku)或者SaaS服务(Terraform Cloud、DNSimple、Cloudflare)。</p>

<p>在这一步中，我们将使用Terraform代码在<a href="https://cloud.google.com/free"> GCP </a>提供一些资源。我们想编写Terraform代码，定义并创建一个新的<a href="https://cloud.google.com/kubernetes-engine"> GKE集群</a>，我们可以在本系列的第2部分中使用它。</p>

<p>为了创建一个新的<a href="https://cloud.google.com/kubernetes-engine"> GKE集群</a>，我们需要依靠<a href="https://www.terraform.io/docs/providers/google/index.html"> GCP提供商</a>与GCP进行交互。一旦定义和配置了提供者，我们就可以在GCP上构建和控制地形<a href="https://www.terraform.io/docs/configuration/resources.html">资源</a>。</p>

<h3>什么是Terraform资源？</h3>

<p><a href="https://www.terraform.io/docs/configuration/resources.html">资源</a>是地形语言中最重要的元素。每个资源块描述一个或多个基础设施对象。基础设施对象可以是虚拟网络、计算实例或更高级别的组件，如DNS记录。一个资源块声明了一个给定类型(<code>google_container_cluster</code>)的资源，它有一个给定的本地名称，比如“web”。该名称用于从同一Terraform模块的其他地方引用该资源，但它在模块范围之外没有任何意义。</p>

<h2>理解Terraform代码</h2>

<p>既然您对Terraform <a href="https://www.terraform.io/docs/providers/google/index.html">提供者</a>和<a href="https://www.terraform.io/docs/configuration/resources.html">资源</a>有了更好的理解，那么是时候开始深入研究代码了。Terraform代码保存在目录中。因为我们使用的是<a href="https://www.terraform.io/docs/cli-index.html"> CLI工具</a>，所以您必须从代码所在的根目录中执行命令。对于本教程，我们使用的Terraform代码位于<code>part01/iac_gke_cluster</code>文件夹<a href="https://github.com/datapunkz/learn_iac">这里</a>。该目录包含这些文件:</p>

<ul>
  <li>providers.tf</li>
  <li>变量. tf</li>
  <li>main.tf</li>
  <li>输出. tf</li>
</ul>

<p>这些文件代表了我们将要创建的GCP资源基础结构。这就是地形的过程。您可以将所有的Terraform代码放在一个文件中，但是一旦语法变得越来越多，管理起来就会变得越来越困难。大多数Terraform开发人员为每个元素创建一个单独的文件。这里是每个文件的快速分解，并讨论每个文件的关键元素。</p>

<h3>细分:providers.tf</h3>

<p><code>provider.tf</code>文件是我们定义将要使用的云提供商的地方。我们将使用<a href="https://www.terraform.io/docs/providers/google/index.html"> google_container_cluster提供者</a>。这是<code>provider.tf</code>文件的内容:</p>

<pre><code>provider "google" {
  # version     = "2.7.0"
  credentials = file(var.credentials)
  project     = var.project
  region      = var.region
}
</code></pre>

<p>该代码块在闭包<code>{  }</code>块中有参数。<code>credentials</code>块指定您之前创建的GCP凭证的JSON文件的文件路径。注意，参数值以<code>var</code>为前缀。<code>var</code>前缀定义了<a href="https://www.terraform.io/docs/configuration/variables.html"> Terraform输入变量</a>的用法，用作Terraform模块的参数。这允许在不改变模块自己的源代码的情况下定制模块的各个方面，并且允许在不同的配置之间共享模块。在配置的根模块中声明变量时，可以使用CLI选项和环境变量来设置它们的值。当您在子模块中声明它们时，调用模块将在模块块中传递值。</p>

<h3>细分:变量. tf</h3>

<p><code>variables.tf</code>文件指定了这个Terraform项目使用的所有输入变量。</p>

<pre><code>variable "project" {
  default = "cicd-workshops"
}

variable "region" {
  default = "us-east1"
}

variable "zone" {
  default = "us-east1-d"
}

variable "cluster" {
  default = "cicd-workshops"
}

variable "credentials" {
  default = "~/.ssh/cicd_demo_gcp_creds.json"
}

variable "kubernetes_min_ver" {
  default = "latest"
}

variable "kubernetes_max_ver" {
  default = "latest"
}
</code></pre>

<p>该文件中定义的变量将在整个项目中使用。所有这些变量都有<code>default</code>值，但是这些值可以在执行Terraform代码时通过CLI定义来更改。这些变量为代码增加了非常必要的灵活性，并使重用有价值的代码成为可能。</p>

<h3>细分:main.tf</h3>

<p><code>main.tf</code>文件定义了我们的大部分GKE集群参数。</p>

<pre><code>terraform {
  required_version = "~&gt;0.12"
  backend "remote" {
    organization = "datapunks"
    workspaces {
      name = "iac_gke_cluster"
    }
  }
}

resource "google_container_cluster" "primary" {
  name               = var.cluster
  location           = var.zone
  initial_node_count = 3

  master_auth {
    username = ""
    password = ""

    client_certificate_config {
      issue_client_certificate = false
    }
  }

  node_config {
    machine_type = var.machine_type
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
    ]

    metadata = {
      disable-legacy-endpoints = "true"
    }

    labels = {
      app = var.app_name
    }

    tags = ["app", var.app_name]
  }

  timeouts {
    create = "30m"
    update = "40m"
  }
}
</code></pre>

<p>以下是对从<code>terraform</code>块开始的<code>main.tf</code>文件的每个元素的描述。该块指定了<a href="https://www.terraform.io/docs/backends/index.html">地形后端</a>的类型。Terraform中的一个“后端”决定了如何加载状态，以及如何执行一个操作，如<code>apply</code>。这种抽象支持非本地文件状态存储和远程执行。在这个代码块中，我们使用的是使用Terraform Cloud的<code>remote</code>后端，它连接到您在先决条件部分创建的<code>iac_gke_cluster</code>工作区。</p>

<pre><code>terraform {
  required_version = "~&gt;0.12"
  backend "remote" {
    organization = "datapunks"
    workspaces {
      name = "iac_gke_cluster"
    }
  }
}
</code></pre>

<p>下一个代码块定义了我们将要创建的<a href="https://cloud.google.com/kubernetes-engine"> GKE集群</a>。我们还使用了<code>variables.tf</code>中定义的一些变量。<code>resource</code>块有许多用于在GCP上供应和配置GKE集群的参数。这里的重要参数是<code>name</code>、<code>location</code>和<code>Initial_node_count</code>，它们指定了将组成这个新集群的计算资源或虚拟机的初始总数。我们将从该集群的三个计算节点开始。</p>

<pre><code>resource "google_container_cluster" "primary" {
  name               = var.cluster
  location           = var.zone
  initial_node_count = 3

  master_auth {
    username = ""
    password = ""

    client_certificate_config {
      issue_client_certificate = false
    }
  }

  node_config {
    machine_type = var.machine_type
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
    ]

    metadata = {
      disable-legacy-endpoints = "true"
    }

    labels = {
      app = var.app_name
    }

    tags = ["app", var.app_name]
  }

  timeouts {
    create = "30m"
    update = "40m"
  }
}
</code></pre>

<h3>细分:output.tf</h3>

<p>Terraform使用一种叫做<a href="https://docs.docker.com/get-docker/">的输出值</a>。这些函数返回Terraform模块的值，并为子模块提供输出。子模块输出向父模块公开其资源属性的子集，或者在运行<code>terraform apply</code>后在CLI输出中打印某些值。以下代码示例中显示的<code>output.tf</code>块输出值，以读出集群名称、集群端点以及敏感数据等值，这些值由<code>sensitive</code>参数指定。</p>

<pre><code>
output "cluster" {
  value = google_container_cluster.primary.name
}

output "host" {
  value     = google_container_cluster.primary.endpoint
  sensitive = true
}

output "cluster_ca_certificate" {
  value     = base64decode(google_container_cluster.primary.master_auth.0.cluster_ca_certificate)
  sensitive = true
}

output "username" {
  value     = google_container_cluster.primary.master_auth.0.username
  sensitive = true
}

output "password" {
  value     = google_container_cluster.primary.master_auth.0.password
  sensitive = true
}
</code></pre>

<h2>初始化地形</h2>

<p>现在我们已经介绍了Terraform项目和语法，您可以开始使用Terraform配置GKE集群了。将目录切换到<code>part01/iac_gke_cluster</code>文件夹:</p>

<pre><code>cd part01/iac_gke_cluster
</code></pre>

<p>在<code>part01/iac_gke_cluster</code>中，运行以下命令:</p>

<pre><code>terraform init
</code></pre>

<p>您的输出应该如下所示:</p>

<pre><code>root@d9ce721293e2:~/project/terraform/gcp/compute# terraform init

Initializing the backend...

Initializing provider plugins...
- Checking for available provider plugins...
- Downloading plugin for provider "google" (hashicorp/google) 3.10.0...

* provider.google: version = "~&gt; 3.10"

Terraform has been successfully initialized!
</code></pre>

<h3>使用地形预览</h3>

<p>Terraform有一个命令，允许您在不实际执行任何操作的情况下，模拟运行和验证您的Terraform代码。这个命令叫做<code>terraform plan</code>。该命令还显示了Terraform将针对您现有的基础设施执行的所有操作和更改。在终端中，运行:</p>

<pre><code>terraform plan
</code></pre>

<p>输出:</p>

<pre><code>An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # google_container_cluster.primary will be created
  + resource "google_container_cluster" "primary" {
      + additional_zones            = (known after apply)
      + cluster_ipv4_cidr           = (known after apply)
      + default_max_pods_per_node   = (known after apply)
      + enable_binary_authorization = false
      + enable_intranode_visibility = (known after apply)
      + enable_kubernetes_alpha     = false
      + enable_legacy_abac          = false
      + enable_shielded_nodes       = false
      + enable_tpu                  = (known after apply)
      + endpoint                    = (known after apply)
      + id                          = (known after apply)
      + initial_node_count          = 3
      + instance_group_urls         = (known after apply)
      + label_fingerprint           = (known after apply)
      + location                    = "us-east1-d"
  }....
Plan: 1 to add, 0 to change, 0 to destroy.  
</code></pre>

<p>Terraform将根据<code>main.tf</code>文件中的代码为您创建新的GCP资源。</p>

<h3>地形应用</h3>

<p>现在，您可以创建新的基础设施并部署应用程序。在终端中运行以下命令:</p>

<pre><code>terraform apply
</code></pre>

<p>Terraform将提示您确认您的命令。键入<code>yes</code>并按回车键。</p>

<pre><code>Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes
</code></pre>

<p>Terraform将在GCP建立新的GKE集群。</p>

<p><strong>注意</strong> : <i>集群需要3-5分钟才能完成。这不是一个即时的过程，因为后端系统正在进行资源调配并使其上线。</i></p>

<p>在我的集群完成之后，这是我的输出:</p>

<pre><code>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.

Outputs:

cluster = cicd-workshops
cluster_ca_certificate = &lt;sensitive&gt;
host = &lt;sensitive&gt;
password = &lt;sensitive&gt;
username = &lt;sensitive&gt;
</code></pre>

<p>新的GKE集群已经创建，并显示了<code>Outputs</code>结果。请注意，标记为敏感的输出值在结果中用<code>&lt;sensitive&gt;</code>标记屏蔽了。这确保敏感数据受到保护，但在需要时可用。</p>

<h3>使用地形摧毁</h3>

<p>现在您已经证明您的GKE集群已经成功创建，运行<code>terraform destroy</code>命令来销毁您在本教程中创建的资产。你可以让它继续运行，但是要知道，在GCP上运行任何资产都是有成本的，你要对这些成本负责。谷歌为其免费试用注册提供了慷慨的300美元信用，但如果你让资产运行，你可以很容易地吃掉它。这取决于你，但是运行<code>terraform destroy</code>将会终止任何正在运行的资产。</p>

<p>运行以下命令销毁GKE集群:</p>

<pre><code>terraform destroy
</code></pre>

<h2>结论</h2>

<p>恭喜你！您刚刚完成了本系列的第1部分，并通过使用IaC和<a href="https://www.terraform.io/"> Terraform </a>将Kubernetes集群配置和部署到GCP，提升了您的体验。</p>

<p>继续本教程的<a href="https://circleci.com/blog/learn-iac-part02/">第2部分</a>。在第2部分中，您将学习如何为应用程序构建Docker映像，将该映像推送到存储库，然后使用Terraform将该映像作为容器部署到使用Terraform的GKE。</p>

<p>这里有一些资源可以帮助你扩大知识面:</p>





        
          
          
        
      </div>
    </div>    
</body>
</html>
<html>
<head>
<title>Clojure Web Framework using Docker - Clojure web development | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Clojure Web框架使用Docker - Clojure web开发| CircleCI</h1>
<blockquote>原文：<a href="https://circleci.com/blog/package-a-clojure-web-application-using-docker/#2019-03-19T12:00:00-07:00">https://circleci.com/blog/package-a-clojure-web-application-using-docker/#2019-03-19T12:00:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>这是关于构建、测试和部署Clojure web应用程序的系列文章的第二篇。你可以在这里找到第一帖<a href="https://circleci.com/blog/build-a-clojure-web-app-using-duct/" target="_blank" rel="noreferrer noopener">，在这里</a>找到第三帖<a href="https://circleci.com/blog/deploy-a-clojure-web-application-to-aws-using-terraform/" target="_blank" rel="noreferrer noopener">。</a></p>

<p>在这篇文章中，我们将关注如何向应用程序添加生产数据库(在本例中是PostgreSQL ),如何将应用程序打包为Docker实例，以及如何在Docker中运行应用程序和数据库。为了跟进，我建议浏览第一篇文章，并按照步骤创建应用程序。否则，您可以通过分叉<a href="https://github.com/chrishowejones/blog-film-handler" target="_blank" rel="noreferrer noopener">这个</a>存储库并检查主分支来获得源代码。如果你选择这种方法，你还需要按照第一篇文章中的描述设置你的CircleCI账户。</p>



<p>尽管我们正在构建一个Clojure应用程序，但是本系列的这一部分并不需要太多Clojure知识。</p>

<h2>先决条件</h2>

<p>为了构建这个web应用程序，您需要安装以下软件:</p>

<ol>
  <li><a href="https://openjdk.java.net/install/" target="_blank" rel="noreferrer noopener"> Java JDK 8或更高版本</a>——clo jure运行在Java虚拟机上，实际上只是一个Java库(JAR)。我用版本8构建了这个，但是一个更好的版本应该也可以。</li>
  <li><a href="https://leiningen.org/" target="_blank" rel="noreferrer noopener"> Leiningen </a> - Leiningen，通常被称为lein(读作‘line’)是最常用的Clojure构建工具。</li>
  <li>Git  -无处不在的分布式版本控制工具。</li>
  <li>Docker——一个工具，旨在通过使用容器来简化应用程序的创建、部署和运行。</li>
  <li>Docker Compose  -一个定义和运行多容器Docker应用程序的工具。</li>
</ol>

<p>您还需要注册:</p>

<ol>
  <li><a href="https://circleci.com/" target="_blank" rel="noreferrer noopener"> CircleCI账号</a> - CircleCI是一个持续集成和交付平台。</li>
  <li>GitHub账户 - GitHub是一个基于网络的托管服务，使用Git进行版本控制。</li>
  <li>Docker Hub帐户 - Docker Hub是一个基于云的存储库，Docker用户和合作伙伴可以在其中创建、测试、存储和分发容器映像。</li>
</ol>

<h2>运行PostgreSQL数据库</h2>

<p>在本节中，我们将介绍如何运行PostgreSQL数据库，我们将从本博客系列的第一部分中构建的web应用程序连接到该数据库。</p>

<p>我们将使用Docker来“打包”我们的应用程序以进行部署。已经有很多关于为什么以及如何使用Docker 的文章，比我计划在这里讨论的还要详细。我之所以决定使用它，是为了提供与我们要部署到的物理机器的一定程度的隔离，我认为，更重要的是，为了确保应用程序在本地或远程环境之间运行时的运行时行为的一致性。</p>

<p>出于这个原因，最终的游戏将是运行我们在上一篇博客中构建的web应用程序和Docker中的PostgreSQL数据库，并让两者进行通信。</p>

<p>该应用程序当前在开发模式下运行时使用SQLite。在博客系列的第一部分中，我们只在开发模式下运行，要么使用<code>lein repl</code>从REPL运行服务器，要么使用<code>lein test</code>运行单元测试。如果我们通过从我们的项目目录中发出<code>lein run</code>命令，尝试在生产模式下运行应用程序，我们将得到一个错误，因为没有指定生产数据库连接。</p>

<pre><code class="language-bash">$ lein run
Exception in thread "main" clojure.lang.ExceptionInfo: Error on key :duct.database.sql/hikaricp when building system {:reason :integrant.core/build-threw-exception ...
</code></pre>

<p>我们将使用官方的<a href="https://circleci.com/docs/postgres-config/"> postgres Docker映像</a> (alpine版本)在Docker容器中运行数据库。为此，我们可以发出以下命令:</p>

<pre><code class="language-bash">$ docker run -p 5432:5432 -e POSTGRES_USER=filmuser -e POSTGRES_DB=filmdb -e POSTGRES_PASSWORD=password postgres:alpine
...
2019-01-20 10:08:32.064 UTC [1] LOG:  database system is ready to accept connections
</code></pre>

<p>这个命令运行postgres Docker镜像(如果需要，从Docker Hub中下载),数据库监听TCP端口5432，设置一个名为<code>filmuser</code>的默认用户，将该用户的密码设置为<code>password</code>,并创建一个名为<code>filmdb</code>的空数据库。如果您已经将PostgreSQL作为一项服务安装在您的计算机上，您可能会收到一条关于端口5432正在使用的消息。如果发生这种情况，要么停止本地PostgreSQL服务，要么更改<code>-p 5432:5432</code>条目以公开不同的端口，例如端口5500 <code>-p 5500:5432</code>。</p>

<p>为了检查您是否可以连接到数据库，请在不同的终端窗口中发出以下命令:</p>

<pre><code class="language-bash">psql -h localhost -p 5432 -U filmuser filmdb
Password for user filmuser:
psql (11.1 (Ubuntu 11.1-1.pgdg16.04+1))
Type "help" for help.

filmdb=#
</code></pre>

<p>虽然您现在已经连接到了数据库，但是此时您还不能做很多事情，因为我们还没有创建任何表、视图等(关系)。</p>

<pre><code>filmdb=# \d
Did not find any relations.
</code></pre>

<p>所以让我们关闭psql实用程序。</p>

<pre><code class="language-bash">filmdb=# exit
</code></pre>

<p>接下来，让postgres的Docker容器保持运行，并更改我们的应用程序，使其具有可以连接到数据库的生产配置。</p>

<p>打开电影分级项目目录中的<code>resources/film_ratings/config.edn</code>文件。然后找到<code>:duct.module/sql</code>条目，并在它下面添加以下内容:</p>

<pre><code class="language-edn">:duct.database.sql/hikaricp {:adapter "postgresql"
                              :port-number #duct/env [ "DB_PORT" :or "5432" ]
                              :server-name #duct/env [ "DB_HOST" ]
                              :database-name "filmdb"
                              :username "filmuser"
                              :password #duct/env [ "DB_PASSWORD" ]}
</code></pre>

<p>此条目使用PostgreSQL定义了光连接池的配置。注意，我们从<a href="https://circleci.com/docs/env-vars/">环境变量</a> <code>DB_HOST</code>和<code>DB_PASSWORD</code>中获取服务器名称和密码。我们还考虑了一个可选的环境变量<code>DB_PORT</code>，但是如果需要的话，可以用来设置应用程序连接到不同的端口而不是<code>5432</code>。</p>

<p>您还需要在<code>project.clj</code>文件中添加PostgreSQL数据库驱动程序和hikaricp库的依赖项，因此依赖项部分如下所示:</p>

<pre><code class="language-clojure">:dependencies [[org.clojure/clojure "1.9.0"]
                 [duct/core "0.6.2"]
                 [duct/module.logging "0.3.1"]
                 [duct/module.web "0.6.4"]
                 [duct/module.ataraxy "0.2.0"]
                 [duct/module.sql "0.4.2"]
                 [org.xerial/sqlite-jdbc "3.21.0.1"]
                 [org.postgresql/postgresql "42.1.4"]
                 [duct/database.sql.hikaricp "0.3.3"]
                 [hiccup "1.0.5"]]
</code></pre>

<p>此外，我们希望在插入一部新电影时，<code>id</code>列被自动分配一个唯一的编号，因此我们需要稍微改变一下迁移，以便<code>id</code>列的类型不再是整数(适用于SQLite ),而是PostgreSQL中的类型<code>serial</code>。这意味着您需要将<code>resources/film_ratings/config.edn</code>中的migrator ragtime条目更改为:</p>

<pre><code class="language-edn">[:duct.migrator.ragtime/sql :film-ratings.migrations/create-film]
 {:up ["CREATE TABLE film (id SERIAL PRIMARY KEY, name TEXT UNIQUE, description TEXT, rating INTEGER)"]
  :down ["DROP TABLE film"]}
</code></pre>

<p>为了测试这个配置，首先需要设置环境变量。因此，从运行Docker postgres实例的终端窗口中打开一个单独的终端窗口，并像这样设置两个环境变量:</p>

<pre><code class="language-bash">$ export DB_HOST=localhost
$ export DB_PASSWORD=password
</code></pre>

<p><strong>注意</strong> : <i>如果您必须更改postgres Docker实例正在使用的端口号，您还需要将<code>DB_PORT</code>环境变量设置为相同的端口号。</i></p>

<p>一旦您设置了这些环境变量，您就可以在生产配置文件中运行应用程序，如下所示(首先将目录更改为您的项目根目录):</p>

<pre><code class="language-bash">$ lein run
lein run
19-01-21 07:19:51 chris-XPS-13-9370 REPORT [duct.server.http.jetty:13] - :duct.server.http.jetty/starting-server {:port 3000}
</code></pre>

<p>正如您从输出中看到的，我们的迁移(在博客的第一部分中定义)并不是为了插入<code>film</code>表而运行的。默认情况下，迁移不是通过生产配置文件中的管道运行的，但是我们将在以后解决这个问题。为了创建<code>film</code>表，我们可以通过打开另一个终端会话并执行以下命令来手动运行我们的迁移(在设置环境变量并将目录更改为项目根目录之后):</p>

<pre><code class="language-bash">$ lein run :duct/migrator
19-01-21 07:48:59 chris-XPS-13-9370 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["CREATE TABLE ragtime_migrations (id varchar(255), created_at varchar(32))"], :elapsed 4}
19-01-21 07:48:59 chris-XPS-13-9370 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["SELECT id FROM ragtime_migrations ORDER BY created_at"], :elapsed 6}
19-01-21 07:48:59 chris-XPS-13-9370 REPORT [duct.migrator.ragtime:14] - :duct.migrator.ragtime/applying :film-ratings.migrations/create-film#11693a5d
19-01-21 07:48:59 chris-XPS-13-9370 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["CREATE TABLE film (id SERIAL PRIMARY KEY, name TEXT UNIQUE, description TEXT, rating INTEGER)"], :elapsed 10}
19-01-21 07:48:59 chris-XPS-13-9370 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["INSERT INTO ragtime_migrations ( id, created_at ) VALUES ( ?, ? )" ":film-ratings.migrations/create-film#11693a5d" "2019-01-21T07:48:59.960"], :elapsed 4}
19-01-21 07:48:59 chris-XPS-13-9370 INFO [duct.database.sql.hikaricp:31] - :duct.database.sql/batch-query {:queries [], :elapsed 0}
</code></pre>

<p>您现在可以通过打开浏览器并指向<code>http://localhost:3000</code>来测试正在运行的应用程序。</p>

<p>如果您尝试添加电影，您将看到一条错误消息，指出列<code>rating</code>是整数类型，但提供的值是字符类型。</p>

<p><img src="../Images/6a89a9ff9267728f2599885440079fb5.png" alt="" data-original-src="https://d2mxuefqeaa7sj.cloudfront.net/s_1709B150038126562194B8C85BDF23241601D3144C4846566FE6570C9886A7F9_1548508414636_ratings-error.png"/></p>

<p>这是因为add film表单中的所有值都是字符串，但是<code>film</code>表中的<code>ratings</code>列需要一个<code>INTEGER</code>。在我们的开发模式下不会发生这种情况，因为SQLite数据库驱动程序将评级的字符串值强制转换为整数，但PostgreSQL驱动程序不会。这说明使用不同的数据库进行生产和开发可能会有问题！</p>

<p>现在，让我们修复处理程序中的这个错误。编辑<code>src/film_ratings/handler/film.clj</code>文件，将处理电影形式的代码重构为一个单独的函数，该函数还处理将<code>ratings</code>强制为整数的操作:</p>

<pre><code class="language-clojure">(defn- film-form-&gt;film
  [film-form]
  (as-&gt; film-form film
    (dissoc film "__anti-forgery-token")
    (reduce-kv (fn [m k v] (assoc m (keyword k) v))
               {}
               film)
    (update film :rating #(Integer/parseInt %))))

(defmethod ig/init-key :film-ratings.handler.film/create [_ {:keys [db]}]
  (fn [{[_ film-form] :ataraxy/result :as request}]
    (let [film (film-form-&gt;film film-form)
          result (boundary.film/create-film db film)
          alerts (if (:id result)
                   {:messages ["Film added"]}
                   result)]
      [::response/ok (views.film/film-view film alerts)])))
</code></pre>

<p>为了测试这一点，停止运行应用程序的服务器并重新启动它(CTRL-C停止，<code>lein run</code>重新启动)。然后将您的浏览器指向<code>http://localhost:3000</code>并试用该应用程序。</p>

<p>一旦您对一切正常感到满意，现在您可以使用CTRL-C关闭服务器，并通过在运行Docker实例的终端会话中发出CTRL-C来关闭Docker postgres实例。</p>

<p>为了确保我们没有破坏任何东西，我们可以尝试在开发模式下运行服务器，这应该使用SQLite数据库实例。</p>

<pre><code class="language-bash">$ lein repl
 lein repl
nREPL server started on port 38553 on host 127.0.0.1 - nrepl://127.0.0.1:38553
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.9.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_191-b12
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&gt; (dev)
:loaded
dev=&gt; (go)
Jan 20, 2019 12:16:20 PM org.postgresql.Driver connect
SEVERE: Connection error:
org.postgresql.util.PSQLException: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.
</code></pre>

<p>我们的配置应用方式有问题。这里不使用<code>dev/resources/dev.edn</code>中的配置:</p>

<pre><code class="language-edn">:duct.module/sql
{:database-url "jdbc:sqlite:db/dev.sqlite"}
</code></pre>

<p>我们似乎在<code>resources/config.edn</code>中至少获得了一些postgres配置。实际发生的是开发配置和生产配置映射被合并。因此，postgres适配器配置和其余的键-值对被添加到<code>:database-url</code>中。我们需要解决这个问题，所以让我们在<code>dev/src/dev.clj</code>文件中添加一些代码来删除这些生产数据库属性。让我们添加一个函数来完成这项工作，并从对<code>set-prep!</code>的调用中调用这个新函数:</p>

<pre><code class="language-clojure">(defn remove-prod-database-attributes
  "The prepared config is a merge of dev and prod config and the prod attributes for 
  everything except :jdbc-url need to be dropped or the sqlite db is 
  configured with postgres attributes"
  [config]
  (update config :duct.database.sql/hikaricp 
    (fn [db-config] (-&gt;&gt; (find db-config :jdbc-url) (apply hash-map)))))

(integrant.repl/set-prep! 
  (comp remove-prod-database-attributes duct/prep read-config))
</code></pre>

<p>现在，如果我们像这样在开发模式下运行服务器(使用<code>quit</code>退出之前运行的repl):</p>

<pre><code class="language-bash">$ lein repl
nREPL server started on port 44721 on host 127.0.0.1 - nrepl://127.0.0.1:44721
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.9.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_191-b12
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&gt; (dev)
:loaded
dev=&gt; (go)
:duct.server.http.jetty/starting-server {:port 3000}
:initiated
dev=&gt;
</code></pre>

<p><strong>注意:</strong> <i>如果你克隆了我的回购协议，而不是按照之前的博客，你可能会看到这样的错误:<code>SQLException path to 'db/dev.sqlite': '.../blog-film-ratings/db' does not</code> <code>exist org.sqlite.core.CoreConnection.open (CoreConnection.java:192)</code>。在这种情况下，使用<code>mkdir db</code>在项目根目录下手动创建一个空的‘db’目录，然后重试repl命令。</i></p>

<p>我们可以看到服务器现在成功启动，并连接到SQLite数据库。现在，让我们提交我们的更改。</p>

<pre><code class="language-bash">$ git add --all .
$ git commit -m "Add production database config, dependencies &amp; fix dev db config"
$ git push
</code></pre>

<h2>在Docker中运行我们的应用程序</h2>

<p>学习了如何在Docker中运行PostgreSQL数据库，以及如何从我们的应用程序连接到它，下一步是在Docker中运行我们的应用程序。</p>

<p>我们将添加一个Docker文件以在Docker中构建我们的应用程序，并且我们将使用<a href="https://circleci.com/docs/docker-compose/"> Docker Compose </a>在它们自己的网络中同时运行我们的应用程序Docker实例和postgres Docker实例。</p>

<p>在我们创建docker文件之前，让我们检查一下我们的web应用程序将如何在docker文件中实际运行。到目前为止，我们一直使用repl在开发模式下运行我们的应用程序，或者使用lein在生产模式下运行我们的应用程序。</p>

<p>通常，Clojure应用程序在生产中的运行方式与Java应用程序相同。最常见的是将应用程序编译成。类文件，然后将它们打包在一个Uberjar中，这是一个包含所有。我们的应用程序所需的类文件和所有依赖库(jar文件)以及任何资源文件(例如，我们的配置文件)。然后，这个Uberjar将使用JVM (Java虚拟机)运行。</p>

<p>在我们必须在Docker内部运行应用程序之前，让我们尝试在本地以这种方式运行我们的应用程序。首先，我们可以使用以下命令在Uberjar中编译和打包我们的应用程序:</p>

<pre><code class="language-bash">$ lein uberjar
Compiling film-ratings.main
Compiling film-ratings.views.template
Compiling film-ratings.views.film
Compiling film-ratings.views.index
Compiling film-ratings.boundary.film
Compiling film-ratings.handler.film
Compiling film-ratings.handler.index
Created /home/chris/circleciblogs/repos/film-ratings/target/film-ratings-0.1.0-SNAPSHOT.jar
Created /home/chris/circleciblogs/repos/film-ratings/target/film-ratings.jar
</code></pre>

<p>这将创建两个JAR文件。标记为快照的那个只包含没有库依赖关系的应用程序，而名为<code>film-ratings.jar</code>的那个是我们的Uberjar，包含所有的依赖关系。我们现在可以从这个Uberjar运行我们的应用程序，但是首先要确保postgres的Docker实例正在运行，并且在发出这个命令之前，已经在终端会话中设置了<code>DB_HOST</code>和<code>DB_PASSWORD</code>环境变量:</p>

<pre><code class="language-bash">$ java -jar target/film-ratings.jar
19-01-22 07:26:20 chris-XPS-13-9370 REPORT [duct.server.http.jetty:13] - :duct.server.http.jetty/starting-server {:port 3000}
</code></pre>

<p>我们现在需要做的是编写一个docker文件来执行这个命令。这意味着我们需要Docker实例拥有一个Java运行时环境(在这种情况下，我们实际上使用的是Java开发工具包环境)。在项目基本目录中创建Dockerfile文件，并添加以下内容:</p>

<pre><code>FROM openjdk:8u181-alpine3.8

WORKDIR /

COPY target/film-ratings.jar film-ratings.jar
EXPOSE 3000

CMD java -jar film-ratings.jar
</code></pre>

<p>您现在可以像这样构建Docker实例:</p>

<pre><code class="language-bash">$ docker build . -t film-ratings-app
Sending build context to Docker daemon  23.71MB
Step 1/5 : FROM openjdk:8u181-alpine3.8
 ---&gt; 04060a9dfc39
Step 2/5 : WORKDIR /
 ---&gt; Using cache
 ---&gt; 2752489e606e
Step 3/5 : COPY target/film-ratings.jar film-ratings.jar
 ---&gt; Using cache
 ---&gt; b282e93eff39
Step 4/5 : EXPOSE 3000
 ---&gt; Using cache
 ---&gt; 15d2e1b9197e
Step 5/5 : CMD java -jar film-ratings.jar
 ---&gt; Using cache
 ---&gt; 2fe0b1e058e5
Successfully built 2fe0b1e058e5
Successfully tagged film-ratings-app:latest
</code></pre>

<p>这创建了一个新的<a href="https://circleci.com/docs/circleci-images/"> Docker图像</a>，并将其标记为<code>film-ratings-app:latest</code>。我们现在可以像这样运行我们的dockerized应用程序:</p>

<pre><code class="language-bash">$ docker run --network host -e DB_HOST=localhost -e DB_PASSWORD=password film-ratings-app
19-01-22 09:12:20 chris-XPS-13-9370 REPORT [duct.server.http.jetty:13] - :duct.server.http.jetty/starting-server {:port 3000}
</code></pre>

<p>但是，我们仍然存在之前遇到的问题，即迁移没有运行。如果您打开浏览器进入<code>http://localhost:3000/list-films</code>，您可以演示这一点。您会看到内部服务器错误，并且会在Docker中运行应用程序的终端会话中看到一个巨大的堆栈跟踪，该跟踪以以下内容结束:</p>

<pre><code class="language-bash">serverErrorMessage: #object[org.postgresql.util.ServerErrorMessage 0x5661cc86 "ERROR: relation \"film\" does not exist\n  Position: 15"]
</code></pre>

<p>为了解决这个问题，我们将做一些实际上不建议可伸缩生产服务器做的事情，让迁移在应用程序启动时运行。更好的方法是在生产环境中有一个单独的Docker实例，它可以按需启动，可能是通过<a href="https://circleci.com/continuous-integration/"> CI </a>管道，在发生变化时运行迁移。为了这篇博客的目的，让我们采用更简单的方法，将我们的主函数改为调用迁移器。打开并编辑<code>src/film_ratings/main.clj</code>文件，如下所示:</p>

<pre><code class="language-clojure">(defn -main [&amp; args]
  (let [keys (or (duct/parse-keys args) [:duct/migrator :duct/daemon])]
    (-&gt; (duct/read-config (io/resource "film_ratings/config.edn"))
        (duct/prep keys)
        (duct/exec keys))))
</code></pre>

<p>这确保了在守护程序启动服务器之前，调用<code>:duct\migrator</code> Integrant键来运行迁移。为了将这一变化加入到我们的Docker映像中，我们需要重新运行<code>lein uberjar</code>和<code>docker build . -t film-ratings-app</code>。然后我们可以在Docker中运行我们的应用程序:</p>

<pre><code class="language-bash">$ docker run --network=host -e DB_HOST=localhost -e DB_PASSWORD=password film-ratings-app
19-01-22 18:08:23 chris-XPS-13-9370 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["CREATE TABLE ragtime_migrations (id varchar(255), created_at varchar(32))"], :elapsed 2}
19-01-22 18:08:23 chris-XPS-13-9370 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["SELECT id FROM ragtime_migrations ORDER BY created_at"], :elapsed 11}
19-01-22 18:08:23 chris-XPS-13-9370 REPORT [duct.migrator.ragtime:14] - :duct.migrator.ragtime/applying :film-ratings.migrations/create-film#11693a5d
19-01-22 18:08:23 chris-XPS-13-9370 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["CREATE TABLE film (id SERIAL PRIMARY KEY, name TEXT UNIQUE, description TEXT, rating INTEGER)"], :elapsed 13}
19-01-22 18:08:23 chris-XPS-13-9370 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["INSERT INTO ragtime_migrations ( id, created_at ) VALUES ( ?, ? )" ":film-ratings.migrations/create-film#11693a5d" "2019-01-22T18:08:23.146"], :elapsed 3}
19-01-22 18:08:23 chris-XPS-13-9370 INFO [duct.database.sql.hikaricp:31] - :duct.database.sql/batch-query {:queries [], :elapsed 0}
19-01-22 18:08:23 chris-XPS-13-9370 REPORT [duct.server.http.jetty:13] - :duct.server.http.jetty/starting-server {:port 3000}
</code></pre>

<p>这一次，我们可以看到在服务器开始添加<code>film</code>表之前，迁移正在运行。现在，如果我们打开指向<code>http://localhost:3000/list-films</code>的浏览器，我们会看到“找不到电影”消息。您可以通过添加一些电影来试用该应用程序。</p>

<p>让我们在继续之前提交这些更改。</p>

<pre><code class="language-bash">$ git add --all .
$ git commit -m "Add Dockerfile &amp; call migrations on startup."
$ git push
</code></pre>

<h2>持久数据</h2>

<p>我们还有一些问题。目前，如果我们停止postgres Docker容器进程并重新启动它，我们将丢失所有的电影。此外，我们通过主机网络在两个Docker容器之间进行通信。这意味着如果您在本地运行PostgreSQL服务器，您将会遇到端口冲突。</p>

<p>让我们通过创建Docker合成文件来解决这两个问题。我们的Docker Compose文件将构建我们的应用程序Docker文件，设置适当的环境变量并启动postgres实例。Docker Compose将通过桥接网络促进应用程序和数据库之间的通信，这样我们就不会在本地主机上发生端口冲突，除了应用程序暴露的端口3000。</p>

<p>在根项目目录中创建一个<code>docker-compose.yml</code>文件，并添加以下内容:</p>

<pre><code class="language-yaml">version: '3.0'
services:
  postgres:
    restart: 'always'
    environment:
      - "POSTGRES_USER=filmuser"
      - "POSTGRES_DB=filmdb"
      - "POSTGRES_PASSWORD=${DB_PASSWORD}"
    volumes:
      - /tmp/postgresdata:/var/lib/postgresql/data
    image: 'postgres:alpine'
  filmapp:
    restart: 'always'
    ports:
      - '3000:3000'
    environment:
      - "DB_PASSWORD=${DB_PASSWORD}"
      - "DB_HOST=postgres"
    build:
      context: .
      dockerfile: Dockerfile
</code></pre>

<p>该文件在docker-compose中注册了两个服务:一个名为postgres，它使用<code>postgres:alpine</code>映像并设置适当的postgres环境变量；另一个名为<code>filmapp</code>，它构建我们的Dockerfile，运行它并公开端口3000并设置它的环境变量。</p>

<p>您还可以看到，我们已经定义了一个卷，该卷将本地机器上的目录<code>/tmp/postgresdata</code>映射到容器上的<code>/var/lib/postgresql/data</code>，该容器是postgres的数据目录。</p>

<p>这意味着，当我们运行docker-compose进程时，存储在数据库中的任何数据都将被写入本地的<code>/tmp/postgresdata</code>,甚至在我们重新启动docker-compose进程后，这些数据也将持续存在。</p>

<p>让我们试试这个。首先，我们构建docker-compose图像(确保您已经首先设置了<code>DB_PASSWORD</code>环境变量)。</p>

<pre><code class="language-bash">$ docker-compose build
postgres uses an image, skipping
Building filmapp
Step 1/5 : FROM openjdk:8u181-alpine3.8
 ---&gt; 04060a9dfc39
Step 2/5 : WORKDIR /
 ---&gt; Using cache
 ---&gt; 2752489e606e
Step 3/5 : COPY target/film-ratings.jar film-ratings.jar
 ---&gt; b855626e4a45
Step 4/5 : EXPOSE 3000
 ---&gt; Running in 7721d74eee62
Removing intermediate container 7721d74eee62
 ---&gt; f7caccf63c3b
Step 5/5 : CMD java -jar film-ratings.jar
 ---&gt; Running in 89b75d045897
Removing intermediate container 89b75d045897
 ---&gt; 48303637af01
Successfully built 48303637af01
Successfully tagged film-ratings_filmapp:latest
</code></pre>

<p>现在，让我们启动docker-compose(首先退出任何正在运行的Docker postgres或filmapp实例)。</p>

<pre><code class="language-bash">$ docker-compose up
Starting film-ratings_filmapp_1  ... done
Starting film-ratings_postgres_1 ... done
Attaching to film-ratings_filmapp_1, film-ratings_postgres_1
...
postgres_1  | 2019-01-22 18:35:58.117 UTC [1] LOG:  database system is ready to accept connections
filmapp_1   | 19-01-22 18:36:06 5d9729ccfdd0 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["CREATE TABLE ragtime_migrations (id varchar(255), created_at varchar(32))"], :elapsed 4}
filmapp_1   | 19-01-22 18:36:06 5d9729ccfdd0 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["SELECT id FROM ragtime_migrations ORDER BY created_at"], :elapsed 11}
filmapp_1   | 19-01-22 18:36:06 5d9729ccfdd0 REPORT [duct.migrator.ragtime:14] - :duct.migrator.ragtime/applying :film-ratings.migrations/create-film#11693a5d
filmapp_1   | 19-01-22 18:36:06 5d9729ccfdd0 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["CREATE TABLE film (id SERIAL PRIMARY KEY, name TEXT UNIQUE, description TEXT, rating INTEGER)"], :elapsed 12}
filmapp_1   | 19-01-22 18:36:06 5d9729ccfdd0 INFO [duct.database.sql.hikaricp:30] - :duct.database.sql/query {:query ["INSERT INTO ragtime_migrations ( id, created_at ) VALUES ( ?, ? )" ":film-ratings.migrations/create-film#11693a5d" "2019-01-22T18:36:06.120"], :elapsed 3}
filmapp_1   | 19-01-22 18:36:06 5d9729ccfdd0 INFO [duct.database.sql.hikaricp:31] - :duct.database.sql/batch-query {:queries [], :elapsed 0}
filmapp_1   | 19-01-22 18:36:06 5d9729ccfdd0 REPORT [duct.server.http.jetty:13] - :duct.server.http.jetty/starting-server {:port 3000}
</code></pre>

<p>从消息中可以看出，我们已经启动了postgres服务，然后是filmapp服务。filmapp服务已经连接到postgres服务(通过在<code>config.edn</code>中拾取的<code>DB_HOST=postgres</code>环境变量)。</p>

<p>filmapp服务已经运行了迁移以添加<code>film</code>表，并且现在正在侦听端口3000。</p>

<p>您现在可以尝试添加一些电影。然后，通过在另一个终端会话中运行项目根目录中的<code>docker-compose down</code>,或者在运行的会话中按CTRL-C键，停止docker-compose进程。</p>

<p>如果您随后使用<code>docker-compose up -d</code>重新启动docker-compose服务，您应该会发现您添加的任何电影数据都被保存了下来。</p>

<p><strong>注意:</strong><i><code>-d</code>标志运行docker-compose detached，因此您必须运行<code>docker-compose logs</code>来查看日志输出，运行<code>docker-compose down</code>来关闭服务。</i></p>

<p>如果您想再次从一个空数据库开始，只需删除<code>/tmp/postgresdata</code>目录并再次调用docker-compose服务。</p>

<p>同样，让我们在继续之前提交docker-compose文件。</p>

<pre><code class="language-bash">$ git add --all .
$ git commit -m "Added docker-compose"
$ git push
</code></pre>

<h2>将Docker映像发布到Docker Hub</h2>

<p>我们几乎已经完成了我们在这个博客中设定的目标。我们想做的最后一件事是将我们的Docker映像推送到Docker Hub，最好作为我们持续集成系统的一部分。</p>

<p>首先，让我们手动操作。</p>

<h3>手动发布到Docker Hub</h3>
<p>如果你还没有这样做，在<a href="https://hub.docker.com/" target="_blank" rel="noreferrer noopener"> Docker Hub </a>上创建一个账户。然后，在您的帐户中创建一个名为<code>film-ratings-app</code>的新存储库。</p>

<p>我们只想发布应用程序的Docker图像，因为我们不会将docker-compose文件用于生产。首先，让我们重新构建Docker映像，并用Docker Hub存储库id(在我的例子中为<code>chrishowejones/film-ratings-app</code>)标记它:</p>

<pre><code class="language-bash">$ docker build . -t chrishowejones/film-ratings-app
Sending build context to Docker daemon  23.72MB
Step 1/5 : FROM openjdk:8u181-alpine3.8
 ---&gt; 04060a9dfc39
Step 2/5 : WORKDIR /
 ---&gt; Using cache
 ---&gt; 2752489e606e
Step 3/5 : COPY target/film-ratings.jar film-ratings.jar
 ---&gt; Using cache
 ---&gt; 60fe31dc32e4
Step 4/5 : EXPOSE 3000
 ---&gt; Using cache
 ---&gt; 672aa852b89a
Step 5/5 : CMD java -jar film-ratings.jar
 ---&gt; Using cache
 ---&gt; 1fdfcd0dc843
Successfully built 1fdfcd0dc843
</code></pre>

<p>然后，我们需要像这样将该映像推送到Docker Hub(记住使用您的Docker Hub存储库，而不是<code>chrishowejones</code>！):</p>

<pre><code class="language-bash">$ docker push chrishowejones/film-ratings-app:latest
The push refers to repository [docker.io/chrishowejones/film-ratings-app]
25a31ca3ed23: Pushed
...
latest: digest: sha256:bcd2d24f7cdb927b4f1bc79c403a33beb43ab5b2395cbb389fb04ea4fa701db2 size: 1159
</code></pre>

<h3>添加CircleCI作业以构建Docker映像</h3>
<p>好了，我们已经证明了可以手动推送。现在，让我们看看如何设置CircleCI，每当我们标记一个版本的存储库时，circle ci就会为我们做这件事。</p>

<p>首先，我们想使用CircleCI的一个名为executors的特性来减少重复。由于这个特性只在2.1版本中引入，我们需要打开我们的<code>.circleci/config.yml</code>文件，并将版本参考从<code>2</code>更改为<code>2.1</code>。</p>

<pre><code class="language-yaml">version: 2.1
jobs:
...
</code></pre>

<p>我们需要添加一个作业来为应用程序构建Docker图像，并添加另一个作业来发布Docker图像。我们将添加两个<a href="https://circleci.com/docs/workflows/">工作流</a>来控制各个构建步骤的运行时间。</p>

<p>让我们首先在文件的顶部添加一个executor，它将声明一些我们希望在两个新任务中重用的有用内容。</p>

<pre><code class="language-yaml">version: 2.1
executors:
    Docker-publisher:
      working_directory: ~/cci-film-ratings # directory where steps will run
      environment:
        IMAGE_NAME: chrishowejones/film-ratings-app
      Docker:
        - image: circleci/buildpack-deps:stretch
jobs:
...
</code></pre>

<p>这个执行器声明了工作目录、本地环境变量<code>IMAGE_NAME</code>，以及一个Docker映像，该映像具有我们支持执行<a href="https://circleci.com/docs/building-docker-images/"> Docker命令</a>所需的buildpack依赖关系。和以前一样，您需要更改图像名称值，以您的Docker Hub用户而不是我的用户作为前缀。</p>

<p>在我们开始添加作业来构建Docker映像之前，我们需要确保在<code>build</code>作业中构建的应用程序的Uberjar持久保存到我们将要编写的新作业中。</p>

<p>所以在<code>build</code>作业的底部，我们需要添加CircleCI命令来持久化工作空间。</p>

<pre><code class="language-yaml">      - run: lein do test, uberjar
      - persist_to_workspace:
          root: ~/cci-film-ratings
          paths:
            - target
</code></pre>

<p>这将持久保存<code>target</code>目录，以便我们可以在新作业中重新附加该目录。现在，让我们将该作业添加到我们的<code>build</code>作业之后:</p>

<pre><code class="language-yaml">   build-docker:
    executor: docker-publisher
    steps:
      - checkout
      - attach_workspace:
          at: .
      - setup_remote_docker
      - run:
          name: Build latest Docker image
          command: docker build . -t $IMAGE_NAME:latest
      - run:
          name: Build tagged Docker image
          command: docker build . -t $IMAGE_NAME:${CIRCLE_TAG}
      - run:
          name: Archive Docker image
          command: docker save -o image.tar $IMAGE_NAME
      - persist_to_workspace:
          root: ~/cci-film-ratings
          paths:
            - ./image.tar
</code></pre>

<p>好了，让我们来看看这个<code>build-docker</code>任务在做什么。首先，我们引用我们的<code>docker-publisher</code>执行器，这样我们就有了工作目录、<code>IMAGE_NAME</code>变量和正确的Docker映像。</p>

<p>接下来，我们检验我们的项目，以便我们有可用的应用程序的<code>Dockerfile</code>。之后，我们将保存的工作空间附加到我们当前的工作目录中，这样我们就可以在Dockerfile的正确路径上获得包含jar的<code>target</code>目录。</p>

<p><code>setup_remote_docker</code>命令创建了一个远离主容器的环境，这是一个Docker引擎，我们可以用它来执行Docker构建/发布事件(尽管其他Docker事件也发生在我们的主容器中)。</p>

<p>接下来的两个run命令在Docker文件上执行Docker构建，并将结果图像分别标记为<code>chrishowejones/film-ratings-app:latest</code>和<code>chrishowejones/film-ratings-app:${CIRCLE_TAG}</code>。在您的情况下，您应该将<code>IMAGE_NAME</code>更改为适合您的<a href="https://circleci.com/blog/build-cicd-piplines-using-docker/"> Docker Hub帐户</a>的前缀，而不是<code>chrishowejones</code>。</p>

<p><code>${CIRCLE_TAG}</code>变量将被插入到与这个构建相关的<a href="https://circleci.com/blog/publishing-to-github-releases-via-circleci/"> GitHub标签</a>中。这里的想法是当我们标记一个commit并将其推送到GitHub时触发这个作业。出于论证的目的，如果我们将提交标记为<code>0.1.0</code>并将其推送到GitHub，当我们的<code>build-docker</code>作业运行时，它将构建一个标记为<code>latest</code>的Docker映像，但也会构建相同的映像并将其标记为<code>0.1.0</code>。</p>

<p><code>docker save</code>命令将<code>IMAGE_NAME</code>的所有Docker图像保存到一个tar存档文件中，然后我们在<code>persist-to-workspace</code>命令中保存该文件，这样我们可以在下一个任务中使用它。</p>

<p><strong>添加CircleCI作业以发布到Docker Hub </strong></p>

<p>我们现在有一个构建两个Docker映像并持久化它们的作业，这样我们就可以在下一个作业中使用它们，下一个作业会将这两个映像推送到Docker Hub。</p>

<p>让我们将该作业添加到<code>config.yml</code>中的<code>build-docker</code>作业之后:</p>

<pre><code class="language-yaml">    publish-docker:
        executor: docker-publisher
        steps:
          - attach_workspace:
              at: .
          - setup_remote_docker
          - run:
              name: Load archived Docker image
              command: docker load -i image.tar
          - run:
              name: Publish Docker Image to Docker Hub
              command: |
                echo "${DOCKERHUB_PASS}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin
                docker push $IMAGE_NAME:latest
                docker push $IMAGE_NAME:${CIRCLE_TAG}
</code></pre>

<p>让我们来看看这份工作是做什么的。首先，它重用了带有工作区、环境变量和图像的执行器。接下来，它将持久化的工作空间附加到工作目录。然后，我们使用<code>setup_remote_docker</code>命令获取远程Docker引擎，这样我们就可以推送图像。</p>

<p>之后，我们运行Docker命令从持久化的tar文件中加载之前存储的Docker图像。下一个run命令使用两个尚未设置的环境变量<code>DOCKERHUB_USER</code>和<code>DOCKERHUB_PASS</code>登录到Docker Hub，然后将前一个作业中构建的两个Docker映像推送到Docker Hub。</p>

<p>在我们继续之前，让我们在CircleCI中设置这两个环境变量，这样我们就不会忘记。登录https://circleci.com/，进入你的仪表板https://circleci.com/dashboard.为你的项目选择项目设置(点击工作侧边栏中所列项目的图标。)</p>

<p><img src="../Images/15b330a84d4be64b20f07a7eb1b17a72.png" alt="" data-original-src="https://d2mxuefqeaa7sj.cloudfront.net/s_1709B150038126562194B8C85BDF23241601D3144C4846566FE6570C9886A7F9_1548509735375_circleci-settings.png"/></p>

<p>接下来，从<code>BUILD SETTINGS</code>部分选择<code>Environment Variables</code>，并添加两个新变量<code>DOCKERHUB_USER</code>和<code>DOCKERHUB_PASS</code>，分别为您的Docker Hub用户名和密码设置适当的值。</p>

<p><img src="../Images/d480da4bdf01e665f6282cd51e42a787.png" alt="" data-original-src="https://d2mxuefqeaa7sj.cloudfront.net/s_1709B150038126562194B8C85BDF23241601D3144C4846566FE6570C9886A7F9_1549728239758_circleci-env-vars.png"/></p>

<p><strong>添加工作流，以便在发布新版本时运行作业</strong></p>

<p>我们现在有了构建和发布Docker映像所需的作业，但是我们还没有指定如何执行这些作业。默认情况下，CircleCI将在每次推送GitHub时运行一个名为<code>build</code>的作业，但是额外的作业将被忽略，除非我们设置工作流来运行它们。让我们将工作流添加到<code>.circleci/config.yml</code>文件的底部。</p>

<pre><code class="language-yaml">workflows:
  version: 2.1
  main:
    jobs:
      - build
  build_and_deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore: /.*/
            tags:
              only: /^\d+\.\d+\.\d+$/
      - build-docker:
          requires:
            - build
          filters:
            branches:
              ignore: /.*/
            tags:
              only: /^\d+\.\d+\.\d+$/
      - publish-docker:
          requires:
            - build-docker
          filters:
            branches:
              ignore: /.*/
            tags:
              only: /^\d+\.\d+\.\d+$/
</code></pre>

<p><code>main</code>工作流指定<code>build</code>作业应该执行，并且当这发生时没有给出任何特殊的过滤器，因此<code>build</code>作业在每次推送到GitHub时执行。</p>

<p><code>build_and_deploy</code>工作流程有点复杂。在这个工作流中，我们指定当我们将任何符合指定正则表达式<code>/^\d+\.\d+\.\d+$/</code>的标签推送到GitHub时，将运行<code>build</code>作业。这个正则表达式是符合语义版本的标签的简单匹配，例如<code>1.0.1</code>。因此，如果我们向GitHub推送一个像<code>1.0.1</code>这样的标签，构建工作就会运行。</p>

<p>该工作流接下来指定<code>build-docker</code>作业将在相同的条件下运行，但是它要求<code>build</code>作业首先成功完成(这就是<code>requires</code>命令所做的)。</p>

<p>工作流的最后一步是在将标签推送到GitHub的相同条件下运行<code>publish-docker</code>作业，但前提是前一个<code>build-docker</code>作业成功完成。</p>

<p>我们完成的<code>.circleci/config.yml</code>文件应该是这样的(记住将对<code>chrishowejones</code>的引用改为您的Docker Hub帐户)。</p>

<pre><code class="language-yaml">    version: 2.1
    executors:
        docker-publisher:
          working_directory: ~/cci-film-ratings # directory where steps will run
          environment:
            IMAGE_NAME: chrishowejones/film-ratings-app
          docker:
            - image: circleci/buildpack-deps:stretch
    jobs:
      build:
        working_directory: ~/cci-film-ratings # directory where steps will run
        docker:
          - image: circleci/clojure:lein-2.8.1
        environment:
          LEIN_ROOT: nbd
          JVM_OPTS: -Xmx3200m # limit the maximum heap size to prevent out of memory errors
        steps:
          - checkout
          - restore_cache:
              key: film-ratings-{{ checksum "project.clj" }}
          - run: lein deps
          - save_cache:
              paths:
                - ~/.m2
              key: film-ratings-{{ checksum "project.clj" }}
          - run: lein do test, uberjar
          - persist_to_workspace:
              root: ~/cci-film-ratings
              paths:
                - target
      build-docker:
        executor: docker-publisher
        steps:
          - checkout
          - attach_workspace:
              at: .
          - setup_remote_docker
          - run:
              name: Build latest Docker image
              command: docker build . -t $IMAGE_NAME:latest
          - run:
              name: Build tagged Docker image
              command: docker build . -t $IMAGE_NAME:${CIRCLE_TAG}
          - run:
              name: Archive Docker images
              command: docker save -o image.tar $IMAGE_NAME
          - persist_to_workspace:
              root: ~/cci-film-ratings
              paths:
                - ./image.tar
      publish-docker:
        executor: docker-publisher
        steps:
          - attach_workspace:
              at: .
          - setup_remote_docker
          - run:
              name: Load archived Docker image
              command: docker load -i image.tar
          - run:
              name: Publish Docker Image to Docker Hub
              command: |
                echo "${DOCKERHUB_PASS}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin
                docker push $IMAGE_NAME:latest
                docker push $IMAGE_NAME:${CIRCLE_TAG}
    workflows:
      version: 2.1
      main:
        jobs:
          - build
      build_and_deploy:
        jobs:
          - build:
              filters:
                branches:
                  ignore: /.*/
                tags:
                  only: /^\d+\.\d+\.\d+$/
          - build-docker:
              requires:
                - build
              filters:
                branches:
                  ignore: /.*/
                tags:
                  only: /^\d+\.\d+\.\d+$/
          - publish-docker:
              requires:
                - build-docker
              filters:
                branches:
                  ignore: /.*/
                tags:
                  only: /^\d+\.\d+\.\d+$/
</code></pre>

<p>现在可以将这个配置提交给GitHub了。</p>

<pre><code class="language-bash">$ git add --all .
$ git commit -m "Added workflow &amp; jobs to publish to Docker Hub."
$ git push
</code></pre>
<p>现在，您可以标记当前构建并检查新工作流是否运行以构建Docker映像并将其推送到Docker Hub:</p>

<pre><code class="language-bash">$ git tag -a 0.1.0 -m "v0.1.0"
$ git push --tags
</code></pre>

<p>这将创建一个带注释的标签，并将其推送到您的GitHub存储库中。这将触发<code>build_and_deploy</code>工作流来构建应用程序Uberjar，构建Docker映像(<code>latest</code>和<code>0.1.0</code>)，并将这两个映像推送到您的Docker Hub存储库用于<code>film-ratings-app</code>。你可以在CircleCI仪表盘中查看，也可以在Docker Hub中浏览你的<code>film-ratings-app</code>库。</p>

<h2>摘要</h2>

<p>恭喜你！如果您已经阅读了本系列，那么您已经创建了一个简单的Clojure web应用程序，并使用Docker和Docker Compose对其进行了打包，这样您就可以在类似生产的环境中本地运行它。您还了解了如何让CircleCI构建、测试、打包和发布您的应用程序作为Docker映像。</p>

<p>在本系列的下一篇博文中，我将逐步介绍如何设置一个相当复杂的AWS环境，以便使用Terraform在云中运行我们的应用程序。</p>


        
          
          
            <hr/>
            <p>Chris Howe-Jones是顾问CTO、软件架构师、精益/敏捷蔻驰、开发人员和DevCycle的技术导航员。他主要从事Clojure/ClojureScript、Java和Scala方面的工作，客户从跨国组织到小型创业公司。</p>

            <p><a href="/blog/author/chris-howe-jones/" class="arrow-link">阅读更多克里斯·豪-琼斯的文章</a></p>
          
        
      </div>
    </div>    
</body>
</html>
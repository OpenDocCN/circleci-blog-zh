<html>
<head>
<title>A Scientific Approach to Debugging | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>调试| CircleCI的科学方法</h1>
<blockquote>原文：<a href="https://circleci.com/blog/a-scientific-approach-to-debugging/#2020-09-17T17:00:00-07:00">https://circleci.com/blog/a-scientific-approach-to-debugging/#2020-09-17T17:00:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>20世纪40年代末，莫里斯·威尔克斯领导的团队建造了早期的计算机EDSAC。1949年，他写下了自己在使用计算机时的一个体会。EDSAC位于大楼的顶层，磁带打孔和编辑设备位于其下一层:</p>

<blockquote>
  <p>“在我一次往返于EDSAC房间和‘在楼梯拐角处犹豫不决’的打孔设备之间的旅途中，我强烈地意识到，我余生的大部分时间都将用来寻找我自己程序中的错误。”—莫里斯·威尔克斯，《计算机先驱回忆录》，1985年</p>
</blockquote>

<p>因此，调试总是与编程携手并进。像持续集成或有效遥测这样的实践可以帮助我们发现问题，但是一旦问题摆在我们面前，我们就需要卷起袖子，弄清楚为什么它现在会显现出来。</p>

<p>问题可能出在我们自己的代码中，可能出在同事的代码中，也可能出在我们依赖的某个库或基础设施中。通常这是一种微妙而令人困惑的混合，包括贯穿我们软件和硬件堆栈的多种交互。</p>

<p>很难从症状(如问题报告或堆栈跟踪)找到原因。这是我们倾向于在工作中学习的东西，而且是不均衡的，而不是系统的。但是快速有效的调试是可以学习的，就像科技中的其他事情一样。</p>

<h2>方法</h2>
<p>我们可以通过一系列重复的步骤从症状中恢复。或者我们可以从系统开始工作的“顶层”开始，沿着代码向下，形成问题的模型。</p>

<p>无论采用哪种方法，这种方法多少都是科学的:</p>
<ul>
  <li>看看我们掌握的事实</li>
  <li>试着推理系统崩溃时的状态</li>
  <li>对所发生的事情形成一个假设</li>
  <li>测试它，使用现有的遥测技术或新的代码，一次改变一件事</li>
  <li>重复这个过程，直到找到错误</li>
</ul>

<h2>例子</h2>
<p>在讨论我们工程团队的调试时，<a href="/blog/circleci-config-teardown-how-we-write-our-circleci-config-at-circleci/"> Marc </a>举了一个很好的例子来说明这种方法:</p>

<p>上周，我调试了一个奇怪的RabbitMQ问题，在这个问题中，消息没有作为两个集群之间迁移的一部分进行传递。</p>
<ul>
  <li>事实:消息没有被传递。</li>
  <li>假设:消息没有发送。</li>
</ul>

<p>查看日志，我可以看到在消息发送之前的一行，并且我看不到发送消息的错误或异常的迹象。</p>
<ul>
  <li>事实:消息已发送到队列。</li>
  <li>假设:消息已发送，但未送达。</li>
</ul>

<p>也许交换机没有连接到队列。所以我们打开RabbitMQ UI并检查配置。新RabbitMQ集群上的队列绑定看起来合法，但它的行为与旧集群不同。</p>
<ul>
  <li>事实:队列被绑定到交换。</li>
  <li>假设:两个集群上的拓扑在某些方面有所不同。</li>
</ul>

<p>我们在一个浏览器选项卡中查看web UI上的旧集群，在另一个选项卡中查看新集群，并在两个选项卡之间快速切换以查看有何不同。我们看到了路由键的不同之处。</p>
<ul>
  <li>事实:旧集群有一个为队列绑定定义的路由关键字，而新集群没有。当我们设置旧的队列绑定时，我们是手动完成的，而新的绑定是在配置管理中设置的。</li>
  <li>假设:配置管理代码没有正确设置绑定。</li>
</ul>

<p>这很容易确认和修复。</p>

<h2>陷阱</h2>
<p>当形成假设时，需要实践来限制我们自己只看事实。一个常见的错误是在没有证据的情况下假设，如果我们看到X，那么Y也一定是真的，然后从“X和Y”的位置进行假设</p>

<p>例如，我们可能会看到一组任务未能取得进展，假设问题在于容量，并立即扩大规模。然而，如果问题是我们的任务共享的队列上的争用，我们只会使它变得更糟。这是一个我们可以先核实的假设。</p>

<p>另一方面，经验可以让我们简化一些假设，更快地找到答案。这是一种平衡:有根据的猜测是很好的，但在继续之前，我们必须明确我们的假设并验证我们的猜测。</p>

<p>有时，特别是对于难以重现的问题，我们会意识到我们目前没有信息来检验我们的假设。然后，诀窍是获得新的工具或遥测到位，以便我们下次可以得到它。</p>

<h2>写下来</h2>
<p>在我们进行的过程中做笔记是很有价值的，尤其是在漫长的调查过程中:</p>
<ul>
  <li>一旦我们收集了更多的数据并填充了系统的<a href="https://medium.com/@copyconstruct/effective-mental-models-for-code-and-systems-7c55918f1b3e">心理模型</a>，或者第二天用新的眼光回顾早期的假设，就可以揭露不正确的假设，并成为新想法的强大来源。</li>
  <li>当我们试图对一些困难的事情写下清晰的解释时，它有助于我们挖掘表面的细节，突出我们没有真正理解的部分。</li>
  <li>分享笔记可以让其他人更容易跟上进度。调试和编程一样，是一项团队运动，效果最好！</li>
</ul>

<h2>变得更好</h2>
<p>像许多技能一样，调试回报密切的关注，对方法的一点反省，和其他人一起学习。尝试上面的方法，寻找陷阱，并与同事和朋友分享你的工作。阅读下面的参考资料，了解更多的背景和想法。</p>

<p>调试是软件工程师的一级技能。作为我们每天面临的挑战，我们为做得更好而付出的任何努力都会一次又一次地回报我们。</p>

<h2>资源</h2>



        
          
          
        
      </div>
    </div>    
</body>
</html>
<html>
<head>
<title>Building Kotlin Multiplatform projects in a CI/CD pipeline | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在CI/CD管道中构建Kotlin多平台项目</h1>
<blockquote>原文：<a href="https://circleci.com/blog/building-kmm-on-cicd/#2021-10-06T12:00:00-07:00">https://circleci.com/blog/building-kmm-on-cicd/#2021-10-06T12:00:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>Kotlin 是最通用的编程语言之一，这在很大程度上是因为Kotlin团队致力于将其引入尽可能多的平台。它是开发Android应用程序的主要语言，在JVM后端很流行。Kotlin还提供了使用Kotlin/Native进行本地二进制编译的目标，以及通过Kotlin/JS进行web编译的目标。它最有前途的特性之一是能够针对多个平台进行编译。</p>

<p>这就是<a href="https://kotlinlang.org/docs/mobile/getting-started.html"> Kotlin多平台移动(KMM) </a>的用武之地:它让你可以在Android和iOS应用中编写和重用相同的Kotlin代码。由于移动客户端通常以功能对等为目标，这是一种避免重复工作的聪明方法，我们都知道开发人员多么喜欢避免重复工作。相信我，我是一名开发人员，我知道这有多真实。</p>

<p>无论如何，回到科特林多平台。这是一种不同于跨平台工具的方法，如Flutter和React Native，它们在一切之上提供统一的UI。KMM允许您编写通用业务逻辑，同时将用户界面和体验牢牢地保留在他们的本地平台领域中。在许多情况下，这种方法更适合应用程序用户，因此也更适合您的客户。</p>

<p>本文将向您展示如何开始在<a href="https://circleci.com/blog/what-is-a-ci-cd-pipeline/"> CI/CD管道</a>中构建KMM项目，并将其包含在您团队的开发工作流中。</p>

<h2>跟随注意事项</h2>

<p>本文假设读者理解Kotlin，并且至少熟悉Android或iOS中的一个，最好是两个平台都熟悉。这篇文章不会教你KMM。为此，请查看Kotlin站点上的现有教程之一，或者示例应用程序的自述文件。</p>

<p>另外请注意:KMM目前是在阿尔法版本。技术和API在不断变化和发展，我们正在尽最大努力使示例保持工作和最新，但除了示例中的API版本之外，我们不提供任何保证。</p>

<h2>在CI/CD管道中构建多平台项目</h2>

<p>要在CI/CD环境中构建一个多平台项目，可以把它看作是为每个单独的目标平台构建不同的项目。我们的项目基于<a href="https://github.com/Kotlin/kmm-production-sample">科特林自己的多平台样本——一个RSS阅读器应用</a>。它包含两个应用程序，以及一个以Kotlin库形式存在的共享Kotlin代码库。共享库保留在Kotlin中，用于在Android上编译，并向下编译为本机代码，以便在ARM64上运行，用于iOS目标。</p>

<p>Android应用程序代码位于<code>androidApp</code>，用熟悉的Kotlin代码库编写。iOS的app是用Swift写的，位于<code>iosApp</code>。要了解KMM是如何让一切工作的，请查看KMM官方文档<a href="https://kotlinlang.org/docs/mobile/home.html">文档</a>和Kotlin的GitHub repo上的<a href="https://github.com/Kotlin/kmm-production-sample">样本项目</a>。</p>

<h2>建立一个基本的管道</h2>

<p>用于KMM项目的最简单的CI/CD管道在单个工作流中包含两个作业，分别执行每个平台的构建。CircleCI中的作业是一系列命令或步骤，它们在预定的环境中执行。这种环境是为不同平台构建应用程序的关键。对于iOS，我们需要在Mac硬件上构建它，为executor传入<code>macos</code>。Android更加宽松，但我们仍然可以选择一个包含所有SDK和其他内置内容的预构建环境。对于本教程，我们将使用由<code>android</code> orb提供的<code>android</code> Docker图像。</p>

<p>这些工作本身很简单，与本教程并不相关:检查代码，编译，可能运行一些测试，构建，甚至部署。作为本指南的一部分，我们将不关注工作。相反，我们将花一些时间为构建设置环境和工作流。如果你想了解更多关于为Android设置构建和测试工作的信息，你可以在<a href="https://circleci.com/blog/building-android-on-circleci/">这篇文章</a>中读到。如果你想了解更多关于在iOS上设置构建和测试的信息，你可以在CircleCI文档中的<a href="https://circleci.com/docs/ios-tutorial/">本教程中了解更多。</a></p>

<pre><code>version: 2.1

orbs:
  android: circleci/android@1.0.3

jobs:
  build-android:
    executor: android/android

    steps:
      - checkout
      - android/restore-build-cache
      - android/restore-gradle-cache
      - run:
          name: Run Android tests
          command: ./gradlew androidApp:testDebugUnitTest
      - android/save-gradle-cache
      - android/save-build-cache

  build-ios:
    macos:
      xcode: 12.4.0
    steps:
      - checkout
      - run:
          name: Allow proper XCode dependency resolution
          command: |
            sudo defaults write com.apple.dt.Xcode IDEPackageSupportUseBuiltinSCM YES
            rm ~/.ssh/id_rsa || true
            for ip in $(dig @8.8.8.8 bitbucket.org +short); do ssh-keyscan bitbucket.org,$ip; ssh-keyscan $ip; done 2&gt;/dev/null &gt;&gt; ~/.ssh/known_hosts || true
            for ip in $(dig @8.8.8.8 github.com +short); do ssh-keyscan github.com,$ip; ssh-keyscan $ip; done 2&gt;/dev/null &gt;&gt; ~/.ssh/known_hosts || true
      - run:
          name: Install Gem dependencies
          command: |
            cd iosApp
            bundle install
      - run:
          name: Fastlane Tests
          command: |
            cd iosApp
            fastlane scan

workflows:
  build-all:
    jobs:
      - build-android
      - build-ios
</code></pre>

<h3>构建Android应用程序</h3>

<p>开始构建Android应用程序的最佳方式是使用Android orb。这为您提供了一些内置的作业和命令，使构建变得更加容易。对于这个练习，我们将安装Gradle依赖项，并运行Gradle命令来运行单元测试。</p>

<p>Kotlin Multiplatform带来的主要区别是该应用程序不是顶级项目。相反，它位于<code>androidApp</code>模块中。这个模块依赖于<code>shared</code>，所以我们需要调用带有<code>androidApp:</code>前缀的Gradle命令。</p>

<pre><code>orbs:
  android: circleci/android@1.0.3

jobs:
  build-android:
    executor: android/android

    steps:
      - checkout
      - android/restore-build-cache
      - android/restore-gradle-cache
      - run:
          name: Run Android tests
          command: ./gradlew androidApp:testDebugUnitTest
      - android/save-gradle-cache
      - android/save-build-cache

      - store_artifacts:
          path: androidApp/build/outputs/apk/debug
</code></pre>

<h3>构建iOS应用程序</h3>

<p>正如我们上面提到的，构建iOS应用程序需要安装了XCode的Mac硬件。对于<code>build-ios</code>作业，我们将使用<code>macos</code>执行器，将xcode版本作为参数传递。在我们的情况下是:<code>xcode: 12.4.0</code>。</p>

<p>不管您使用的是CocoaPods还是Swift Package Manager，其余步骤都是通用的。您通常会安装一些依赖项，然后您可以使用浪子构建应用程序并运行测试。对于本教程，我们将只运行一些测试。</p>

<p>当我们使用浪子启动构建时，共享的Kotlin代码会自动构建为一个框架，所以这里没有什么要做的了。</p>

<pre><code>jobs:
  ...
 build-ios:
    macos:
      xcode: 12.4.0
    steps:
      - checkout
      - run:
          name: Allow proper XCode dependency resolution
          command: |
            sudo defaults write com.apple.dt.Xcode IDEPackageSupportUseBuiltinSCM YES
            rm ~/.ssh/id_rsa || true
            for ip in $(dig @8.8.8.8 bitbucket.org +short); do ssh-keyscan bitbucket.org,$ip; ssh-keyscan $ip; done 2&gt;/dev/null &gt;&gt; ~/.ssh/known_hosts || true
            for ip in $(dig @8.8.8.8 github.com +short); do ssh-keyscan github.com,$ip; ssh-keyscan $ip; done 2&gt;/dev/null &gt;&gt; ~/.ssh/known_hosts || true
      - run:
          name: Install Gem dependencies
          command: |
            cd iosApp
            bundle install
      - run:
          name: Fastlane Tests
          command: |
            cd iosApp
            fastlane scan
</code></pre>

<h2>使用动态配置创建高级管道</h2>

<p>每当有人提交到存储库时，这个示例管道可以很好地构建和测试您的KMM应用程序的两个目标平台。但是我们可以做得更好。移动开发的现实是，我们有专家专注于他们各自的平台。有些人喜欢并使用Android，喜欢为Android制作伟大的UX和体验，对这个平台了如指掌。另一方面，也有同样专注于iOS的开发者。在公共代码库上工作总会有一些交叉。在大多数团队中，仍然会有专门从事某个平台的人。</p>

<p>开发进度通常以以下一种形式出现:</p>
<ul>
  <li>仅限Android前端代码库</li>
  <li>仅限iOS前端代码库</li>
  <li>由两个前端代码库使用的共享KMM代码库</li>
</ul>

<p>对于前两个场景，只为正在工作的平台构建更有意义，并且节省时间、信用和效率。</p>

<p>为了优化这个流程，我们可以使用CircleCI的动态配置特性，这有助于我们更有效地编排这样的项目。动态配置允许您只构建应用程序中您已经更改的部分。</p>

<p>动态配置通过设置工作流工作，第一步是评估代码库，检测发生了什么变化(稍后将详细介绍)，然后才运行<em>真正的</em>工作流，即构建应用程序相关部分的工作流。</p>

<p>设置工作流程仍然使用CircleCI用户可能熟悉的<code>config.yml</code>。执行的工作流使用路径过滤orb，它检测与指定分支相比的变化。这是完整的配置。</p>

<pre><code>version: 2.1

setup: true

orbs:
  # the path-filtering orb is required to continue a pipeline based on
  # the path of an updated fileset
  path-filtering: circleci/path-filtering@0.0.2

workflows:
  select-for-build:
    jobs:
      - path-filtering/filter:
          base-revision: master
          config-path: .circleci/continue-config.yml
          mapping: |
            shared/.*|^(?!shared/.*|iosApp/.*|androidApp/.*).*  build-all     true
            androidApp/.*                                       build-android true
            iosApp/.*                                           build-ios     true

</code></pre>

<p>以下是该配置的明细:</p>

<p><code>setup:true</code>向CircleCI表示我们正在使用动态配置，这是管道运行的第一部分。设置工作流是此配置的唯一工作流。它只有一个作业<code>path-filtering/filter</code>，来自<code>path-filtering</code> orb。该作业需要几个参数:</p>

<ul>
  <li><code>base-revision</code>表示要比较的分支</li>
  <li><code>mapping</code>决定比较哪些路径(稍后将详细介绍)</li>
  <li><code>config-path</code>指向<code>continue-config.yml</code>，这是该设置工作流程后要评估的下一个配置。在我们的例子中，我们指向一个静态文件，但是我们也可以预先以编程方式构造这个新的配置文件。</li>
</ul>

<p>要使用<code>mapping</code>，您需要定义项目的路径，以便与基础版本中的代码库进行比较。每行有一条路径。然后，设置要传递给后续管道的管道参数及其值。所有这些都用空格隔开。</p>

<p>第2行和第3行相当简单:</p>

<pre><code>androidApp/.* build-android  true
</code></pre>

<p>在这种情况下，我们感兴趣的路径是<code>androidApp/</code>目录中的所有文件和子目录。这就是Android专用前端的代码库。流水线参数<code>build-android</code>被设置为<code>true</code>。</p>

<p>然而，第一个匹配行更复杂，因为正则表达式匹配器更长:</p>

<pre><code>shared/.*|^(?!shared/.*|iosApp/.*|androidApp/.*).*  build-all  true
</code></pre>

<p>它匹配两个目录中的路径，即我们的Kotlin多平台代码所在的目录，以及不在<code>shared/</code>、<code>iosApp/</code>或<code>androidApp/</code>目录中的任何内容，包括任何其他顶级文件。我们已经将管道参数<code>build-all</code>设置为<code>true</code>，这将触发两个平台的应用构建。</p>

<p>如<code>continue-config.yml</code>中所述，在映射评估了所有更改并设置了所有相关的管道参数后，CircleCI停止该作业，并开始该动态工作流的第二部分。这是完整的文件。</p>

<pre><code>version: 2.1

orbs:
  android: circleci/android@1.0.3

parameters:
  build-all:
    type: boolean
    default: false
  build-android:
    type: boolean
    default: false
  build-ios:
    type: boolean
    default: false

jobs:
  build-android:
    executor: android/android

    steps:
      - checkout
      - android/restore-build-cache
      - android/restore-gradle-cache
      - run:
          name: Build Android app
          command: ./gradlew androidApp:assembleDebug
      - android/save-gradle-cache
      - android/save-build-cache

  build-ios:
    macos:
      xcode: 12.4.0
    steps:
      - checkout
      - run:
          name: Allow proper XCode dependency resolution
          command: |
            sudo defaults write com.apple.dt.Xcode IDEPackageSupportUseBuiltinSCM YES
            rm ~/.ssh/id_rsa || true
            for ip in $(dig @8.8.8.8 bitbucket.org +short); do ssh-keyscan bitbucket.org,$ip; ssh-keyscan $ip; done 2&gt;/dev/null &gt;&gt; ~/.ssh/known_hosts || true
            for ip in $(dig @8.8.8.8 github.com +short); do ssh-keyscan github.com,$ip; ssh-keyscan $ip; done 2&gt;/dev/null &gt;&gt; ~/.ssh/known_hosts || true
      - run:
          name: Install Gem dependencies
          command: |
            cd iosApp
            bundle install
      - run:
          name: Fastlane Tests
          command: |
            cd iosApp
            fastlane scan

workflows:
  run-android:
    when:
      or:
        - &lt;&lt; pipeline.parameters.build-android &gt;&gt;
        - &lt;&lt; pipeline.parameters.build-all &gt;&gt;
    jobs:
      - build-android

  run-ios:
    when:
      or:
        - &lt;&lt; pipeline.parameters.build-ios &gt;&gt;
        - &lt;&lt; pipeline.parameters.build-all &gt;&gt;
    jobs:
      - build-ios
</code></pre>

<p>这里没有包含<code>setup:true</code>行，这表明这是一个“标准”CircleCI配置文件。它确实包含了带有我们在前一阶段定义的管道参数的<code>parameters</code>部分。</p>

<pre><code>parameters:
  build-all:
    type: boolean
    default: false
  build-android:
    type: boolean
    default: false
  build-ios:
    type: boolean
    default: false
</code></pre>

<p>要使用管道参数，我们首先需要在管道中定义它们。我们之前用过。现在您指定它们的类型和默认值:all <code>boolean</code>并设置为<code>false</code>。</p>

<pre><code>workflows:
  run-android:
    when:
      or:
        - &lt;&lt; pipeline.parameters.build-android &gt;&gt;
        - &lt;&lt; pipeline.parameters.build-all &gt;&gt;
    jobs:
      - build-android

  run-ios:
    when:
      or:
        - &lt;&lt; pipeline.parameters.build-ios &gt;&gt;
        - &lt;&lt; pipeline.parameters.build-all &gt;&gt;
    jobs:
      - build-ios
</code></pre>

<p>一旦定义了参数，我们就可以在过滤工作流时使用它们。与上一节所示的简单得多的配置不同，我们需要将作业划分到两个工作流中:</p>
<ul>
  <li>Android的工作被命名为<code>run-android</code></li>
  <li>iOS的作业名为<code>run-ios</code></li>
</ul>

<p>我们可以使用与逻辑操作符结合的<code>when</code>节来指定何时运行特定工作流的过滤器。对于Android，它是一个<code>build-all</code>或<code>build-android</code>管道参数。对于iOS，它是一个<code>build-ios</code>或<code>build-all</code>。</p>

<p>此工作流根据运行与工作流相关的作业的已更改文件有选择地运行。这种设置让您的团队更快、更有效地运作，同时仍然利用KMM的所有多平台功能。</p>

<h1>结论</h1>

<p>在本教程中，您已经学习了如何在CircleCI上建立构建Kotlin多平台移动项目的管道。它类似于构建任何其他项目，除了知道首先构建哪个平台。移动平台通常是单独开发的，因此我们使用CircleCI动态配置功能来构建应用程序开发人员当前正在开发的部分。</p>

<p>如果你对这篇文章有任何问题或建议，或者对未来的文章和指南有什么想法，请通过<a href="https://twitter.com/zmarkan"> Twitter - @zmarkan </a>或<a href="mailto:zan@circleci.com"> email给我</a>联系我。</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>
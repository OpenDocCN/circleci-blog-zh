<html>
<head>
<title>How we spotted–and fixed–11 errors in our docs with our new markdown proofer - CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>我们如何使用新的markdown proofer - CircleCI发现并修复文档中的11个错误</h1>
<blockquote>原文：<a href="https://circleci.com/blog/markdown-proofer/#2018-06-15T03:00:00-07:00">https://circleci.com/blog/markdown-proofer/#2018-06-15T03:00:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>静态站点生成器(SSG)如<a href="http://gohugo.io/">雨果</a>和<a href="https://jekyllrb.com/">杰基尔</a>如今风靡一时。这些后端的静态和前端网站的JavaScript被称为JAMStacks。通常，我们用两种方式测试它们:</p>
<ul>
  <li>经由SSG成功地建立了网站</li>
  <li>和<a href="https://github.com/gjtorikian/html-proofer"> HTMLProofer </a></li>
</ul>

<p>如果我们想做得更多呢？让我们来看看我为测试markdown文件制作的新工具，以及它如何提高CircleCI文档示例的准确性。</p>



<p>作为CircleCI的开发人员，Hugo社区的成员，以及CircleCI docs ( <a href="https://github.com/circleci/circleci-docs">用Jekyll </a>构建)的经常撰稿人，我一直在思考改进静态站点测试的方法。拥有一个定制的小型Docker映像可以缩短构建时间，如果可能的话，并行化作业也会有所帮助。更多的原始测试来确保页面看起来和工作正常是最重要的，但有时也是最难做到的。CircleCI客户对CircleCI Docs的频繁反馈给了我一个想法。</p>

<h2>问题是</h2>

<p>像大多数技术文档一样，CircleCI文档是用Markdown编写的，包含数百个示例。这些例子是用GitHub风格的Markdown <a href="https://help.github.com/articles/creating-and-highlighting-code-blocks/#fenced-code-blocks"> fenced代码块</a>编写的。我们的大多数例子都是使用YAML语法的片段或完整的CircleCI配置文件。许多用户在阅读我们的文档时，会看到一些对他们有用的YAML示例，自然会将&amp;复制粘贴到他们自己的配置中。然后我们破坏了他们的配置。</p>

<p>怎么会？</p>

<p>YAML非常严格。契约意味着一切。缩进量告诉YAML解释器如何解组所有数据。错误的缩进可以创建或破坏配置文件。此外，YAML规范很久以前就做出了——在笔者看来——只通过空格缩进的糟糕决定。YAML行开头的制表符是语法错误。</p>

<p>回到docs，当CircleCI docs团队、其他员工甚至社区成员为repo添加或更新示例时，有时会出现这些错误。这可能是一个简单的人为错误——我们都会犯错——或者有时可能是由文本编辑器在不应该的时候假设了一些事情造成的。无论哪种方式，人眼可能看不到的语法错误(制表符看起来像空格)被合并进来，稍后用户出现，复制它，然后出现错误。可以理解的是，这可能会导致挫败感，而HTMLProofer这个伟大的工具却无法捕捉到这一点。</p>

<h2>解决方案</h2>

<p>除了HTMLProofer，还有其他工具可以测试网站，其中一些可以覆盖markdown文件。为了帮助提高CircleCI文档、我的个人项目和其他静态网站的质量，我写了一个新工具，叫做<a href="https://github.com/felicianotech/md-proofer"> Markdown Proofer </a>。这是一个用Go编写的小型开源命令行界面(CLI ),旨在测试markdown文件。受CircleCI docs的启发，Markdown Proofer的第一个也是迄今为止唯一的功能是在Markdown文件中寻找YAML防护代码块，然后验证YAML以确保其语法正确。这允许一些人在他们的markdown中自动测试YAML代码块，有希望在他们的站点中产生更少的充满错误的例子。让我们用CircleCI docs测试这个新工具。</p>

<h2>使用降价检验器测试CircleCI文档</h2>

<p>在推出Markdown Proofer的第一个版本v0.1.0后，我在CircleCI docs中创建了一个PR，将其添加到构建过程中，看看我们会发现什么。正如所料，由于Markdown Proofer发现了几个错误，PR构建失败。你可以在GitHub <a href="https://github.com/circleci/circleci-docs/pull/2323">这里</a>看到这个PR，在这里看到失败的CircleCI build <a href="https://circleci.com/gh/circleci/circleci-docs/6270?utm_campaign=vcs-integration-link&amp;utm_medium=referral&amp;utm_source=github-build-link">。</a></p>

<p>所以，太好了！该工具完成了它的工作，并发现了一些错误。现在我需要修复它们，这样构建就可以通过，我们就可以正式将Markdown Proofer放入CircleCI docs的<code>master</code>分支。我开发了一个新的PR来修复所有被发现的YAML错误，并且，不算任何表面上的改变，能够修复我们YAML例子中的11个错误。这个PR可以在GitHub <a href="https://github.com/circleci/circleci-docs/pull/2324">这里</a>找到。</p>

<p>随着所有PRs的合并，CircleCI docs的配置示例中修复了11个YAML错误，未来的YAML错误将被捕获，而无需手动检查所有内容，并且仅增加了1秒或更少的总构建时间。虽然不是开创性的，但我能够在CircleCI文档构建过程中添加一个小工具，以提高我们提供给用户的文档的质量。听起来我赢了。</p>

<h2>下一步是什么？</h2>

<h3>用于减价打样机</h3>

<p>Markdown Proofer仍然是一个全新的工具，只检查YAML围栏代码块。在不久的将来，我计划:</p>
<ul>
  <li>添加对JSON代码块的支持。</li>
  <li>添加对JavaScript代码块的支持。</li>
  <li>使用CircleCI <a href="https://circleci.com/docs/local-cli/">本地CLI </a>验证CircleCI配置示例(一个完整的文件),不仅验证YAML语法，还验证CircleCI配置方案。</li>
  <li>对CLI输出和README.md进行更多润色。</li>
  <li>改进错误消息(Go YAML库没有提供很好的消息传递)。</li>
</ul>

<p>由于Markdown Proofer是开源的，您可以跟踪项目并公开问题或在GitHub上提交PRs。在这里找到它<a href="https://github.com/felicianotech/md-proofer">。</a></p>

<h3>对于静态网站测试</h3>

<p>许多网站只是使用HTMLProofer进行测试，我们可以做得更多。也许Markdown Proofer是你的事，也许不是。用<a href="https://www.seleniumhq.org/"> Selenium </a>测试你网站的UI是另一种测试大多数网站的方法。了解需要什么来<a href="https://circleci.com/blog/without-logs-did-it-actually-happen-logging-selenium-browser-testing-on-circleci-2-0/">获得测试过程的更好日志</a>以帮助解决挂起和失败的构建。还有针对您所拥有的内容类型的独特测试。例如，如果您有一个普通的RSS提要、一个sitemap.xml文件、一个播客提要等等。有一些聪明的方法来测试这些页面，以确保它们不只是返回一个HTTP 200“Status OK”响应，而是实际工作并有意义。</p>

<p>如果你有自己的想法或任何问题，请在<a href="https://discuss.circleci.com">circle ci discuse</a>上继续讨论。</p>



        
          
          
        
      </div>
    </div>    
</body>
</html>
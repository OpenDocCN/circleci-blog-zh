<html>
<head>
<title>Creating automated build, test, and deploy workflows for orbs part 2 | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>为orbs创建自动化构建、测试和部署工作流第2部分| CircleCI</h1>
<blockquote>原文：<a href="https://circleci.com/blog/creating-automated-build-test-and-deploy-workflows-for-orbs-part-2/#2019-03-05T08:21:00-08:00">https://circleci.com/blog/creating-automated-build-test-and-deploy-workflows-for-orbs-part-2/#2019-03-05T08:21:00-08:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>在我的<a href="https://circleci.com/blog/creating-automated-build-test-and-deploy-workflows-for-orbs/" target="_blank" rel="noreferrer noopener">上一篇文章</a>中，我讨论了如何为一个新的<a href="https://circleci.com/docs/orb-intro/" target="_blank" rel="noreferrer noopener"> orb </a>建立一个理想的自动化CI/CD流程。这个过程的目标是版本控制、多级测试和自动化部署。现在，让我们看一个例子。我将使用我们上个月刚刚发布的<a href="https://circleci.com/developer/orbs/orb/circleci/azure-cli" target="_blank" rel="noreferrer noopener"> Azure CLI orb </a>，因为它足够小和简单，相当容易理解，但也有点复杂，因为它确实与第三方云提供商微软Azure集成。</p>



<p>用这个过程构建、测试和部署的orb的<code>config.yml</code>文件并不复杂。我们的<a href="https://circleci.com/developer/orbs/orb/circleci/orb-tools" target="_blank" rel="noreferrer noopener"> Orb工具</a> orb已经抽象出自动化Orb开发的大部分基本机制。Azure CLI orb的<a href="https://github.com/CircleCI-Public/azure-cli-orb/blob/master/.circleci/config.yml" target="_blank" rel="noreferrer noopener"> <code>config.yml</code> </a>包含两个不同的工作流。一个工作流用于基本验证和<code>dev</code>发布，另一个用于集成/使用测试和可能的orb生产部署:</p>

<pre><code class="language-yaml">workflows:
  lint_pack-validate_publish-dev:
  
  # …

  integration_tests-prod_deploy:
</code></pre>

<p>这种设置允许您在单个<code>config.yml</code>文件、单个存储库中对orb进行使用和集成测试，并绑定到单个<code>git</code>提交。它允许绕过一些替代的orb测试方法，这些方法可能更复杂或更麻烦(尽管绝不是无效的)，例如<a href="https://github.com/CircleCI-Public/config-preview-sdk/blob/master/docs/inline-orbs.md" target="_blank" rel="noreferrer noopener">内联您的orb </a>，使用外部存储库进行测试，或者在本质上是运行在CircleCI上的<a href="https://circleci.com/docs/local-cli/#running-a-job" target="_blank" rel="noreferrer noopener">本地作业</a>中评估您的新orb源代码，使用<code>machine</code>执行器。</p>

<p>默认情况下，<code>config.yml</code>文件中定义的所有工作流程同时运行。然而，我们已经设置了这两个，一个在每次提交时运行，另一个仅由git标签触发<a href="https://circleci.com/docs/workflows/#executing-workflows-for-a-git-tag" target="_blank" rel="noreferrer noopener">。通过控制如何创建这些git标签，我们可以确保我们的集成测试工作流仅在我们完成了基本的林挺/验证并发布了我们想要进一步测试的orb的<code>dev</code>版本之后才运行。</a></p>



<p><code>lint_pack-validate_publish-dev</code> <br/></p>

<p>我们的第一个工作流程完全是圆形的！也就是说，除了调用我们的<a href="https://circleci.com/developer/orbs/orb/circleci/orb-tools" target="_blank" rel="noreferrer noopener"> orb工具</a> orb中定义的一系列作业并向它们传递必要的参数之外，您不需要做任何事情就可以在您自己的Orb库的配置文件中使用它。让我们快速浏览一下这些工作，一个接一个:</p>



<pre><code class="language-yaml">  - orb-tools/lint:
</code></pre>

<p><code>orb-tools/lint</code>作业将使用<code>yamllint</code> <a href="https://yamllint.readthedocs.io/en/stable/" target="_blank" rel="noreferrer noopener"> CLI工具【lint给定目录下的所有YAML文件，由<code>singapore/lint-condo</code> </a><a href="https://hub.docker.com/r/singapore/lint-condo" target="_blank" rel="noreferrer noopener"> Docker镜像</a>打包。您可以提供一个定制的<code>.yamllint</code>配置文件，或者使用作业中包含的一些基本默认值。</p>



<pre><code class="language-yaml">  - orb-tools/pack:
      requires:
        - orb-tools/lint
</code></pre>

<p><code>orb-tools/pack</code>是为那些用<a href="https://circleci.com/docs/local-cli/#packing-a-config" target="_blank" rel="noreferrer noopener">解构YAML格式</a>写球体的人制作的，我强烈推荐使用！对于任何具有一个或两个以上独立命令或作业的orb，以这种方式组织orb源代码将使您的代码更容易解析、调试和开发。这类似于将一个整体分成更小、更模块化的服务，或者编写React组件，而不是充斥着HTML、JavaScript和CSS代码的单个HTML文件。</p>

<p><a href="https://circleci.com/blog/designing-a-package-manager-from-the-ground-up/" target="_blank" rel="noreferrer noopener">orbs</a>的设计利用了一些更高级的对象类型(即命令、执行器、作业、示例)，非常直观地形成了一个文件系统树，其中每种类型都有自己的文件夹，每个文件夹都包含该类型的所有实例，每个实例都在自己的YAML文件中。一个单独的<code>@orb.yml</code>文件作为这个系统的“入口点”,包含版本信息和描述。您的orb引用的其他orb也可以放在这里，或者每个orb也可以在一个<code>orbs</code>目录中有自己的文件(因为orb可以引用其他orb)。<a href="https://github.com/CircleCI-Public/azure-cli-orb/tree/master/src" target="_blank" rel="noreferrer noopener">看一看</a>我们的Azure CLI orb示例的<code>/src</code>目录，应该会清楚这一切看起来像什么。</p>

<p>默认情况下，<code>orb-tools/pack</code>将执行以下操作:</p>

<ol>
  <li>签出您的项目</li>
  <li>将orb源文件夹打包到一个文件中</li>
  <li>验证这个新的orb.yml文件(<code>circleci orb validate orb.yml</code>)</li>
  <li>将<code>orb.yml</code>文件保存到一个工作空间，这样它就可以在下游作业中使用</li>
</ol>

<p>正如您从上面的YAML片段中看到的，该作业有默认值，因此您通常可以简单地调用该作业，不带任何参数，orb会处理其余的事情。</p>

<ul>
  <li><a href="https://circleci.com/developer/orbs/orb/circleci/orb-tools#jobs-publish-dev" target="_blank" rel="noreferrer noopener">工作三</a> : <code>orb-tools/publish-dev</code></li>
</ul>

<pre><code class="language-yaml">- orb-tools/publish-dev:
    orb-name: circleci/azure-cli
    context: orb-publishing
    requires:
      - orb-tools/pack
</code></pre>

<p>我们的第一个工作流程就要结束了。这个作业只是发布了我们的orb的一个<code>dev</code>版本，它已经在之前的作业中对其YAML进行了标记和验证。同样，提供了合理的缺省值，因此可能只需要为<code>orb-name</code>参数提供一个值。我们已经为这项工作附加了一个<a href="https://circleci.com/docs/contexts/" target="_blank" rel="noreferrer noopener">上下文</a>，因为发布一个orb需要一个<a href="https://circleci.com/docs/managing-api-tokens/" target="_blank" rel="noreferrer noopener"> CircleCI API令牌</a>，但是如果你已经将你的令牌存储为一个<a href="https://circleci.com/docs/env-vars/#setting-an-environment-variable-in-a-project" target="_blank" rel="noreferrer noopener">项目环境变量</a>，那么上下文可能就不需要了。</p>

<ul>
  <li><a href="https://circleci.com/developer/orbs/orb/circleci/orb-tools#jobs-trigger-integration-workflow" target="_blank" rel="noreferrer noopener">工作4 </a> : <code>orb-tools/trigger-integration-workflow</code></li>
</ul>

<pre><code class="language-yaml">- orb-tools/trigger-integration-workflow:
    name: trigger-integration-dev
    context: orb-publishing
    ssh-fingerprints: 23:d1:63:44:ad:e7:1a:b0:45:5e:1e:e4:49:ea:63:4e
    requires:
      - orb-tools/publish-dev
    filters:
      branches:
        ignore: master

- orb-tools/trigger-integration-workflow:
    name: trigger-integration-master
    context: orb-publishing
    ssh-fingerprints: 23:d1:63:44:ad:e7:1a:b0:45:5e:1e:e4:49:ea:63:4e
    tag: master
    requires:
      - orb-tools/publish-dev
    filters:
      branches:
        only: master
</code></pre>

<p>在这里，事情变得有点复杂。我们已经完成了所有基本的orb验证，并发布了orb的<code>dev</code>版本。现在我们要触发第二个工作流，它只有在git标签被推回到我们的orb存储库时才会运行。这正是这份<code>orb-tools</code>工作所要做的！这就是为什么该作业需要SSH指纹作为参数。该作业创建一个git标记，并通过SSH将它推回我们的orb存储库。</p>

<p><a href="https://circleci.com/docs/add-ssh-key/#steps" target="_blank" rel="noreferrer noopener">我们的文档</a>介绍了创建一个密钥并将其添加到CircleCI的过程，但简而言之:生成一个无密码的OpenSSL(不是OpenSSH)密钥对，将公共部分作为读/写密钥存储在您的GitHub或Bitbucket存储库中，将私有部分存储在CircleCI中。这将使您的CircleCI作业能够对您的repo进行更改，例如，推送git标记。</p>

<p>这种类型的方法是必要的，因为在内部，我们的构建系统在运行时处理配置文件，包括orb。因此，如果没有一个新的webhook事件(比如一个git标签),我们将无法测试orb的新版本<code>dev</code>,除非手动进行第二次提交。git标签使我们的系统重新处理我们的<code>config.yml</code>文件，拉入我们的orb的刚刚发布的<code>dev</code>版本。</p>

<p>至关重要的是，因为git标签与我们从本地机器推送的初始提交附加在同一个提交上，所以这个新的CircleCI构建被视为同一套VCS状态检查的一部分。也就是说，对于特定的拉请求，两组工作流作业将被附加到相同的提交，这使得开发人员可以很容易地评估给定的代码更改。</p>

<p>您会注意到我们调用了两次<code>trigger-integration-workflow</code>作业。这是因为我们的集成测试工作流使用<a href="https://circleci.com/docs/workflows/#using-regular-expressions-to-filter-tags-and-branches" target="_blank" rel="noreferrer noopener">正则表达式过滤</a>来控制哪个作业将运行，这取决于git标签的内容。这样，我们可以实现以下目标:</p>

<ol>
  <li>每当提交被推送到非主分支时，只运行我们的集成测试作业；而对主分支的提交将触发集成测试作业，如果测试作业成功，还可能触发生产部署。</li>
  <li>根据我们的orb源代码的哪些部分在给定的提交中被修改，动态地发布补丁、次要版本或主要版本。(例如:一个新的命令或作业将触发一个可能的主要版本；一个新的执行者，或者一个orb的整体<code>description</code>域的改变，只会触发一个小的释放。)这个特性在默认情况下是打开的，但是如果您想要更多地手动控制何时发布各种类型的orb版本，可以禁用它(将<code>use-git-diff</code>参数设置为<code>false</code>)。</li>
</ol>

<p>第二个<code>trigger-integration-workflow</code>作业，只在提交给master时运行，本质上是将字符串“master”附加到我们的git标签上，导致我们完整的第二个工作流(可能还有生产部署作业)运行。</p>



<p><code>integration-tests_prod-deploy</code> <br/></p>

<p>Orb集成测试总是比你在我们的第一个工作流中看到的更加自由，基本上可以拖放到几乎任何orb repo的CircleCI配置文件中。我的基本方法是，作为一个管理大型(而且还在增长！)的目的是关注使用测试，覆盖尽可能多的边缘情况。</p>

<p>换句话说，使用我们刚刚在之前的工作流中发布的orb的<code>dev</code>版本，并运行它的所有命令和作业。我们这样做是为了确保他们不会失败，并确保他们按照我们的期望行事。如果一个命令或任务可以以多种截然不同的方式使用，我们就运行它多次，这样我们就可以覆盖所有的方式。如果一个命令或作业涉及到与第三方服务的交互，在这种情况下，微软Azure，我们建立一个测试环境，这样我们就可以有信心orb将为其他用户工作。</p>

<p>您甚至可以采用我们在这个Azure CLI orb上采用的方法，在不同的运行时环境中测试相同的命令或作业(如果作业被配置为采用自定义执行器的话)(下面，您将看到我们使用基于Go的Docker映像、基于Python的Docker映像和微软自己的第三方Azure Docker映像来测试orb的命令)。</p>

<p>由于这个例子的细节可能不适用于其他orb，所以我将包括第二个工作流的完整YAML，但是在继续讨论生产部署工作之前，只简单地触及几个要点，生产部署工作也被抽象到我们的orb工具Orb中，并且被设计为可供任何希望实现类似开发过程的Orb开发人员使用。</p>

<p><a href="https://circleci.com/blog/circleci-hacks-reuse-yaml-in-your-circleci-config-with-yaml/" target="_blank" rel="noreferrer noopener">在我们的集成测试工作中使用的YAML锚定过滤器</a>:</p>

<pre><code class="language-yaml">integration-dev_filters: &amp;integration-dev_filters
  branches:
    ignore: /.*/
  tags:
    only: /integration-.*/

integration-master_filters: &amp;integration-master_filters
  branches:
    ignore: /.*/
  tags:
    only: /master-.*/

prod-deploy_requires: &amp;prod-deploy_requires
  [test-orb-python_master, test-orb-azure_master, test-orb-golang_master]
</code></pre>

<p>完整的集成-测试和部署工作流程:</p>
<pre><code class="language-yaml">integration-tests_prod-deploy:
  jobs:
    # triggered by non-master branch commits
    - test-orb-python:
        name: test-orb-python_dev
        context: orb-publishing
        filters: *integration-dev_filters

    - test-orb-azure-docker:
        name: test-orb-azure_dev
        context: orb-publishing
        filters: *integration-dev_filters

    - test-orb-golang:
        name: test-orb-golang_dev
        context: orb-publishing
        filters: *integration-dev_filters

    # triggered by master branch commits
    - test-orb-python:
        name: test-orb-python_master
        context: orb-publishing
        filters: *integration-master_filters

    - test-orb-azure-docker:
        name: test-orb-azure_master
        context: orb-publishing
        filters: *integration-master_filters

    - test-orb-golang:
        name: test-orb-golang_master
        context: orb-publishing
        filters: *integration-master_filters

    # patch, minor, or major publishing
    - orb-tools/dev-promote-prod:
        name: dev-promote-patch
        orb-name: circleci/azure-cli
        context: orb-publishing
        requires: *prod-deploy_requires
        filters:
          branches:
            ignore: /.*/
          tags:
            only: /master-patch.*/

    - orb-tools/dev-promote-prod:
        name: dev-promote-minor
        orb-name: circleci/azure-cli
        release: minor
        context: orb-publishing
        requires: *prod-deploy_requires
        filters:
          branches:
            ignore: /.*/
          tags:
            only: /master-minor.*/

    - orb-tools/dev-promote-prod:
        name: dev-promote-major
        orb-name: circleci/azure-cli
        release: major
        context: orb-publishing
        requires: *prod-deploy_requires
        filters:
          branches:
            ignore: /.*/
          tags:
            only: /master-major.*/
</code></pre>

<p>各种<code>test-orb</code>任务的内容在这个orb的<code>config.yml</code>文件中已经定义好了。如果你好奇，我鼓励你去<a href="https://github.com/CircleCI-Public/azure-cli-orb/blob/master/.circleci/config.yml#L19" target="_blank" rel="noreferrer noopener">看一看</a>。现在，我只想说明我们对YAML锚的使用，主要是为了简化一些不太干燥的分支/标签过滤器。我们使用这些过滤器来确保我们在第一个工作流中推送的git标签将正确地控制我们的集成测试工作是否会导致生产部署。</p>

<p>最重要的是，我想检查一下我们称之为三次分开的工作。</p>



<p>为什么我们给这份工作打了三次电话？</p>

<p>这项工作旨在将<code>dev</code> orb升级为语义/生产orb版本。因此，它需要一个参数来确定升级后的版本是补丁(0.0.x)、次要版本(0.x.0)还是主要版本(x.0.0)。因为我们如何在<code>trigger-integration-workflow</code>作业中使用git标签来确定最终发布的版本类型，我们需要调用这个作业三次，每次使用不同的正则表达式过滤git标签。</p>

<p>除此之外，这份工作超级直接！它的设计要求尽可能少的样板文件。所需要的只是一个orb名称和一个CircleCI API令牌。如果没有提供发布类型，则默认为<code>patch</code>。</p>

<h2>包扎</h2>

<p>这就是我们自动化orb开发工作流程的结束！我们只需对包含orb源代码的存储库进行一次提交，通过林挺、基本orb验证、发布<code>dev</code> orb版本、通过git标签触发整个第二次集成测试工作流，以及动态插入<code>patch</code>、<code>minor</code>或<code>major</code> orb版本的生产部署。</p>

<p><strong>几个结束语:</strong></p>

<p><a href="https://github.com/CircleCI-Public/azure-cli-orb/blob/5d352d75be7fe7ee1f56e336445b15fc5cc6544a/.circleci/config.yml#L4" target="_blank" rel="noreferrer noopener">这个过程使用<code>@dev:alpha</code>标签的</a>来标记你的球体。鉴于生产orb版本是不可变的，<code>dev</code>版本<a href="https://circleci.com/docs/creating-orbs/#using-development-versions" target="_blank" rel="noreferrer noopener">可以被覆盖</a>。这使得我们的配置可以用这个orb的旧版本<code>@dev:alpha</code>处理一次，然后在我们用新版本<code>@dev:alpha</code>推送git标签后重新处理。因此，您将需要手动发布一个初始的<code>@dev:alpha</code> orb版本来“引导”这个过程，以便您的配置可以被处理。</p>

<p>如果提交给定的提交已经改变了您的orb源，以至于现在正在调用先前的<code>@dev:alpha</code>版本中不存在的作业和命令，那么您可能还需要在提交给定的提交之前偶尔重新发布<code>@dev:alpha</code>版本。如果无法处理CircleCI作业的配置，它们将不会运行，并且调用尚不存在的orb命令将导致配置处理错误。</p>

<p>因为这里描述的大多数测试工作都驻留在我们的orb工具Orb中，所以我们在这个库的README中添加了这个过程的完整示例。</p>

<p>感谢阅读！</p>

<hr/>

<p>阅读更多信息:</p>




        
          
          
        
      </div>
    </div>    
</body>
</html>
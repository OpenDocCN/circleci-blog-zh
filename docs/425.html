<html>
<head>
<title>GitHub pull request - managing secrets | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>GitHub pull请求-管理机密| CircleCI</h1>
<blockquote>原文：<a href="https://circleci.com/blog/managing-secrets-when-you-have-pull-requests-from-outside-contributors/#2018-10-30T09:57:00-07:00">https://circleci.com/blog/managing-secrets-when-you-have-pull-requests-from-outside-contributors/#2018-10-30T09:57:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>Mozilla喜欢尽可能开放地工作，这意味着我们主要在可公开访问的代码库中进行开发，无论我们是否期望外部合作者。然而，这些存储库仍然需要连接到其他系统，这有时涉及到管理敏感凭证。我们如何让这些连接为维护人员提供丰富的<a href="https://circleci.com/docs/workflows/">工作流</a>，同时也为外部贡献者提供良好的体验？</p>

<p>我们将在GitHub中构建一个示例Java项目，该项目使用CircleCI对所有pull请求(PRs)进行测试，无论是来自主存储库的分支还是fork。然后，我们将添加条件逻辑，当可信提交者将代码推送到主存储库时，该条件逻辑将构建并部署一个java jar工件到亚马逊S3。</p>



<h2>创建项目</h2>

<p>让我们使用<a href="https://maven.apache.org/index.html"> Apache Maven </a>作为构建工具来生成一个小的Java项目:</p>

<pre><code class="language-bash">    mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=managing-secrets -DarchetypeArtifactId=maven-archetype-quickstart -Dversion=1.3 -DinteractiveMode=false
</code></pre>

<p>现在，我们将创建一个简单的CircleCI工作流，运行单个<code>test</code>步骤:</p>

<pre><code class="language-yaml">    version: 2.0
    
    jobs:
      test:
        docker:
          - image: circleci/openjdk:8-jdk
        steps:
          - checkout
          - run: mvn clean test
    
    workflows:
      version: 2
      build:
        jobs:
          - test
</code></pre>

<p>一旦我们将它提交到GitHub并在CircleCI中启用它作为一个项目，每次推送都会触发CircleCI中的<code>build</code>工作流的运行。从主存储库的任何分支发出的PRs将显示<code>test</code>作业的状态。</p>

<h2>为分叉PRs启用CircleCI</h2>

<p>现在，我们希望为来自分叉存储库的拉请求启用相同的工作流。这不仅允许没有提交权限的贡献者提出变更，而且对于喜欢从自己的分支工作的提交者也很有帮助。</p>

<p>为了启用CircleCI的分叉拉取请求，我们在CircleCI中进入我们项目的设置页面，选择<strong>构建设置</strong> &gt; <strong>高级设置</strong>，并启用<strong> <a href="https://circleci.com/docs/oss/#build-pull-requests-from-forked-repositories">构建分叉拉取请求</a> </strong>选项。</p>

<p>当我们在那里时，注意下一个选项，<strong>将秘密从分叉的拉请求</strong>传递到构建。这是默认禁用的，这正是我们在这里想要的。在下一步中，我们将上传AWS凭证，我们不希望意外地将它们暴露给我们组织之外的用户。</p>

<h2>添加秘密</h2>

<p>我们通过将AWS凭证设置为<a href="https://circleci.com/docs/env-vars/#setting-an-environment-variable-in-a-project">特定于项目的环境变量</a>，使它们对可信构建可用。注意，创建一个由多个项目共享的<a href="https://circleci.com/docs/contexts/">上下文</a>也是可能的。</p>

<p>我们现在将移动到CircleCI中项目配置的<strong>构建设置</strong> &gt; <strong>环境变量</strong>部分，并添加<code>AWS_ACCESS_KEY_ID</code>和<code>AWS_SECRET_ACCESS_KEY</code>变量，这些变量包含允许写入亚马逊S3中我们将存放[工件][14]的选定位置的凭证。这些变量不会为从分叉的pull请求触发的CircleCI作业设置，而只会为由具有commit访问权限的人发起的主存储库上的分支设置。</p>

<h2>构建和部署工件</h2>

<p>此时，我们已经准备好向我们的[持续集成(CI)][15]工作流添加逻辑，以构建一个jar并将其部署到S3。为了让我们的CI作业尽可能快地运行，我们将把jar工件与<code>test</code>作业并行打包。一旦测试和打包成功完成，我们将把工件部署到S3。</p>

<p>我们将以下作业定义添加到我们的<code>config.yml</code>中，使用<a href="https://circleci.com/docs/workflows/#using-workspaces-to-share-data-among-jobs">工作区</a>在<code>package</code>和<code>deploy</code>步骤之间共享数据:</p>

<pre><code class="language-yaml">    jobs:
      test:
        ...
      package:
        docker:
          - image: circleci/openjdk:8-jdk
        steps:
          - checkout
          - run: mvn clean package
          - persist_to_workspace:
              root: target
              paths:
                - managing-secrets-1.3.jar
      deploy:
        docker:
          - image: python:3.7
        steps:
          - checkout
          - attach_workspace:
              at: target
          - run: pip install awscli
          - run: aws s3 cp target/managing-secrets-1.3.jar s3://mybucket/managing-secrets/$CIRCLE_BRANCH/managing-secrets-1.3.jar
</code></pre>

<p>我们希望将这些新任务添加到我们的工作流中，并将<code>deploy</code>定义为依赖于<code>test</code>和<code>package</code>步骤。我们的工作流现在在配置中表示为:</p>

<pre><code class="language-yaml">    workflows:
      version: 2
      build:
        jobs:
          - test
          - package
          - deploy:
              requires:
                - test
                - package
</code></pre>

<p>我们将这些更改提交给master，并且我们有了第一次成功的部署！🎉Alice是我们在另一家公司的朋友，她对项目的进展很兴奋，她想提出一个改进方案，所以她分叉这个项目并发出第一个拉动请求。不幸的是，Alice的公关没有通过我们的CI测试。<code>deploy</code>步骤返回:</p>

<pre><code class="language-bash">    upload failed: ... Unable to locate credentials
</code></pre>

<p>这里有好有坏。好的一面是，CircleCI完全按照我们的要求做了；它运行分叉公关的工作流程，没有暴露任何秘密。从坏的方面来说，这对爱丽丝来说是一次令人困惑的经历；在她打开PR之前，她确保她的新代码和测试在本地正常工作，所以她有理由期望她的PR应该通过我们的CI测试。</p>

<p>我们需要引入更多的逻辑来检测分叉的PRs，并延迟部署，直到可信的提交者批准并合并代码。</p>

<h2>定义在分叉PRs上提前返回的命令</h2>

<p>CircleCI 2.1配置引入了<a href="https://circleci.com/docs/reusing-config/#authoring-reusable-commands">可重用的用户定义命令</a>，我们将利用这个概念来制作一个<code>early_return_for_forked_prs</code>命令。调用它将使我们知道分叉PRs不需要的工作或我们知道会失败的工作短路。确保参考<a href="https://circleci.com/docs/reusing-config/#getting-started-with-config-reuse">上的文档，启用配置重用</a>。</p>

<p>首先，我们如何在一个工作运行中辨别这是否是一个分叉的PR？我们可以直接检查传入的特定环境变量是否存在，比如<code>AWS_ACCESS_KEY_ID</code>，但是我们希望实现一个更通用的解决方案，它可以被复制到任何项目中，而不考虑我们已经定义的特定秘密集。相反，我们将使用由<a href="https://circleci.com/docs/env-vars/#built-in-environment-variables"> CircleCI的内置环境变量</a>提供的关于作业的丰富上下文。我们感兴趣的特定变量是<code>CIRCLE_PR_NUMBER</code>，记录为“相关联的[GitHub或Bitbucket][16] pull请求的编号。仅在分叉的PRs上可用。如果<code>CIRCLE_PR_NUMBER</code>存在，那么我们知道我们正在运行一个无法访问秘密的分叉PR的构建。</p>

<p>为了在shell语法中表达这个条件，我们使用了<code>-n</code>(非零长度)测试。条件将是这样的:</p>

<pre><code class="language-bash">    if [ -n "$CIRCLE_PR_NUMBER" ]; then
      # mark this job successful and stop processing
    fi
</code></pre>

<p>CircleCI上的大多数执行器都有一个可用的本地<a href="https://circleci.com/docs/local-cli/"> <code>circleci-agent</code>命令行界面</a>，它提供了我们填写这个条件表达式所需的命令:</p>

<pre><code class="language-bash">    circleci-agent step halt
</code></pre>

<p>现在，我们准备将所有这些放入配置的一个新的顶级<code>commands</code>部分:</p>

<pre><code class="language-yaml">    commands:
      early_return_for_forked_pull_requests:
        description: &gt;-
          If this build is from a fork, stop executing the current job and return success.
          This is useful to avoid steps that will fail due to missing credentials.
        steps:
          - run:
              name: Early return if this build is from a forked PR
              command: |
                if [ -n "$CIRCLE_PR_NUMBER" ]; then
                  echo "Nothing to do for forked PRs, so marking this step successful"
                  circleci step halt
                fi
</code></pre>

<p>我们添加自定义命令作为部署作业的第一步:</p>

<pre><code class="language-yaml">    jobs:
      deploy:
        docker:
          - image: python:3.7
        steps:
          - early_return_for_forked_pull_requests
          - checkout
          - attach_workspace:
              at: target
          - run: pip install awscli
          - run: aws s3 cp target/managing-secrets-1.3.jar s3://mybucket/managing-secrets/$CIRCLE_BRANCH/managing-secrets-1.3.jar
</code></pre>

<p>此时，我们可以为<code>package</code>作业添加相同的命令，因为它的唯一目的是为我们跳过的<code>deploy</code>作业暂存工件。我们还不如不要浪费计算时间去建造一个我们从来不用的工件。</p>

<p>如果爱丽丝在这些配置改变的基础上重新设置她的PR，CircleCI现在会运行得更快，并由于早期的返回而显示所有绿色。当她的变更被批准和合并时，包括秘密在内的完整工作流将在主分支运行，构建一个批准的工件并部署到S3。</p>

<h2>进一步阅读</h2>

<p>这里讨论的演示项目的完整代码可以在GitHub上的<a href="https://github.com/jklukas/managing-secrets"> jklukas/managing-secrets </a>获得。</p>

<p>了解更多关于CircleCI <a href="https://circleci.com/blog/securing-ci-cd-pipelines-with-circleci-contexts-rest-api/">上下文REST API </a>的信息。</p>

<p>要查看这种方法在实际生产环境中的应用，请参见[mozilla/telemetry-batch-view][12]和[Mozilla/telemetry-streaming][13]，Mozilla数据平台团队在这些存储库中定义了Spark转换作业，用于从Firefox遥测数据创建派生数据集。对这些存储库的每次推送都会触发一次构建，并将一个jar工件交付给S3；我们通过旋转指向一个已部署jar的Amazon EMR集群来运行转换。默认情况下，夜间运行引用S3的<code>master/</code>路径中的工件，因此我们的CircleCI配置确保了白天合并到master的代码将在第二天晚上运行。</p>

<p>https://github . com/Mozilla/telemetry-batch-view/blob/33 D1 BF 1 cafd 29098 a 989d 08770358361 a 93 D7 BC 3/。circle ci/config . yml[12]:https://github . com/Mozilla/telemetry-streaming/blob/b 3318 acdfeae 5e 0 f 7d 5a 484 BFA be 809355 F3 ad C5/。circle ci/config . yml[14]:https://circleci.com/docs/artifacts/[15]:https://circleci.com/continuous-integration/[16]:https://circleci.com/docs/gh-bb-integration/</p>


        
          
          
            <hr/>
            <p>杰夫·克鲁卡斯有实验粒子物理学的背景，他既是教师又是帮助发现希格斯玻色子的研究人员。他现在在俄亥俄州哥伦布市的Mozilla公司的Firefox数据平台上远程工作，之前是Simple公司数据平台的技术负责人，Simple是一家云端无分支银行。</p>

            <p><a href="/blog/author/jeff-klukas/" class="arrow-link">阅读更多杰夫·克鲁卡斯的文章</a></p>
          
        
      </div>
    </div>    
</body>
</html>
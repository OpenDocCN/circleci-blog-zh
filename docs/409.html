<html>
<head>
<title>Infrastructure as Code, part 2: build Docker images and deploy to a Kubernetes cluster with Terraform | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>基础设施即代码，第2部分:使用Terraform | CircleCI构建Docker映像并部署到Kubernetes集群</h1>
<blockquote>原文：<a href="https://circleci.com/blog/learn-iac-part02/#2021-11-09T12:00:00-08:00">https://circleci.com/blog/learn-iac-part02/#2021-11-09T12:00:00-08:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>本系列向您展示如何开始使用基础设施即代码(IaC)。目标是通过教程和代码示例帮助开发人员加深对IaC的理解。</p>



<p>在这篇文章中，我将演示如何为应用程序创建一个<a href="https://docs.docker.com/get-started/overview/#docker-objects"> Docker映像</a>，然后将该映像推送到<a href="https://hub.docker.com/"> Docker Hub。</a>我还将讨论如何使用<a href="https://www.terraform.io/"> HashiCorp的Terraform创建Docker映像并将其部署到<a href="https://cloud.google.com/kubernetes-engine"> Google Kubernetes Engine (GKE)集群</a>。</a></p>

<p>下面是我们将在这篇文章中完成的事情的快速列表:</p>

<ol>
  <li>构建新的<a href="https://docs.docker.com/get-started/overview/#docker-objects"> Docker映像</a></li>
  <li>将新的Docker映像推送到<a href="https://hub.docker.com/"> Docker Hub注册表</a></li>
  <li>使用<a href="https://www.terraform.io/">地形</a>创建一个新的<a href="https://cloud.google.com/kubernetes-engine"> GKE集群</a></li>
  <li>使用<a href="https://www.terraform.io/docs/providers/kubernetes/"> Terraform Kubernetes提供者</a>创建一个新的<a href="https://www.terraform.io/docs/providers/kubernetes/r/deployment.html"> Terraform Kubernetes部署</a></li>
  <li>摧毁所有使用<a href="https://www.terraform.io/">地形</a>创造的资源</li>
</ol>

<p><strong>注意:</strong> <i>在你开始学习这部分教程之前，确保你已经完成了第1部分的<a href="https://circleci.com/blog/learn-iac-part1/">先决条件部分中的所有操作。</a></i></p>

<p>我们的第一个任务是学习如何基于包含在<a href="https://github.com/datapunkz/learn_iac">代码报告中的Node.js应用程序构建一个<a href="https://docs.docker.com/get-started/overview/#docker-objects"> Docker镜像</a>。</a></p>

<h2>建立码头工人形象</h2>

<p>在<a href="https://circleci.com/blog/learn-iac-part1/">之前的帖子</a>中，我们使用<a href="https://www.terraform.io/"> Terraform </a>创建了一个新的GKE集群，但该集群不可用，因为没有部署任何应用程序或服务。因为Kubernetes (K8s)是一个容器编排器，应用和服务必须打包到<a href="https://docs.docker.com/get-started/overview/#docker-objects"> Docker镜像</a>中，然后这些镜像可以衍生出<a href="https://docs.docker.com/get-started/overview/#docker-objects"> Docker容器</a>来执行应用或服务。</p>

<p><a href="https://docs.docker.com/get-started/overview/#docker-objects"> Docker镜像</a>是使用<a href="https://docs.docker.com/engine/reference/commandline/build/"> <code>docker build</code>命令</a>创建的，你将需要一个<a href="https://docs.docker.com/engine/reference/builder/">Docker文件</a>来指定如何构建你的Docker镜像。我将讨论Dockerfiles，但首先我想解决<a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">。dockerignore文件</a>。</p>

<h3>是什么？dockerignore文件？</h3>

<p><code>.dockerignore</code>文件排除了与其中声明的模式相匹配的文件和目录。使用该文件有助于避免不必要地将大型或敏感的文件和目录发送到守护程序，并有可能将它们添加到公共映像中。在这个项目中，<code>.dockerignore</code>文件排除了与Terraform和Node.js本地依赖相关的不必要的文件。</p>

<h3>了解Dockerfile文件</h3>

<p>Docker文件对于构建Docker映像至关重要。它指定了如何构建和配置映像，以及向其中导入什么文件。Dockerfile文件是动态的，因此您可以用不同的方式完成许多目标。对Dockerfile功能有一个扎实的了解是很重要的，这样您就可以构建功能性映像。这是这个项目的代码报告中包含的docker文件的细目分类。</p>

<pre><code>FROM node:12

# Create app directory
WORKDIR /usr/src/app

# Install app dependencies
COPY package*.json ./

RUN npm install --only=production

# Bundle app source
COPY . .

EXPOSE 5000
CMD [ "npm", "start" ]
</code></pre>

<p><code>FROM node:12</code>行定义了一个要继承的图像。构建映像时，Docker从父映像继承。在这种情况下，它是从Docker Hub获取的<code>node:12</code>图像，如果它不在本地的话。</p>

<pre><code># Create app directory
WORKDIR /usr/src/app

# Install app dependencies
COPY package*.json ./

RUN npm install --only=production
</code></pre>

<p>这个代码块定义了<code>WORKDIR</code>参数，它指定了Docker映像中的工作目录。<code>COPY package*.json ./</code>行将任何与包相关的文件复制到Docker映像中。<code>RUN npm install</code>行安装在<code>package.json</code>文件中列出的应用程序依赖项。</p>

<pre><code>COPY . .

EXPOSE 5000
CMD [ "npm", "start" ]
</code></pre>

<p>这个代码块将所有文件复制到Docker映像中，除了在<code>.dockerignore</code>文件中列出的文件和目录。<code>EXPOSE 5000</code>行指定为这个Docker映像公开的端口。<code>CMD [ "npm", "start" ]</code>行定义了如何开始这个图像。在这种情况下，它正在执行该项目的<code>package.json</code>文件中指定的<code>start</code>部分。该<code>CMD</code>参数是默认的执行命令。现在您已经理解了Dockerfile文件，您可以使用它在本地构建一个映像。</p>

<h3>使用Docker构建命令</h3>

<p>使用<a href="https://docs.docker.com/engine/reference/commandline/build/"> <code>docker build</code> </a>命令，Dockerfile根据其中定义的指令构建一个新的映像。在构建Docker映像时，需要记住一些命名约定。如果您计划共享图像，命名约定尤其重要。</p>

<p>在我们开始构建图像之前，我将花点时间来描述如何给它们命名。Docker图像使用由斜杠分隔的名称组件组成的<a href="https://docs.docker.com/engine/reference/commandline/tag/">标签</a>。因为我们将把图像推送到<a href="https://hub.docker.com/"> Docker Hub </a>，所以我们需要在图像名称前加上我们的Docker Hub用户名。对我来说，那就是<code>ariv3ra/</code>。我通常会在后面加上项目的名称，或者图像的有用描述。这个Docker镜像的全名将会是<code>ariv3ra/learniac:0.0.1</code>。<code>:0.0.1</code>是应用程序的版本标签，但是您也可以用它来描述图像的其他细节。</p>

<p>一旦你有了一个好的、描述性的名字，你就可以建立一个形象。以下命令必须从项目repo的根目录中执行(确保将<code>ariv3ra</code>替换为<i>您的</i> Docker Hub名称):</p>

<pre><code>docker build -t ariv3ra/learniac  -t ariv3ra/learniac:0.0.1 .
</code></pre>

<p>接下来，运行以下命令查看机器上的Docker映像列表:</p>
<pre><code>docker images
</code></pre>
<p>这是我的输出。</p>

<pre><code>REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
ariv3ra/learniac        0.0.1               ba7a22c461ee        24 seconds ago      994MB
ariv3ra/learniac        latest              ba7a22c461ee        24 seconds ago      994MB
</code></pre>

<h3>Docker推送命令</h3>

<p>现在我们已经准备好<a href="https://docs.docker.com/engine/reference/commandline/push/">将这张图片</a>推送到Docker Hub并公开发布。Docker Hub需要授权才能访问服务，所以我们需要使用<a href="https://docs.docker.com/engine/reference/commandline/login/"> <code>login</code>命令来认证</a>。运行以下命令登录:</p>

<pre><code>docker login
</code></pre>

<p>在提示中输入您的Docker Hub凭据以授权您的帐户。每台机器只需要登录一次。现在你可以推送图片了。</p>

<p>使用您的<code>docker images</code>命令中列出的图像名称，运行以下命令:</p>

<pre><code>docker push ariv3ra/learniac
</code></pre>

<p>这是我的输出。</p>

<pre><code>The push refers to repository [docker.io/ariv3ra/learniac]
2109cf96cc5e: Pushed 
94ce89a4d236: Pushed 
e16b71ca42ab: Pushed 
8271ac5bc1ac: Pushed 
a0dec5cb284e: Mounted from library/node 
03d91b28d371: Mounted from library/node 
4d8e964e233a: Mounted from library/node
</code></pre>

<p>现在，您在Docker Hub中有了一个Docker映像，并准备好部署到GKE集群。将您的应用程序部署到新的Kubernetes集群的所有工作都已就绪。下一步是使用Terraform构建Kubernetes部署。</p>

<h2>使用Terraform部署Kubernetes</h2>

<p>在本系列的第1部分中，我们学习了如何使用Terraform创建一个新的Google Kubernetes引擎(GKE)集群。正如我前面提到的，该集群没有提供任何应用程序或服务，因为我们没有向它部署任何应用程序或服务。在这一节中，我将描述使用Terraform 部署<a href="https://www.terraform.io/docs/providers/kubernetes/r/deployment.html"> Kubernetes部署需要什么。</a></p>

<p>Terraform有一个<a href="https://www.terraform.io/docs/providers/kubernetes/r/deployment.html"> Kubernetes部署</a>资源，允许您定义一个并执行一个Kubernetes部署到您的GKE集群。在第1部分<a href="https://circleci.com/blog/learn-iac-part1/">中，我们使用<code>part01/iac_gke_cluster/</code>目录中的Terraform代码创建了一个新的GKE集群。在本文中，我们将分别使用<code>part02/iac_gke_cluster/</code>和<code>part02/iac_kubernetes_app/</code>目录。<code>iac_gke_cluster/</code>是我们在第1部分中使用的相同代码。我们将在这里结合<code>iac_kubernetes_app/</code>目录再次使用它。</a></p>

<h3>Terraform Kubernetes提供商</h3>

<p>我们之前使用Terraform <a href="https://www.terraform.io/docs/providers/google/index.html"> Google云平台提供商</a>创建了一个新的<a href="https://cloud.google.com/kubernetes-engine"> GKE集群</a>。Terraform提供者是特定于Google云平台的，但它仍然是引擎盖下的Kubernetes。因为GKE本质上是一个Kubernetes集群，我们需要使用<a href="https://www.terraform.io/docs/providers/kubernetes/"> Terraform Kubernetes提供者</a>和<a href="https://www.terraform.io/docs/providers/kubernetes/r/deployment.html"> Kubernetes部署资源</a>来配置和部署我们的应用到GKE集群。</p>

<h2>地形代码文件</h2>

<p><code>part02/iac_kubernetes_app/</code>目录包含这些文件:</p>

<ul>
  <li>providers.tf</li>
  <li>变量. tf</li>
  <li>main.tf</li>
  <li>部署. tf</li>
  <li>services.tf</li>
  <li>输出. tf</li>
</ul>

<p>这些文件维护我们用来定义、创建和配置Kubernetes集群应用程序部署的所有代码。接下来，我将分解这些文件，让您更好地理解它们的作用。</p>

<h3>细分:providers.tf</h3>

<p>在<code>provider.tf</code>文件中，我们定义了将要使用的Terraform提供者:<a href="https://www.terraform.io/docs/providers/kubernetes/"> Terraform Kubernetes提供者</a>。<code>provider.tf</code>:</p>

<pre><code>provider "kubernetes" {

}
</code></pre>

<p>此代码块定义了将在此Terraform项目中使用的提供程序。<code>{ }</code>块是空的，因为我们将用不同的进程处理<a href="https://www.terraform.io/docs/providers/google/guides/using_gke_with_terraform.html#interacting-with-kubernetes">认证需求。</a></p>

<h3>细分:变量. tf</h3>

<p>这个文件应该看起来很熟悉，并且类似于第1部分<code>variables.tf</code>文件。这个特殊的文件只指定了这个Terraform Kubernetes项目使用的输入变量。</p>

<pre><code>variable "cluster" {
  default = "cicd-workshops"
}
variable "app" {
  type        = string
  description = "Name of application"
  default     = "cicd-101"
}
variable "zone" {
  default = "us-east1-d"
}
variable "docker-image" {
  type        = string
  description = "name of the docker image to deploy"
  default     = "ariv3ra/learniac:latest"
}
</code></pre>

<p>此文件中定义的变量将在项目文件的代码块中用于整个Terraform项目。所有这些变量都有<code>default</code>值，可以在执行代码时通过在CLI中定义它们来更改。这些变量为Terraform代码增加了急需的灵活性，并允许重用有价值的代码。这里需要注意的一点是，<code>variable "docker-image"</code>默认参数被设置为我的Docker图像名称。将该值替换为您的 Docker图像的<i>名称。</i></p>

<h3>细分:main.tf</h3>

<p><code>main.tf</code>文件的元素以<code>terraform</code>块开始，它指定了<a href="https://www.terraform.io/docs/backends/index.html"> Terraform后端</a>的类型。Terraform中的一个“后端”决定了如何加载状态，以及如何执行一个操作，如<code>apply</code>。这种抽象支持非本地文件状态存储和远程执行等。在这个代码块中，我们使用了<code>remote</code>后端。它使用Terraform云，并连接到您在第1部分文章的<a href="https://circleci.com/blog/learn-iac-part1/">先决条件部分创建的<code>iac_kubernetes_app</code>工作空间。</a></p>

<pre><code>terraform {
  required_version = "~&gt;0.12"
  backend "remote" {
    organization = "datapunks"
    workspaces {
      name = "iac_kubernetes_app"
    }
  }
}
</code></pre>

<h3>细分:deployments.tf</h3>

<p>接下来是对<code>deployments.tf</code>文件中语法的描述。该文件使用<a href="https://www.terraform.io/docs/providers/kubernetes/r/deployment.html"> Terraform Kubernetes部署资源</a>来定义、配置和创建将我们的应用程序发布到GKE集群所需的所有Kubernetes资源。</p>

<pre><code>resource "kubernetes_deployment" "app" {
  metadata {
    name = var.app
    labels = {
      app = var.app
    }
  }
  spec {
    replicas = 3

    selector {
      match_labels = {
        app = var.app
      }
    }
    template {
      metadata {
        labels = {
          app = var.app
        }
      }
      spec {
        container {
          image = var.docker-image
          name  = var.app
          port {
            name           = "port-5000"
            container_port = 5000
          }
        }
      }
    }
  }
}
</code></pre>

<p>是时候回顾一下代码元素了，以便更好地理解正在发生的事情。</p>

<pre><code>resource "kubernetes_deployment" "app" {
  metadata {
    name = var.app
    labels = {
      app = var.app
    }
  }
</code></pre>

<p>这个代码块指定了Terraform Kubernetes部署资源的使用，它为Kubernetes定义了我们的部署对象。<code>metadata</code>块用于为Kubernetes服务中使用的参数赋值。</p>

<pre><code>  spec {
    replicas = 3

    selector {
      match_labels = {
        app = var.app
      }
    }

    template {
      metadata {
        labels = {
          app = var.app
        }
      }

      spec {
        container {
          image = var.docker-image
          name  = var.app
          port {
            name           = "port-5000"
            container_port = 5000
          }
        }
      }
    }
  }
</code></pre>

<p>在resources <code>spec{...}</code>块中，我们指定想要三个<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/"> Kubernetes pods </a>在集群中运行我们的应用程序。<code>selector{...}</code>块代表<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors">标签选择器</a>。这是Kubernetes的一个核心分组原语，允许用户选择一组对象。</p>

<p>资源<code>template{...}</code>块中有一个<code>spec{...}</code>块，它有一个<code>container{...}</code>属性块。该块具有定义和配置部署中使用的容器的参数。从代码中可以看出，这是我们定义pod的Docker <code>image</code>(我们想要使用的图像)和容器的<code>name</code>的地方，它应该出现在Kubernetes中。这也是我们定义在容器上公开的<code>port</code>的地方，它将允许对正在运行的应用程序的入口访问。这些值来自同一文件夹中的<code>variables.tf</code>文件。Terraform Kubernetes部署资源能够执行非常健壮的配置。我鼓励您和您的团队尝试其他一些属性，以便更广泛地熟悉这个工具。</p>

<h3>细目:services.tf</h3>

<p>我们已经创建了一个<a href="https://www.terraform.io/docs/providers/kubernetes/r/deployment.html"> Terraform Kubernetes部署资源</a>文件，并为这个应用程序定义了我们的Kubernetes部署。剩下一个细节来完成我们的应用程序的部署。我们正在部署的应用程序是一个基本的网站。和所有的网站一样，它需要是可访问的才是有用的。此时，我们的<code>deployments.tf</code>文件指定了使用Docker映像部署Kubernetes pod的指令以及所需的pod数量。我们的部署缺少一个关键要素:Kubernetes服务。这是一种将运行在一组pod上的应用程序作为网络服务公开的抽象方式。使用Kubernetes，您不需要修改应用程序来使用不熟悉的服务发现机制。Kubernetes为一组pods提供它们自己的IP地址和一个DNS名称，并且可以在它们之间进行负载平衡。</p>

<p>在<code>services.tf</code>文件中，我们定义了一个<a href="https://www.terraform.io/docs/providers/kubernetes/r/service.html"> Terraform Kubernetes服务</a>。它将连接Kubernetes元素，以提供对集群中pods上运行的应用程序的入口访问。这里是<code>services.tf</code>文件。</p>

<pre><code>resource "kubernetes_service" "app" {
  metadata {
    name = var.app
  }
  spec {
    selector = {
      app = kubernetes_deployment.app.metadata.0.labels.app
    }
    port {
      port        = 80
      target_port = 5000
    }
    type = "LoadBalancer"
  }
} 
</code></pre>

<p>此时，描述一下<code>spec{...}</code>块和其中的元素可能会有所帮助。<code>selector{ app...}</code>块指定了一个在<code>deployments.tf</code>文件中定义的名称，并表示部署资源中元数据块的<code>label</code>属性中的<code>app</code>值。这是一个重用相关资源中已经分配的值的例子。它还提供了一种机制来简化重要的值，并为像这样的重要数据建立一种形式的引用完整性。</p>

<p><code>port{...}</code>块有两个属性:<code>port</code>和<code>target_port</code>。这些参数定义了服务将侦听应用程序请求的外部端口。在本例中，它是端口80。<code>target_port</code>是我们的pod正在监听的内部端口，即端口5000。该服务将所有流量从端口80路由到端口5000。</p>

<p>这里要回顾的最后一个元素是<code>type</code>参数，它指定了我们正在创建的服务的类型。Kubernetes有三种<a href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types">服务</a>。在这个例子中，我们使用的是<code>LoadBalancer</code>类型，它使用云提供商的负载均衡器对外公开服务。外部负载平衡器路由到的NodePort和ClusterIP服务是自动创建的。在这种情况下，GCP将创建并配置一个<code>LoadBalancer</code>，它将控制流量并将其路由到我们的GKE集群。</p>

<h3>细分:output.tf</h3>

<p>Terraform使用<a href="https://docs.docker.com/get-started/overview/#docker-objects">输出值</a>返回Terraform模块的值，该模块在运行<code>terraform apply</code>后向子模块提供输出。这些输出用于向父模块公开其资源属性的子集，或者在CLI输出中打印某些值。<code>output.tf</code>块我们使用输出值来读出集群名称和我们新创建的负载平衡器服务的入口IP地址等值。这个地址是我们可以访问托管在GKE集群上的应用程序的地方。</p>

<pre><code>  output "gke_cluster" {
    value = var.cluster
  }

  output "endpoint" {
    value = kubernetes_service.app.load_balancer_ingress.0.ip
  }
</code></pre>

<h2>初始化地形零件02/iac_gke_cluster</h2>

<p>现在您已经对我们的Terraform项目和语法有了更好的理解，您可以开始使用Terraform配置我们的GKE集群了。将目录更改为<code>part02/iac_gke_cluster</code>目录:</p>

<pre><code>cd part02/iac_gke_cluster
</code></pre>

<p>在<code>part02/iac_gke_cluster</code>中，运行以下命令:</p>

<pre><code>terrform init
</code></pre>

<p>这是我的输出。</p>

<pre><code>Initializing the backend...

Successfully configured the backend "remote"! Terraform will automatically
use this backend unless the backend configuration changes.

Initializing provider plugins...
- Checking for available provider plugins...
- Downloading plugin for provider "google" (hashicorp/google) 3.31.0...

The following providers do not have any version constraints in configuration,
so the latest version was installed.

To prevent automatic upgrades to new major versions that may contain breaking
changes, it is recommended to add version = "..." constraints to the
corresponding provider blocks in configuration, with the constraint strings
suggested below.

* provider.google: version = "~&gt; 3.31"

Terraform has been successfully initialized!
</code></pre>

<p>这太棒了！现在我们可以创建GKE集群了。</p>

<h3>地形应用零件02/iac_gke_cluster</h3>

<p>Terraform有一个命令，允许您在不实际执行任何操作的情况下，模拟运行和验证您的Terraform代码。该命令名为<code>terraform plan</code>，它还绘制了Terraform将针对您现有的基础设施执行的所有操作和更改。在终端中，运行:</p>

<pre><code>terraform plan
</code></pre>

<p>这是我的输出。</p>

<pre><code>Refreshing Terraform state in-memory prior to plan...
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.
------------------------------------------------------------------------
An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # google_container_cluster.primary will be created
  + resource "google_container_cluster" "primary" {
      + additional_zones            = (known after apply)
      + cluster_ipv4_cidr           = (known after apply)
      + default_max_pods_per_node   = (known after apply)
      + enable_binary_authorization = false
  ...
</code></pre>

<p>Terraform将根据<code>main.tf</code>文件中的代码为您创建新的GCP资源。现在，您已经准备好创建新的基础设施并部署应用程序了。在终端中运行以下命令:</p>

<pre><code>terraform apply
</code></pre>

<p>Terraform将提示您确认您的命令。键入<code>yes</code>并按回车键。</p>

<pre><code>Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes
</code></pre>

<p>Terraform将在GCP建立新的Google Kubernetes引擎集群。</p>

<p><strong>注意</strong> : <i>集群需要3-5分钟才能完成。这不是一个即时的过程，因为后端系统正在进行配置并使其上线。</i></p>

<p>在我的集群完成之后，这就是我的输出。</p>

<pre><code>Apply complete! Resources: 1 added, 0 changed, 0 destroyed.

Outputs:

cluster = cicd-workshops
cluster_ca_certificate = &lt;sensitive&gt;
host = &lt;sensitive&gt;
password = &lt;sensitive&gt;
username = &lt;sensitive&gt;
</code></pre>

<p>新的GKE集群已经创建，并显示了<code>Outputs</code>结果。请注意，标记为敏感的输出值在结果中用<code>&lt;sensitive&gt;</code>标记屏蔽了。这确保敏感数据受到保护，但在需要时可用。</p>

<p>接下来，我们将使用<code>part02/iac_kubernetes_app/</code>目录中的代码来创建一个Kubernetes部署和附带的<code>LoadBalancer</code>服务。</p>

<h3>Terraform初始化part02/iac_kubernetes_app/</h3>

<p>我们现在可以使用<code>part02/iac_kubernetes_app/</code>目录中的代码将我们的应用程序部署到这个GKE集群。使用以下命令将目录更改为目录:</p>

<pre><code>cd part02/iac_kubernetes_app/
</code></pre>

<p>在<code>part02/iac_kubernetes_app/</code>中，运行此命令初始化Terraform项目:</p>

<pre><code>terrform init
</code></pre>
<p>这是我的输出。</p>

<pre><code>Initializing the backend...

Successfully configured the backend "remote"! Terraform will automatically
use this backend unless the backend configuration changes.

Initializing provider plugins...
- Checking for available provider plugins...
- Downloading plugin for provider "kubernetes" (hashicorp/kubernetes) 1.11.3...

The following providers do not have any version constraints in configuration,
so the latest version was installed.

To prevent automatic upgrades to new major versions that may contain breaking
changes, it is recommended to add version = "..." constraints to the
corresponding provider blocks in configuration, with the constraint strings
suggested below.

* provider.kubernetes: version = "~&gt; 1.11"

Terraform has been successfully initialized!
</code></pre>

<h3>GKE集群凭据</h3>

<p>使用Terraform创建<code>google_container_cluster</code>后，需要对集群进行身份验证。您可以使用<a href="https://cloud.google.com/sdk/docs/quickstarts"> Google Cloud CLI </a>来配置集群访问，并生成一个<a href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/"> kubeconfig </a>文件。执行以下命令:</p>

<pre><code>gcloud container clusters get-credentials cicd-workshops --zone="us-east1-d"
</code></pre>

<p>使用这个命令，<code>gcloud</code>将生成一个使用<code>gcloud</code>作为认证机制的kubeconfig条目。该命令使用<code>cicd-workshops</code>值作为集群名称，该名称也在<code>variables.tf</code>中指定。</p>

<h3>Terraform应用part02/iac_kubernetes_app/</h3>

<p>最后，我们准备使用Terraform将我们的应用程序部署到GKE集群。执行以下命令:</p>

<pre><code>terraform plan
</code></pre>

<p>这是我的输出。</p>

<pre><code>Refreshing Terraform state in-memory prior to plan...
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.
------------------------------------------------------------------------
An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create
Terraform will perform the following actions:
  # kubernetes_deployment.app will be created
  + resource "kubernetes_deployment" "app" {
      + id = (known after apply)
      + metadata {
          + generation       = (known after apply)
          + labels           = {
              + "app" = "cicd-101"
            }
          + name             = "cicd-101"
          + namespace        = "default"
          + resource_version = (known after apply)
          + self_link        = (known after apply)
          + uid              = (known after apply)
        }
  ...
</code></pre>

<p>Terraform将根据<code>deployment.tf</code>和<code>services.tf</code>文件中的代码为您创建新的GCP资源。现在，您可以创建新的基础设施并部署应用程序。在终端中运行以下命令:</p>

<pre><code>terraform apply
</code></pre>
<p>Terraform将提示您确认您的命令。键入<code>yes</code>并按回车键。</p>

<pre><code>Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes
</code></pre>

<p>Terraform将为您构建新的Kubernetes应用程序部署和相关的负载平衡器。</p>

<p><strong>注意</strong> : <i>集群需要3-5分钟才能完成。这不是一个即时的过程，因为后端系统正在进行配置并使其上线。</i></p>

<p>在我的集群完成之后，这就是我的输出。</p>

<pre><code>Apply complete! Resources: 2 added, 0 changed, 0 destroyed.

Outputs:

endpoint = 104.196.222.238
gke_cluster = cicd-workshops
</code></pre>

<p>该应用程序现在已经部署。<code>endpoint</code>值和输出是集群<code>LoadBalancer</code>的公共入口的IP地址。它还表示您可以访问应用程序的地址。打开网络浏览器，使用<code>output</code>值访问应用程序。将会出现一个网页，内容为“欢迎使用CircleCI学习CI/CD 101！”。</p>

<h3>使用地形摧毁</h3>

<p>您已经证明您的Kubernetes部署工作正常，并且将应用程序部署到GKE集群已经过成功测试。你可以让它继续运行，但要知道，在谷歌云平台上运行任何资产都是有成本的，你要为这些成本负责。谷歌为其免费试用注册提供了慷慨的300美元信用，但如果你让资产运行，你可以很容易地吃掉它。</p>

<p>运行<code>terraform destroy</code>将终止您在本教程中创建的任何正在运行的资源。</p>

<p>运行以下命令销毁GKE集群。</p>

<pre><code>terraform destroy
</code></pre>

<p>请记住，上面的命令只会销毁<code>part02/iac_kubeernetes_app/</code>部署，您需要运行以下命令来销毁在本教程中创建的<i>所有</i>资源。</p>

<pre><code>cd ../iac_gke-cluster/

terraform destroy
</code></pre>

<p>这将破坏我们之前创建的GKE集群。</p>

<h2>结论</h2>

<p>恭喜你！您已经完成了本系列的第2部分，并且通过构建和发布新的Docker映像，以及使用基础设施作为代码和平台将应用程序配置和部署到Kubernetes集群，提升了您的体验。</p>

<p>继续本教程的第3部分,您将学习如何使用CircleCI将所有这些令人惊叹的知识自动化到CI/CD管道中。</p>

<p>以下资源将帮助您扩展知识:</p>





        
          
          
        
      </div>
    </div>    
</body>
</html>
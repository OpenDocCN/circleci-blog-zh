<html>
<head>
<title>Kubernetes - Infrastructure as Code - Kubernetes tutorial | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Kubernetes -基础设施代码- Kubernetes教程| CircleCI</h1>
<blockquote>原文：<a href="https://circleci.com/blog/automate-releases-from-pipelines-using-infrastructure-as-code/#2019-07-24T08:00:00-07:00">https://circleci.com/blog/automate-releases-from-pipelines-using-infrastructure-as-code/#2019-07-24T08:00:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p><a href="https://circleci.com/blog/a-brief-history-of-devops-part-iv-continuous-delivery-and-continuous-deployment/" target="_blank" rel="noreferrer noopener">持续交付</a>使开发人员、团队和组织能够毫不费力地更新代码并向他们的客户发布新特性。这一切都是可能的，因为团队和组织内最近的文化转变，他们开始接受CI/CD和DevOps实践。实施CI/CD和DevOps实践使这些团队能够更好地利用现代工具，以高度的信心和一致性来构建、测试和部署他们的软件。</p>

<p>基础设施即代码(IaC)使团队能够轻松管理他们的云资源，方法是在代码中静态定义和声明这些资源，然后通过代码部署和动态维护这些资源。在本文中，我将演示如何在CI/CD管道中实现IaC。这篇文章还演示了如何在管道中实现我们合作伙伴的Pulumi orb。这个orb定义并部署一个应用到一个<a href="https://cloud.google.com/kubernetes-engine/" target="_blank" rel="noreferrer noopener"> Google Kubernetes引擎(GKE) </a>集群。Pulumi将提供该职位的IaC部分。</p>

<h2>假设</h2>

<p>这篇文章假设您在<a href="https://github.com" target="_blank" rel="noreferrer noopener"> GitHub </a>上有一个现有的Git存储库。这里提供的代码示例需要存在于项目repo的目录中。</p>

<h2>使用的技术</h2>

<p>这篇文章还假设读者对以下内容有基本的了解；</p>



<h2>启动装置</h2>

<p>Pulumi使开发人员能够用他们喜欢的语言(例如JavaScript、Python、Go等)编写代码。)，轻松部署云应用和基础设施，无需学习专门的DSL或YAML模板解决方案。一流语言的使用使得抽象和重用成为可能。Pulumi在所有主要云服务提供商(如AWS、Azure、GCP等)中提供高级别的云包和低级别的资源定义。)这样你就可以掌握一个系统交付给所有人。</p>

<p>在您选择的应用程序存储库中，创建一个Pulumi应用程序将驻留的新目录。</p>

<pre><code class="language-shell">mkdir -p pulumi/gke
cd pulumi/gke
</code></pre>

<p>接下来，注册Pulumi和Google Cloud账户，如果你以前没有注册过的话。</p>



<p>在创建了一个新的Pulumi项目之后，现在在<code>pulumi/gke</code>目录中有三个文件:</p>

<ul>
  <li><strong>pulumi . YAML</strong>——指定关于项目的元数据。</li>
  <li><strong>普鲁米。&lt;栈名&gt;。YAML</strong>——包含我们初始化的堆栈的配置值。<strong> <em> &lt;栈名&gt; </em> </strong>应该替换为创建新的Pulumi项目时定义的<strong>栈名</strong>。出于本教程的目的，我们将这个文件命名为<code>Pulumi.k8s.yaml</code>。</li>
  <li><strong> __main__。py </strong> -定义堆栈资源的Pulumi程序。这就是IaC <a href="https://www.brainyquote.com/quotes/arthur_c_clarke_101182" target="_blank" rel="noreferrer noopener">魔法</a>发生的地方。</li>
</ul>

<p>编辑<code>Pulumi.&lt;stack name&gt;.yaml</code>文件并将以下内容粘贴到其中:</p>

<pre><code class="language-yaml">config:
  gcp:credentials: ./cicd_demo_gcp_creds.json
  gcp:project: cicd-workshops
  gcp:region: us-east1
  gcp:zone: us-east1-d
  gke:name: k8s
</code></pre>

<p>编辑<code>__main__.py</code>文件并将其内容替换为:</p>

<pre><code class="language-python">import os
import pulumi
import pulumi_kubernetes
from pulumi import ResourceOptions
from pulumi_kubernetes.apps.v1 import Deployment
from pulumi_kubernetes.core.v1 import Namespace, Pod, Service
from pulumi_gcp import container

conf = pulumi.Config('gke')
gcp_conf = pulumi.Config('gcp')

stack_name = conf.require('name')
gcp_project = gcp_conf.require('project')
gcp_zone = gcp_conf.require('zone')

app_name = 'cicd-app'
app_label = {'appClass':app_name}
cluster_name = app_name

image_tag = ''
if 'CIRCLE_SHA1' in os.environ:
    image_tag = os.environ['CIRCLE_SHA1']
else:
    image_tag = 'latest'

docker_image = 'ariv3ra/orb-pulumi-gcp:{0}'.format(image_tag)

machine_type = 'g1-small'

cluster = container.Cluster(
    cluster_name,
    initial_node_count=3,
    min_master_version='latest',
    node_version='latest',
    node_config={
        'machine_type': machine_type,
        'oauth_scopes': [
            "https://www.googleapis.com/auth/compute",
            "https://www.googleapis.com/auth/devstorage.read_only",
            "https://www.googleapis.com/auth/logging.write",
            "https://www.googleapis.com/auth/monitoring",
        ],
    }
)

# Set the Kubeconfig file values here
def generate_k8_config(master_auth, endpoint, context):
    config = '''apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: {masterAuth}
    server: https://{endpoint}
  name: {context}
contexts:
- context:
    cluster: {context}
    user: {context}
  name: {context}
current-context: {context}
kind: Config
preferences: {prefs}
users:
- name: {context}
  user:
    auth-provider:
      config:
        cmd-args: config config-helper --format=json
        cmd-path: gcloud
        expiry-key: '{expToken}'
        token-key: '{tokenKey}'
      name: gcp
    '''.format(masterAuth=master_auth, context=context, endpoint=endpoint, 
            prefs='{}', expToken = '{.credential.token_expiry}', tokenKey='{.credential.access_token}')

    return config
    
gke_masterAuth = cluster.master_auth['clusterCaCertificate']
gke_endpoint = cluster.endpoint
gke_context = gcp_project+'_'+gcp_zone+'_'+cluster_name

k8s_config = pulumi.Output.all(gke_masterAuth,gke_endpoint,gke_context).apply(lambda args: generate_k8_config(*args))

cluster_provider = pulumi_kubernetes.Provider(cluster_name, kubeconfig=k8s_config)
ns = Namespace(cluster_name, __opts__=ResourceOptions(provider=cluster_provider))

gke_deployment = Deployment(
    app_name,
    metadata={
        'namespace': ns,
        'labels': app_label,
    },
    spec={
        'replicas': 3,
        'selector':{'matchLabels': app_label},
        'template':{
            'metadata':{'labels': app_label},
            'spec':{
                'containers':[
                    {
                        'name': app_name,
                        'image': docker_image,
                        'ports':[{'name': 'port-5000', 'container_port': 5000}]
                    }
                ]
            }
        }
    },
    __opts__=ResourceOptions(provider=cluster_provider)
)

deploy_name = gke_deployment

gke_service = Service(
    app_name,
    metadata={
        'namespace': ns,
        'labels': app_label,
    },
    spec={
        'type': "LoadBalancer",
        'ports': [{'port': 80, 'target_port': 5000}],
        'selector': app_label,
    },
    __opts__=ResourceOptions(provider=cluster_provider)
)

pulumi.export("kubeconfig", k8s_config)
pulumi.export("app_endpoint_ip", gke_service.status['load_balancer']['ingress'][0]['ip'])
</code></pre>

<p><code>__main__.py</code>文件中的内容指定了您将从管道中部署的GKE集群和基础设施。这个Pulumi应用程序创建了一个三节点Kubernetes集群，它通过Docker容器在pods中运行应用程序。这段代码还创建了一个<code>Load Balancer</code>资源，它将流量均匀地路由到各个计算节点上的活动Docker容器。如果你想了解更多关于Pulumi Python应用的信息，请访问<a href="https://pulumi.io/reference/python/" target="_blank" rel="noreferrer noopener">网站</a>获取详细解释。</p>

<h2>Google云设置</h2>

<p>在本节中，您将创建和生成必要的GCP凭证。这些凭证将为我们的CI/CD管道和Pulumi代码提供访问权限，以便在GCP上执行命令。</p>

<h3>创建一个GCP项目</h3>

<p>默认项目是为新帐户默认设置的。我建议您创建一个新项目，并保持它的独立性，以便以后可以轻松地拆除它。创建后，请务必将<code>project id</code>复制下来，因为它与<code>project name</code>不同。</p>

<p><img src="../Images/3148a095599913fd92c76a4e6737dc04.png" alt="How to find your project id." title="Project Id" data-original-src="https://storage.googleapis.com/gcp-community/tutorials/getting-started-on-gcp-with-terraform/gcp_project_id.png"/></p>

<h3>获取项目凭据</h3>

<p>接下来，设置一个服务帐户密钥，Pulumi 将使用它来创建和管理您的GCP项目中的资源。进入<a href="https://console.cloud.google.com/apis/credentials/serviceaccountkey" target="_blank" rel="noreferrer noopener">创建服务账户密钥页面</a>。选择默认服务账户或新建一个，选择<code>JSON</code>作为密钥类型，点击<strong>创建</strong>。将这个<code>.json</code>文件保存在<code>pulumi/gke</code>文件夹中。</p>

<p><strong>重要安全提示:</strong> <i>将文件重命名为<code>cicd_demo_gcp_creds.json</code>，以保护您的Google Cloud凭据不会在公共GitHub存储库中发布和暴露。此外，您可以在这个项目的<code>.gitignore</code>文件中添加凭证的<code>.json</code>文件名。您必须非常谨慎地使用该文件中的数据，因为一旦暴露，任何拥有该信息的人都可以登录您的帐户，并在您的Google Cloud帐户上创建资源和运行费用。</i></p>

<h2>cicekci设置</h2>

<p>现在，我们需要配置CircleCI和我们的管道<a href="https://circleci.com/docs/configuration-reference/" target="_blank" rel="noreferrer noopener">配置文件</a>来将Pulumi集成到我们的CI/CD管道中。</p>

<h3>对Google服务帐户文件进行编码</h3>

<p>服务帐户文件必须编码成一个<code>base64</code>值，以便将该数据作为一个<a href="https://circleci.com/docs/env-vars/">环境变量</a>存储在CircleCI中。在终端中运行以下命令，对值进行编码并获得结果:</p>

<pre><code class="language-shell">base64 cicd_demo_gcp_creds.json
</code></pre>

<p>该命令的结果将类似于以下内容:</p>

<pre><code class="language-shell">ewogICJ0eXBlIjogInNlcnZpY2VfYWNjb3VudCIsCiAgInByb2plY3RfaWQiOiAiY2ljZC13b3Jrc2hvcHMiLAogICJwcml2YXRlX2tleV9pZCI6ICJiYTFmZDAwOThkNTE1ZTE0NzE3ZjE4NTVlOTY1NmViMTUwNDM4YTQ4IiwKICAicHJpdmF0ZV9rZXkiOiAiLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXG5NSUlFdlFJQkFEQU5CZ2txaGtpRzl3MEJBUUVGQUFTQ0JLY3dnZ1NqQWdFQUFvSUJBUURjT1JuRXFla3F4WUlTXG5UcHFlYkxUbWdWT3VzQkY5NTE1YkhmYWNCVlcyZ2lYWjNQeFFBMFlhK2RrYjdOTFRXV1ZoRDZzcFFwWDBxY2l6XG5GdjFZekRJbXkxMCtHYnlUNWFNV2RjTWw3ZlI2TmhZay9FeXEwNlc3U0FhV0ZnSlJkZjU4U0xWcC8yS1pBbjZ6XG5BTVdHZjM5RWxSNlhDaENmZUNNWXorQmlZd29ya3Nob3BzLmlhbS5nc2VydmljZWFjY291bnQuY29tIgp9Cg==
</code></pre>

<p>将结果复制到您的剪贴板，因为我们将在下一部分使用它。</p>

<h3>创建项目变量</h3>

<p>为了让这个CI/CD管道在GCP上执行命令，我们必须在CircleCI中配置<a href="https://circleci.com/docs/env-vars/#setting-an-environment-variable-in-a-project" target="_blank" rel="noreferrer noopener">项目级环境变量</a>。</p>

<p>使用CircleCI仪表板创建以下项目级环境变量:</p>

<ul>
  <li><strong> $DOCKER_LOGIN </strong> =您的Docker Hub用户名</li>
  <li><strong> $DOCKER_PWD </strong> =您的Docker Hub密码</li>
  <li><strong> $GOOGLE_CLOUD_KEYS </strong> =上一节的base64编码结果</li>
  <li><strong> $PULUMI_ACCESS_TOKEN </strong> =从PULUMI仪表板生成访问令牌</li>
</ul>

<h3>集成了Pulumi的CI/CD管道</h3>

<p>现在，您已经拥有了将Pulumi应用程序集成到CircleCI <code>config.yml</code>文件中所需的所有元素。编辑您的<code>config.yml</code>并将以下配置粘贴到您的文件中。这个<code>config.yaml</code>的内容特定于我在演示和演讲中使用的一个示例Python项目，因此您的项目的<code>config.yml</code>将会不同。要查看完整的示例项目，请在GitHub <a href="https://github.com/datapunkz/orb-pulumi-gcp" target="_blank" rel="noreferrer noopener">点击</a>查看回购。我将引导您并解释这个示例配置中重要的Pulumi集成部分，以便您对正在发生的事情有一个清晰的理解。</p>

<pre><code class="language-yaml">version: 2.1
orbs:
  pulumi: pulumi/pulumi@1.0.1
jobs:
  build_test:
    docker:
      - image: circleci/python:3.7.2
        environment:
          PIPENV_VENV_IN_PROJECT: 'true'
    steps:
      - checkout
      - run:
          name: Install Python Dependencies
          command: |
            pipenv install --skip-lock
      - run:
          name: Run Tests
          command: |
            pipenv run pytest
  build_push_image:
    docker:
      - image: circleci/python:3.7.2
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: false
      - run:
          name: Build and push Docker image
          command: |       
            pipenv install --skip-lock
            pipenv run pyinstaller -F hello_world.py
            echo 'export TAG=${CIRCLE_SHA1}' &gt;&gt; $BASH_ENV
            echo 'export IMAGE_NAME=orb-pulumi-gcp' &gt;&gt; $BASH_ENV
            source $BASH_ENV
            docker build -t $DOCKER_LOGIN/$IMAGE_NAME -t $DOCKER_LOGIN/$IMAGE_NAME:$TAG .
            echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin
            docker push $DOCKER_LOGIN/$IMAGE_NAME
  deploy_to_gcp:
    docker:
      - image: circleci/python:3.7.2
        environment:
          CLOUDSDK_PYTHON: '/usr/bin/python2.7'
          GOOGLE_SDK_PATH: '~/google-cloud-sdk/'
    steps:
      - checkout
      - pulumi/login:
          access-token: ${PULUMI_ACCESS_TOKEN}
      - run:
          name: Install dependecies
          command: |
            cd ~/
            sudo pip install --upgrade pip==18.0 &amp;&amp; pip install --user pulumi pulumi-gcp pulumi-kubernetes
            curl -o gcp-cli.tar.gz https://dl.google.com/dl/cloudsdk/channels/rapid/google-cloud-sdk.tar.gz
            tar -xzvf gcp-cli.tar.gz
            echo ${GOOGLE_CLOUD_KEYS} | base64 --decode --ignore-garbage &gt; ${HOME}/project/pulumi/gcp/gke/cicd_demo_gcp_creds.json
            ./google-cloud-sdk/install.sh  --quiet 
            echo 'export PATH=$PATH:~/google-cloud-sdk/bin' &gt;&gt; $BASH_ENV
            source $BASH_ENV
            gcloud auth activate-service-account --key-file ${HOME}/project/pulumi/gcp/gke/cicd_demo_gcp_creds.json
      - pulumi/update:
          stack: k8s
          working_directory: ${HOME}/project/pulumi/gcp/gke/
workflows:
  build_test_deploy:
    jobs:
      - build_test
      - build_push_image:
          requires:
            - build_test
      - deploy_to_gcp:
          requires:
          - build_push_image
</code></pre>

<p>下面的代码片段指定将在这个管道中使用<a href="https://circleci.com/developer/orbs/orb/pulumi/pulumi" target="_blank" rel="noreferrer noopener"> Pulumi orb </a>。</p>

<pre><code class="language-yaml">version: 2.1
orbs:
  pulumi: pulumi/pulumi@1.0.1
</code></pre>

<p>示例管道中的<code>jobs:</code>键定义了三个单独的作业:</p>

<ul>
  <li>
    <p>这个任务运行应用程序单元测试</p>
  </li>
  <li>
    <p><code>build_push_image</code>:该作业基于通常共存于项目报告中的Docker文件构建新的Docker映像</p>
  </li>
  <li>
    <p>这个任务通过Pulumi orb部署到GKE集群</p>
  </li>
</ul>

<p>我将专注于<code>build_push_image</code>和<code>deploy_to_gcp</code>工作。</p>

<h3>构建_推送_映像:</h3>

<pre><code class="language-yaml">  build_push_image:
    docker:
      - image: circleci/python:3.7.2
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: false
      - run:
          name: Build and push Docker image
          command: |       
            pipenv install --skip-lock
            pipenv run pyinstaller -F hello_world.py
            echo 'export TAG=${CIRCLE_SHA1}' &gt;&gt; $BASH_ENV
            echo 'export IMAGE_NAME=orb-pulumi-gcp' &gt;&gt; $BASH_ENV
            source $BASH_ENV
            docker build -t $DOCKER_LOGIN/$IMAGE_NAME -t $DOCKER_LOGIN/$IMAGE_NAME:$TAG .
            echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin
            docker push $DOCKER_LOGIN/$IMAGE_NAME
</code></pre>

<p>在应用程序经过测试并成功通过后，<code>build_push_image</code>作业将应用程序打包成一个可执行的二进制文件。然后它启动了<code>docker build</code>命令，该命令基于项目回购中的<code>Dockerfile</code>构建了一个新的Docker映像。该作业还使用现有的环境变量，并定义一些新的环境变量，用于指定唯一的Docker图像名称。以下是该项目的<code>Dockerfile</code>:</p>

<pre><code class="language-dockerfile">FROM python:3.7.2
RUN mkdir /opt/hello_world/
WORKDIR /opt/hello_world/
COPY dist/hello_world /opt/hello_world/
EXPOSE 80
CMD [ "./hello_world" ]
</code></pre>

<p><code>docker push</code>命令将我们新建的Docker映像上传到Docker Hub，以便将来存储和检索。</p>

<h3>部署到gcp:</h3>

<pre><code class="language-yaml">  deploy_to_gcp:
    docker:
      - image: circleci/python:3.7.2
        environment:
          CLOUDSDK_PYTHON: '/usr/bin/python2.7'
          GOOGLE_SDK_PATH: '~/google-cloud-sdk/'
    steps:
      - checkout
      - pulumi/login:
          access-token: ${PULUMI_ACCESS_TOKEN}
      - run:
          name: Install dependencies
          command: |
            cd ~/
            sudo pip install --upgrade pip==18.0 &amp;&amp; pip install --user pulumi pulumi-gcp pulumi-kubernetes
            curl -o gcp-cli.tar.gz https://dl.google.com/dl/cloudsdk/channels/rapid/google-cloud-sdk.tar.gz
            tar -xzvf gcp-cli.tar.gz
            echo ${GOOGLE_CLOUD_KEYS} | base64 --decode --ignore-garbage &gt; ${HOME}/project/pulumi/gcp/gke/cicd_demo_gcp_creds.json
            ./google-cloud-sdk/install.sh  --quiet 
            echo 'export PATH=$PATH:~/google-cloud-sdk/bin' &gt;&gt; $BASH_ENV
            source $BASH_ENV
            gcloud auth activate-service-account --key-file ${HOME}/project/pulumi/gcp/gke/cicd_demo_gcp_creds.json
      - pulumi/update:
          stack: k8s
          working_directory: ${HOME}/project/pulumi/gcp/gke/
</code></pre>

<p>上面指定的<code>deploy_to_gcp:</code>作业是管道的一部分，它利用Pulumi应用程序和orb在GCP上实际建立新的GKE集群。下面，我将简要介绍一下<code>deploy_to_gcp:</code>工作。</p>

<pre><code class="language-yaml">      - pulumi/login:
          access-token: ${PULUMI_ACCESS_TOKEN}
</code></pre>

<p>上面的代码演示了Pulumi orb的<code>login:</code>命令的规范和执行。参数<code>access-token:</code>通过您在CircleCI仪表板中设置的<code>${PULUMI_ACCESS_TOKEN}</code>环境变量传递。</p>

<pre><code class="language-shell">            curl -o gcp-cli.tar.gz https://dl.google.com/dl/cloudsdk/channels/rapid/google-cloud-sdk.tar.gz
            tar -xzvf gcp-cli.tar.gz
            echo ${GOOGLE_CLOUD_KEYS} | base64 --decode --ignore-garbage &gt; ${HOME}/project/pulumi/gcp/gke/cicd_demo_gcp_creds.json
            ./google-cloud-sdk/install.sh  --quiet 
            echo 'export PATH=$PATH:~/google-cloud-sdk/bin' &gt;&gt; $BASH_ENV
            source $BASH_ENV
            gcloud auth activate-service-account --key-file ${HOME}/project/pulumi/gcp/gke/cicd_demo_gcp_creds.json  
</code></pre>

<p>以上命令下载并安装<a href="https://pulumi.io/reference/python/" target="_blank" rel="noreferrer noopener"> Google Cloud SDK </a>。此SDK是在GCP上创建和修改GKE集群所必需的。前两行下载并解包SDK。<code>echo ${GOOGLE_CLOUD_KEYS} | base64 --decode...</code>命令解码<code>${GOOGLE_CLOUD_KEYS}</code>环境变量，然后用解码后的内容填充<code>cicd_gcp_creds.json</code>。这个文件必须存在于Pulumi应用程序项目的目录中。这个特定的<code>run:</code>块中的其余命令安装SDK，最后一行授权服务帐户通过<code>cicd_demo_gcp_creds.json</code>文件访问GCP。</p>

<pre><code class="language-yaml">  - pulumi/update:
      stack: k8s
      working_directory: ${HOME}/project/pulumi/gcp/gke/
</code></pre>

<p>上面的代码利用Pulumi orb的<code>update:</code>命令将应用程序部署到GCP的一个新的GKE集群上。<code>pulumi/update:</code>命令显示了<code>stack:</code>和<code>working_directory:</code>参数，它们代表了Pulumi堆栈的名称和初始化为Pulumi项目的目录的文件路径。您的<code>working_directory:</code>将不同于上面的代码示例。</p>

<h2>结论</h2>

<p>在本文中，我展示了如何将基础设施作为代码解决方案集成到CI/Cd管道中。我还演示了如何在CI/CD管道中声明和执行CircleCI orb技术。这些示例提供了对使用CI/CD自动化来构建、测试和部署使用IaC解决方案的代码的坚实理解。</p>

<p>使用CircleCI orbs通过简化我们编写CircleCI配置的方式来提高生产率。orb也可以共享，这通过在我们的配置文件中使用预构建的命令、作业和执行器来节省时间。orb并不局限于CircleCI + GKE部署。您可以浏览<a href="https://circleci.com/developer/orbs" target="_blank" rel="noreferrer noopener"> Orb注册表</a>中的可用Orb列表，找到符合您选择的云平台、编程语言、testng工具等的Orb。</p>

<p>要查看完整的示例项目，请查看GitHub上的repo<a href="https://github.com/datapunkz/orb-pulumi-gcp" target="_blank" rel="noreferrer noopener">这里</a>。</p>



        
          
          
        
      </div>
    </div>    
</body>
</html>
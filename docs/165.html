<html>
<head>
<title>Clojure microservices for JavaScript developers part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>面向JavaScript开发人员的Clojure微服务第3部分</h1>
<blockquote>原文：<a href="https://circleci.com/blog/clojure-microservices-for-js-devs-pt-3/#2021-07-26T04:20:00-07:00">https://circleci.com/blog/clojure-microservices-for-js-devs-pt-3/#2021-07-26T04:20:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>这个系列由穆萨·巴里格扎伊和泰勒·苏尔贝格共同撰写。</p>

<p>这是JavaScript开发人员关于如何设置Clojure微服务的系列文章中的第三篇，也是最后一篇。以前的职位是:</p>



<p>那些以前的帖子是有用的背景，但是你可以<a href="https://github.com/tsully/clojure-for-js-devs">克隆回购</a>并在不阅读它们的情况下进入这篇帖子。</p>

<h2>使用Clojure测试API</h2>

<p>与JavaScript相比，Clojure的一个方便的特性是它自带了一个内置的单元测试库，<a href="https://clojure.github.io/clojure/clojure.test-api.html"> clojure.test </a>。按照惯例，在Leinegen项目中，你有一个src目录，我们知道它保存了所有的代码，并且用于测试一个测试目录，将你的代码从你的测试中分离出来。对于您想要测试的在<code>src</code>下的任何文件，您可以在后缀为<code>\_test</code>的<code>/test</code>下创建一个匹配的文件。</p>

<p>假设我们有一个文件<code>adder.clj</code>，在Leiningen项目的下面的文件结构中。</p>

<pre><code>src/
├─ adder/
│  ├─ adder.clj
</code></pre>

<p>为了编写<code>adder.clj</code>的单元测试，我们将创建以下测试目录:</p>

<pre><code>src/
├─ adder/
│  ├─ adder.clj
test/
├─ adder/
│  ├─ adder_test.clj
</code></pre>

<p>注意<code>test</code>目录是如何镜像我们的<code>src</code>目录的，以及我们如何在我们想要测试的文件上添加一个<code>\_test</code>后缀。</p>

<p>我们想在<code>adder.clj</code>中测试下面的函数。</p>

<pre><code>(defn add-numbers [x y]
  (+ x y))
</code></pre>

<p>要在<code>adder.clj</code>中为<code>add-numbers</code>函数编写测试，首先要引入Clojure核心测试框架。</p>

<pre><code>(ns adder
  (:require [clojure.test :refer [deftest]))
</code></pre>

<p>利用<code>deftest</code>宏，编写测试就像:</p>

<pre><code>(deftest test-add-numbers
  (is (= 4 (add-numbers 2 2))))
</code></pre>

<p>在我们的<a href="https://github.com/tsully/clojure-for-js-devs">示例项目</a>中，我们对所有的HTTP端点处理程序都进行了单元测试。下面是一个例子(可以在test/clo jure _ for _ js _ devs/handlers _ test . clj中找到)。这是为我们的<code>/counter</code>路径测试处理程序。<code>/counter</code>路径将请求者的IP地址作为一个关键字添加到Redis中，并将值加1，记录一个keeping的次数<code>/counter</code>。</p>

<pre><code>(testing "counter-handler"
    (let [response "Counter: 44"
          req (-&gt;  (ring-mock/request :get "/counter"))]
      (bond/with-stub! [[redis/getKey (constantly 44)] [redis/incr (constantly nil)]]
        (is (= (handlers/counter-handler req {}) response)))))
</code></pre>

<p>这里发生了很多事情，所以让我们来为您分析一下。</p>

<p>首先，我们为想要测试的端点(<code>/counter</code>)初始化一个请求对象<code>req</code>。我们正在利用ring-clojure(我们的HTTP服务器框架)附带的请求模拟库。这为我们节省了时间；我们不需要写出完整的请求映射。</p>

<p>接下来，我们使用库<code>bond/with-stub!</code>。在JavaScript中，最流行的测试框架是<a href="https://jestjs.io/"> Jest </a>。如果你以前和Jest合作过，bond会给你<a href="https://jestjs.io/docs/mock-function-api">类似的特性</a>。jest.mock()允许您模仿模块，并声明您希望模仿函数的返回值是什么。这就是<code>bond/with-stub</code>在Clojure中为我们做的事情。因为这些是单元测试，我们想要模拟对Redis的调用，特别是键<code>getKey</code>和<code>incr</code>。对于<code>getKey</code>，我们希望在测试中调用它的任何时候都返回44，同样，对于<code>incr</code>，我们希望返回<code>nil</code>。</p>

<p>最后，我们断言我们对<code>handlers/counter-handler</code>的调用将匹配我们的响应<code>Counter: 44</code>。注意，<code>handlers/counter-handler</code>中的最后一个参数是我们的Redis组件，但是在这个测试中，我们传入了一个空的map <code>{}</code>。因为我们正在存根化我们的Redis调用，所以我们可以为这个参数传递一个空映射，因为在我们的测试中不需要Redis。</p>

<p>写集成测试怎么样？在JavaScript中，Jest的一个有用特性是测试的设置和拆卸。当编写集成测试时，这个特性很方便。例如，如果我们有一个查询城市数据库的应用程序，您可能会开玩笑地这样做:</p>

<pre><code>beforeAll(() =&gt; {
  initializeCityDatabase();
});

afterAll(() =&gt; {
  clearCityDatabase();
});

test("city database has Vienna", () =&gt; {
  expect(isCity("Vienna")).toBeTruthy();
});
</code></pre>

<p>beforeAll/afterAll允许您在测试之前和之后运行代码。</p>

<p>Clojure内置了对测试设置和拆卸的支持。它还利用了<a href="https://clojuredocs.org/clojure.test/use-fixtures">夹具</a>。这里有一个完整的例子:</p>

<pre><code>(ns adder_test
  (:require [clojure.test :refer [testing use-fixtures]))

(defn my-fixture [f]
  ;; The function you want to run before all tests
  (initializeCityDatabase)

  (f)  ;;Then call the function we passed.
  ;; The function you want to run after all tests
  (clearCityDatabase)
 )
lang:clojure
(use-fixtures :once my-fixture)

(deftest city-db
  (is (= "'Vienna'" (IsCity))))
</code></pre>

<p>这里我们用<code>:once</code>调用use-fixtures，这意味着在名称空间中的所有测试中只运行一次我的fixture。您还可以通过<code>:each</code>为每个测试重复运行您的夹具。<code>use-fixtures</code>这里的工作和以前一模一样/一语双关。我们用我们希望在之前和之后被调用的方法来包装我们的测试(在我的fixture中显示为(f))。</p>

<p>你可以在<a href="https://github.com/tsully/clojure-for-js-devs">示例项目</a>和<code>test/clojure_for_js_devs/test_core.clj</code>中看到完整的例子。在<a href="https://circleci.com/blog/clojure-microservices-for-js-devs-pt-2/">的帖子2 </a>中，我们讨论了<code>system-map</code>的目的。系统图允许我们的应用程序管理它所依赖的每个软件组件的生命周期。在我们的例子中，我们的组件是Redis连接和一个HTTP服务器:</p>

<pre><code>(defn- test-system
  []
  (component/system-map
   :redis (redis/new-redis "redis://localhost:6379")
   :http-server (component/using
                 (http/new-server "localhost" 0)
                 {:redis :redis})))


(defn- setup-system
  []
  (alter-var-root #'system (fn [_] (component/start (test-system)))))

(defn- tear-down-system
  []
  (alter-var-root #'system (fn [s] (when s (component/stop s)))))

(defn init-system
  [test-fn]
  (setup-system)
  (test-fn)
  (tear-down-system))
</code></pre>

<p>我们有一个方法<code>setup-system</code>,它使用组件库(来自文章1)来启动所需的组件(HTTP服务器和Redis)。除了<code>setup-system</code>，我们还有<code>tear-down-system</code>，它运行component/stop来在测试完成后关闭所有组件。</p>

<p>现在，如何在Clojure中运行测试呢？如果没有测试运行器，您可以在REPL中调用(run-all-tests)来运行所有命名空间中的所有测试。或者，如果您正在使用Leiningen跟踪，您可以调用<code>lein test</code>。</p>

<p>您可能已经使用了Jest这样的测试运行器，它具有在代码中检测到变化时自动运行测试的特性。Clojure社区也有各种具有类似特性的测试运行程序。最受欢迎的是<a href="https://github.com/lambdaisland/kaocha"> Kaocha </a>。我们在示例项目中使用Kaocha。</p>

<p>要设置Kaocha，首先将它作为一个依赖项添加到dev dependencies下的<code>project.clj</code>文件中:</p>

<pre><code>  :profiles {:uberjar {:aot :all}
                 :dev {:dependencies [[lambdaisland/kaocha "1.0.829"]
                                  [circleci/bond "0.5.0"]
                                  [ring/ring-mock]]}}
</code></pre>

<p>在JavaScript中，您可以为想要运行的自定义命令创建自定义脚本。比如<code>npm run prod:ci</code>。Leinegen也有这个特性，称为别名。我们可以创建一个别名<code>test</code>来加载<code>lambdaisland/kaocha</code>依赖项。</p>

<pre><code>:aliases {"kaocha" ["run" "-m" "kaocha.runner"]}
</code></pre>

<p>最后，添加Koacha配置文件。使用以下配置在您的根项目目录中创建一个<code>tests.edn</code>文件:</p>

<pre><code>#kaocha/v1
{:kaocha/color? true}
</code></pre>

<p>现在，如果您调用<code>lein test</code>，kaocha将执行测试并报告结果。</p>

<h2>在CircleCI中运行Clojure测试</h2>

<p>如果你正在寻找持续集成(CI)重要性的介绍，我强烈推荐你去看看<a href="https://circleci.com/continuous-integration/">https://circleci.com/continuous-integration/</a>。在这一节中，我们将回顾CI工作流以及如何在CircleCI中运行Clojure测试，</p>

<p>在我们在<code>.circleci/config.yml</code>下的示例项目中，我们有一个工作流，用于在每次提交<a href="https://github.com/tsully/clojure-for-js-devs">回购</a>时测试我们的项目。</p>

<pre><code>version: 2.1
jobs:
  build:
    docker:
      - image: circleci/clojure:lein-2.9.5
      - image: redis:4.0.2-alpine
        command: redis-server --port 6379
    working_directory: ~/repo
    environment:
      LEIN_ROOT: "true"
      JVM_OPTS: -Xmx3200m
    steps:
      - checkout
      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "project.clj" }}
            - v1-dependencies-
      - run: lein deps
      - save_cache:
          paths:
            - ~/.m2
          key: v1-dependencies-{{ checksum "project.clj" }}
      - run:
          name: install dockerize
          command: wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz &amp;&amp; sudo tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz &amp;&amp; rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz
          environment:
            DOCKERIZE_VERSION: v0.3.0
      - run:
          name: Wait for redis
          command: dockerize -wait tcp://localhost:6379 -timeout 1m
      - run: lein test

workflows:
  build:
    jobs:
      - build
</code></pre>

<p><code>jobs</code>键是我们定义可以在CI渠道中使用的工作的地方。我们的管道只有一个任务，“构建”，它将构建我们的应用程序，然后运行我们的测试。“构建”将使用Docker映像来设置我们的CI环境。我们的Clojure应用程序将使用预先构建的CircleCI Docker映像:<code>circleci/clojure:lein-2.9.5</code>运行。这些映像通常是官方Docker映像的扩展，包括对CI/CD特别有用的工具。在我们的例子中，<code>circleci/clojure:lein-2.9.5</code>安装了Clojure和lein。我们还使用Redis Docker映像，因为我们的集成测试需要访问Redis服务器。</p>

<p>下面是我们“构建”工作的所有步骤的回顾:</p>

<ol>
  <li>我们首先从我们的回购中检查我们的代码。</li>
  <li>然后，我们包装<code>lein deps</code>调用，用缓存获取我们所有的依赖项。我们不需要在每次CI运行时都重新安装所有的依赖项，因此缓存将加快我们的CI构建。</li>
  <li>然后我们引入Dockerize，这是一个工具，它使我们的CI能够在运行测试之前等待其他服务可用。在我们的例子中，我们使用Dockerize在运行集成测试之前等待Redis。</li>
  <li>最后，我们运行<code>lein test</code>来运行我们所有的测试。</li>
</ol>

<p>我们现在让CI管道在每次提交时运行，自动确保没有人对我们的Clojure项目进行重大更改。</p>

<p>就是这样！现在，您已经有了一个Clojure微服务，它使用持续集成工作流进行基本测试。我们希望您发现这个系列很有价值，并且有信心在您的下一个项目中使用Clojure。</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>
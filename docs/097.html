<html>
<head>
<title>Continuous integration for Android projects | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Android项目的持续集成| CircleCI</h1>
<blockquote>原文：<a href="https://circleci.com/blog/building-android-on-circleci/#2022-08-26T06:27:00-07:00">https://circleci.com/blog/building-android-on-circleci/#2022-08-26T06:27:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>CircleCI在Android开发人员中很受欢迎，原因有几个:它可以快速入门，快速执行具有高并行性的构建，(无论是本机、跨平台还是多平台)，甚至支持使用我们的Android机器映像直接从CircleCI运行Android模拟器。</p>

<p>本文将向您展示如何在CircleCI平台上为一个示例项目构建和测试Android应用程序。完整的源代码可以在GitHub-CircleCI-Public/Android-testing-circle ci-examples上找到<a href="https://github.com/CircleCI-Public/android-testing-circleci-examples" target="_blank" rel="noreferrer noopener">，你可以在相应的circle ci项目</a>中找到工作管道<a href="https://app.circleci.com/pipelines/github/CircleCI-Public/android-testing-circleci-examples">。</a></p>

<p>为了从本文中获得最大收益，您应该</p>
<ul>
  <li>Android开发的工作知识</li>
  <li>熟悉Android工具和测试框架</li>
  <li>能够使用Gradle构建系统</li>
</ul>

<h2>CircleCI为Android提供了什么</h2>

<p>我们为您提供了一些构建Android的工具:</p>

<ul>
  <li>Docker图像</li>
  <li>Android机器图像</li>
  <li>安卓orb</li>
</ul>

<h3>图像对接器</h3>

<p>Docker图像是团队使用的主要执行者。它运行在Docker容器中，因此启动非常快，并且包含了开始构建Android项目所需的一切。预装工具的完整列表可以在文档中找到<a href="https://circleci.com/developer/images/image/cimg/android">。这些图片还附带了预装Node.js、Android NDK和浏览器工具的变体。</a></p>

<h3>机器图像</h3>

<p>变化最大的是<a href="https://circleci.com/developer/machine/image/android">新安卓机镜像</a>。这是一个虚拟机映像，所以比上面提到的Docker映像花费的时间多一点，但它包含了构建Android应用程序可能需要的所有工具，包括SDK、Google Cloud tools for Firebase、<a href="/features/python/"> Python </a>、Node。JS和浪子。然而最大的变化是对嵌套虚拟化的支持，它允许你在这个机器映像中运行Android模拟器。</p>

<p>Android机器映像支持嵌套虚拟化，这允许在CircleCI作业中运行x86模拟器。如果你从平台早期就开始为Android开发，你可能记得模拟器非常慢。然后x86模拟器开始支持英特尔的Hyper-V虚拟机管理程序，这让模拟器直接使用主机的资源。像这样直接使用资源使得模拟器能够运行得更加流畅和快速。</p>

<p>很长一段时间，支持仅限于我们的本地硬件。对CircleCI的有限支持降低了模拟器的速度，并使其难以运行UI测试。嵌套虚拟化解决了这一问题，它为可大规模复制的CI/CD环境增加了对快速仿真的支持，使所有的好处都变得可用。</p>

<h3>安卓Orb</h3>

<p>最后是CircleCI Android orb，它提供了作为执行者对两个映像的轻松访问，以及安装SDK、运行模拟器、缓存、测试等方便的任务和命令。你可以在orb文档<a href="https://circleci.com/developer/orbs/orb/circleci/android">的链接</a>中阅读更多关于orb的内容。</p>

<h2>介绍Android CI演示项目</h2>

<p>我已经创建了一个<a href="https://github.com/zmarkan/android-testing-circleci-examples" target="_blank" rel="noreferrer noopener">演示项目</a>，这是谷歌自己的Android测试Codelab源代码的一个分支。Codelab是一个简单的待办事项列表管理器应用程序，包含单元测试和工具测试的组合，有和没有UI。该项目还可以在CircleCI 上观看<a href="https://app.circleci.com/pipelines/github/zmarkan/android-testing-circleci-examples">。如果在Android Studio中打开，一定要切换到<code>Project</code>视图。项目视图允许您查看我们将要查看的<code>.circleci/config.yml</code>文件。</a></p>

<p>该项目有一个单独的<code>app</code>模块，带有默认的<code>debug</code>和<code>release</code>变量。<code>test</code>目录包含单元测试，而<code>androidTest</code>目录包含仪器测试。包括了完整的CircleCI配置，我将在本文中引用它。配置位于<code>.circleci/config.yml</code>。</p>

<h2>为示例Android应用程序构建和测试CI</h2>

<p>我们的CI流程必须做到三点:</p>
<ol>
  <li>在虚拟机中运行单元测试</li>
  <li>在模拟器上运行检测测试</li>
  <li>构建应用程序的发布版本</li>
</ol>

<p>我们将同时运行单元测试和仪器测试。如果两种类型的测试都成功了，我们就可以组装发布版本了。我们还将添加一个条件，如果新的工作已经提交到“主”分支，并且只有在从23到30的每个Android版本上成功的模拟器测试之后，才继续发布版本<i/>。当我们的构建满足这个条件时，我们将有坚实的保证，我们的应用程序将在许多不同的Android设备上工作。</p>

<p><strong>注意:</strong> <i>正如我之前提到的，从这一点开始的一切都将引用<code>.circleci/config.yml</code>中的CircleCI配置文件。</i></p>

<h3>使用CircleCI Android orb</h3>

<p>创建我们的<a href="https://circleci.com/blog/what-is-a-ci-cd-pipeline/"> CI管道</a>的第一步是使用Android orb，它包含许多已经为您预先编写好的步骤。最新版本可在<a href="https://circleci.com/developer/orbs/orb/circleci/android"> orb文档</a>中获得。</p>

<p>定义orb后，脚本指定这些作业:</p>
<ul>
  <li><code>unit-test</code></li>
  <li><code>android-test</code></li>
  <li><code>release-build</code></li>
</ul>

<p>还包括一个工作流程<code>test-and-build</code>。</p>

<pre><code class="language-yaml">version: 2.1

orbs:
  android: "2.1.2"

jobs:
  unit-test:
    ...
  android-test:
    ...
  release-build:
    ...
    # We'll get to this later

workflows:
  test-and-build:
    ...
  # We'll get to this later
</code></pre>

<h3>运行单元测试</h3>

<p>我们的<code>unit-test</code>作业包含一个来自Android orb的执行程序:<code>android/android-docker</code>。如上所述，它在Docker容器中运行，启动速度极快。</p>

<p>在第<code>steps</code>节中，有一些事情需要注意。首先，我们运行<code>android/restore-gradle-cache</code> Gradle cache帮助存储我们的依赖项并构建工件。在运行测试命令之后，我们还运行<code>android/save-gradle-cache</code>和<code>android/save-build-cache</code>来确保后续的构建通过使用缓存运行得更快。这些都来自Android orb，如前缀<code>android/</code>所示。</p>

<p>我们还可以通过将<code>find-args</code>参数传递给<code>restore-gradle-cache</code>来修改缓存的内容。在这个开源项目中可以找到一个很好的例子<a href="https://github.com/owntracks/android/blob/59f13afa93a27904e739493d96af64ab36f783eb/.circleci/continue-config.yml#L17-L44" target="_blank" rel="noreferrer noopener">。</a></p>

<p>主要的构建步骤发生在<code>android/run-tests</code>命令中，我们在<code>test-command</code>参数中调用<code>./gradlew testDebug</code>。这个命令运行<code>debug</code>构建变体的所有单元测试。另外，这个命令带有一个默认的重试值，可以帮助您避免测试失败。</p>

<pre><code class="language-yaml">jobs:
  unit-test:
    executor:
      name: android/android-docker
      tag: 2022.08.1
    steps:
      - checkout
      - android/restore-gradle-cache
      - android/run-tests:
          test-command: ./gradlew testDebug
      - android/save-gradle-cache
      ...
</code></pre>

<h3>在模拟器上运行Android测试</h3>

<p>我们的工作是使用新的Android模拟器功能。该作业使用与<code>build</code>作业相同的Android机器执行器。所有后续作业都将使用同一个执行器，缓存恢复步骤也是一样的。</p>

<p>模拟器要求我们在机器映像上运行，所以我们指定<code>android/android-machine</code>作为执行器。为了缩短构建时间，我们将<code>resource-class</code>指定为xlarge。您也可以在<code>large</code>执行器上运行它，但是我发现资源的缺乏会导致构建时间变慢。我建议你自己做一些实验，为你的项目找到合适的执行者。</p>

<p>下一步更短；我们只需要<code>android/start-emulator-and-run-tests</code>命令。这个命令确实做到了它所说的:它启动指定的模拟器并运行测试。我们再次传入<code>test-command</code>作为参数(它使用了<code>android/run-tests</code>命令)。<code>system-image</code>是完全合格的Android模拟器系统映像。我们目前将我们的Android机器映像捆绑回SDK版本23。你可以使用<code>sdkmanager</code>工具安装更多。</p>

<pre><code class="language-yaml">jobs:
  android-test:
    executor:
      name: android/android-machine
      resource-class: xlarge
    steps:
      - checkout
      - android/start-emulator-and-run-tests:
          test-command: ./gradlew connectedDebugAndroidTest
          system-image: system-images;android-30;google_apis;x86
      ...
</code></pre>

<p>您可以使用Android orb中指定的命令手工编写所有模拟器设置步骤的代码:<code>create-avd</code>、<code>start-emulator</code>、<code>wait-for-emulator</code>和<code>run-tests</code>。</p>

<h3>存储测试结果</h3>

<p>测试不仅仅是运行测试，因为我们可以从CircleCI仪表板中准确地看到什么失败了，从而获得很多价值。为此，我们可以使用CircleCI平台内置的<code>store_test_results</code>函数，它将显示我们通过(或失败)的构建。</p>

<p>单元测试和仪器测试的步骤略有不同，因为它们各自的Gradle任务将测试存储在不同的位置。对于单元测试，测试将在<code>app/build/test-results</code>中进行，对于仪器测试，测试将在<code>app/build/outputs/androidTest-results</code>中进行。</p>

<p>我们建议您创建一个新的<code>Save test results</code>步骤，它使用<code>find</code>工具，将所有测试结果文件复制到一个公共位置——比如<code>test-results/junit</code>,然后从那里存储它。还要确保将<code>when: always</code>参数添加到步骤中，这样无论上面的测试是成功还是失败，该步骤都会运行。</p>

<h3>存储单元测试</h3>
<p>对于这个项目，我们希望基于XML的结果。调用<code>store_artifacts</code>使得这些结果可以在CircleCI平台上解析。如果您愿意，也可以存储HTML输出。</p>

<pre><code>...
- android/run-tests:
  test-command: ./gradlew testDebug
- run:
    name: Save test results
    command: |
        mkdir -p ~/test-results/junit/
        find . -type f -regex ".*/build/test-results/.*xml" -exec cp {} ~/test-results/junit/ \;
    when: always
- store_test_results:
    path: ~/test-results
- store_artifacts:
    path: ~/test-results/junit
</code></pre>

<h3>存储仪器测试</h3>
<p>不同测试类型有不同的regex命令。存储测试结果的其余步骤与单元测试示例相同。</p>

<pre><code>- android/start-emulator-and-run-tests:
        test-command: ./gradlew connectedDebugAndroidTest
        system-image: &lt;&lt; parameters.system-image &gt;&gt;
    - run:
        name: Save test results
        command: |
          mkdir -p ~/test-results/junit/
          find . -type f -regex ".*/build/outputs/androidTest-results/.*xml" -exec cp {} ~/test-results/junit/ \;
        when: always
    - store_test_results:
        path: ~/test-results
    - store_artifacts:
        path: ~/test-results/junit
</code></pre>

<h3>制作发布版本并存储工件</h3>

<p>对于这个项目，我们需要存储我们正在构建的应用程序。为了完成流程的这一部分，我们使用了<code>release-build</code>作业，它有两个需要注意的部分。一个<code>run</code>步骤调用<code>./gradlew assembleRelease</code>。然后，<code>store_artifacts</code>指向建成的APK所在的位置。对于一个完整CI/CD项目，您可以签署并上传APK到一个测试版发行服务。你甚至可以和浪子一起在Play Store上发布。但是，这两种活动都超出了本文的范围。</p>

<pre><code>jobs:
  ...
  release-build:
    executor:
      name: android/android-machine
      resource-class: xlarge
    steps:
      - checkout
      - android/restore-gradle-cache
      - android/restore-build-cache
      - run:
          name: Assemble release build
          command: |
            ./gradlew assembleRelease
      - store_artifacts:
          path: app/build/outputs/apk/release
</code></pre>

<h3>同时在多个Android版本上运行测试</h3>

<p>Android平台一直在发展，每个版本都有自己的缺陷和独特之处。我相信你已经遇到了其中的一些。避免不同版本Android之间不确定行为的一个好方法是尽可能多的测试它们。CircleCI作业矩阵功能使在多个版本上运行作业变得更加容易。</p>

<p>要使用职务矩阵，请向要在多个版本上测试的职务添加一个参数。我们的<code>android-test</code>作业使用<code>system-image</code>参数来完成这项工作。我们还为参数指定了一个默认值，因此您可以在没有它的情况下运行作业。</p>

<p>要使用该参数，通过将它放在成对的尖括号- <code>&lt;&lt; &gt;&gt;</code>中来指定需要它的值的位置:</p>

<pre><code> android-test:
    parameters: # this is a parameter
      system-image:
        type: string
        default: system-images;android-30;google_apis;x86
    executor:
      name: android/android-machine
      resource-class: xlarge
    steps:
      - checkout
      - android/start-emulator-and-run-tests:
          test-command: ./gradlew connectedDebugAndroidTest
          system-image: &lt;&lt; parameters.system-image &gt;&gt; # parameter being used
</code></pre>

<p>要将值传递给工作流中的参数，请使用我们正在调用的作业的<code>matrix</code>参数。</p>

<pre><code>workflows:
  jobs:
  ...
  - android-test:
      matrix:
        alias: android-test-all
        parameters:
          system-image:
            - system-images;android-30;google_apis;x86
            - system-images;android-29;google_apis;x86
            - system-images;android-28;google_apis;x86
            - system-images;android-27;google_apis;x86
            - system-images;android-26;google_apis;x86
            - system-images;android-26;google_apis;x86
            - system-images;android-26;google_apis;x86
            - system-images;android-26;google_apis;x86
      name: android-test-&lt;&lt;matrix.system-image&gt;&gt;

</code></pre>

<h3>通过缓存使每个运行更快</h3>

<p>除了构建我们的应用程序、安装依赖项和运行测试，我们通常还希望利用缓存。这让我们更少重复做任务。Android尤其是Gradle为此提供了一个极好的机制-<a href="https://docs.gradle.org/current/userguide/build_cache.html" target="_blank" rel="noreferrer noopener">Gradle构建缓存</a>。</p>

<p>这让您可以跳过应用程序的预构建部分。</p>

<h3>选择何时运行什么</h3>

<p>在开发期间，我们创建许多提交，应该鼓励开发人员尽可能频繁地将它们推送到远程存储库。但是，这些提交中的每一个都创建了一个新的CI/CD构建，我们可能不需要为一个提交在所有可能的设备上运行每个测试。另一方面，如果<code>main</code>分支是我们主要的事实来源，我们希望尽可能多的对它进行测试，以确保它总是如预期的那样工作。我们可能希望只在<code>main</code>上启动发布部署，而不是在任何其他分支上。</p>

<p>我们可以使用CircleCI的<code>requires</code>和<code>filters</code>节来定义适合我们流程的工作流。我们的<code>release-build</code>岗位<code>requires</code>那个<code>unit-test</code>岗位。这意味着<code>release-build</code>被放入队列中，直到所有的<code>unit-test</code>任务都已通过。只有这时<code>release-build</code>作业才会运行。</p>

<p>我们可以使用<code>filters</code>来设置逻辑规则，以便只在特定的分支或git标签上运行特定的作业。例如，我们的<code>main</code>分支有一个过滤器，它用一个完整的仿真器矩阵运行<code>android-test</code>。在另一个例子中，<code>release</code>构建只在<code>main</code>上触发，并且只有当它的两个必需的作业成功运行时才触发。</p>

<pre><code class="language-yaml">workflows:
  test-and-build:
    jobs:
      - unit-test
      - android-test: # Commits to any branch - skip matrix of devices
          filters:
            branches:
              ignore: main
      - android-test: # Commits to main branch only - run full matrix
          matrix:
            alias: android-test-all
            parameters:
              system-image:
                - system-images;android-30;google_apis;x86
                - system-images;android-29;google_apis;x86
                - system-images;android-28;google_apis;x86
                - system-images;android-27;google_apis;x86
                - system-images;android-26;google_apis;x86
                - system-images;android-25;google_apis;x86
                - system-images;android-24;google_apis;x86
                - system-images;android-23;google_apis;x86
          name: android-test-&lt;&lt;matrix.system-image&gt;&gt;
          filters:
            branches:
              only: main 
      - release-build:
          requires:
            - unit-test
            - android-test-all
          filters:
            branches:
              only: main # Commits to main branch
</code></pre>

<h2>改进您的Android应用CI流程</h2>

<p>我在本文中描述的步骤只是一个开始。有很多方法可以提高流量。以下是一些想法:</p>

<h3>构建一次，运行多次</h3>

<p>如果你是一个有经验的Android开发者，你会知道<code>connectedAndroidTest</code>总是从一开始就运行整个构建过程。使用CircleCI，我们可以一次构建整个应用程序和测试，将工件传递给后续作业，并简单地在模拟器上运行测试。这个过程可能会在每次作业运行时节省几分钟的构建时间。</p>

<p>为此，在每个模拟器运行中添加三个命令行步骤:安装应用程序、安装测量应用程序和运行测量测试。对于我们的应用程序，我们将输入:</p>

<pre><code>adb install app/build/outputs/apk/debug/app-debug.apk  
adb install app/build/outputs/apk/androidTest/debug/app-debug-androidTest.apk  
adb shell am instrument -w com.example.android.architecture.blueprints.reactive.test/androidx.test.runner.AndroidJUnitRunner 
</code></pre>

<p>确实，这段代码将输出发送到命令行。这不是Gradle提供的整洁的测试输出。如果你想让输出看起来更好，这个StackOverflow主题可能对你有帮助。</p>

<h3>在真实设备上运行</h3>

<p>仿真器是一种工具，但是真实世界的设备通常(可悲地)非常不同。没有什么可以取代真实世界的设备测试。为此，你可以使用在云中提供真实设备的解决方案，比如Sauce Labs或Firebase Test Lab。</p>

<h3>部署到beta测试人员，并发布应用程序</h3>

<p>这个构建和测试示例项目只是更广泛的CI/CD故事的一部分。您可以进一步发展您的CI/CD流程。例如，您可以将应用程序的新版本自动发布到Play Store。CircleCI有一些指南可以帮助你。本教程是一个很好的起点。浪子官方文件是另一个有用的资源。</p>

<h2>结论</h2>

<p>在本文中，我描述了用CircleCI构建一个Android应用程序，并对其进行测试。对于我们的示例项目，我们使用单元测试和Android平台模拟器矩阵，使用新的CircleCI Android orb和机器映像。我们还谈到了如何存储和显示测试结果，以及如何编排工作流来运行测试，这不会给我们提供Gradle提供的整洁的测试输出，所有输出都在一部分设备上。</p>

<p>如果你想让我探讨另一个Android主题，请告诉我，无论是在文章中还是在直播中。在<a href="https://twitter.com/zmarkan/"> Twitter - @zmarkan </a>上联系我。</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>
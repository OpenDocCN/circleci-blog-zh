<html>
<head>
<title>Building a Laravel API for CircleCI webhooks | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>为CircleCI webhooks | CircleCI构建Laravel API</h1>
<blockquote>原文：<a href="https://circleci.com/blog/building-a-laravel-api-for-circleci-webhooks/#2022-01-07T12:00:00-08:00">https://circleci.com/blog/building-a-laravel-api-for-circleci-webhooks/#2022-01-07T12:00:00-08:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>软件应用程序由相互连接的系统组成——每个系统都为满足业务需求的共同目标提供专门的服务。与任何网络一样，高效的数据交换机制是其功能性、有效性和响应性的关键。</p>

<p>过去，使用<i>轮询</i>请求来执行数据交换。每隔一段时间，系统就会请求获取最新的信息，或者了解是否有更新需要处理。这种技术被证明是低效的，因为大多数请求被返回，而没有新的信息来处理。如果有新的东西要处理，信息很可能是陈旧的，使应用程序无法实时响应。</p>

<p>这导致了一种新的交流形式:网页挂钩。如果预先约定的事件发生，则请求通知需要该信息的系统，允许该系统立即响应。使用webhooks的优点是系统开销较低，因为发出的请求较少。它还确保了数据的实时交换。CircleCI提供了<a href="/blog/create-customizable-experiences-with-circleci-webhooks/"> webhooks </a>，允许您实时接收关于您的管道的信息。这可以帮助您避免轮询API或手动检查CircleCI web应用程序中您需要的数据。</p>

<p>在本教程中，我将带领您构建一个Laravel API，它将被用作我们也将创建的CircleCI管道的webhook。</p>

<h2>先决条件</h2>

<p>为了从本教程中获得最大收益，您需要一些东西:</p>



<blockquote><p>我们的教程是平台无关的，但是使用CircleCI作为例子。如果你没有CircleCI账号，请在 注册一个免费的<a href="https://circleci.com/signup/"> <strong>。</strong></a></p></blockquote>

<h2>CircleCI webhooks的用例</h2>

<p>如果您仍然想知道如何使用CircleCI webhooks，而不管您选择哪种编程语言，这里有一些用例:</p>

<ul>
  <li>聚合来自单个或多个项目的事件，并将数据发送到Slack等通信渠道</li>
  <li>当工作流/作业被取消或完成时，自动向开发团队发送通知。</li>
  <li>通过自定义控制面板可视化和分析工作流/作业事件。</li>
  <li>向数据记录和事故管理工具发送有价值的数据</li>
</ul>

<h2>入门指南</h2>

<p>创建一个新项目开始。</p>

<pre><code>laravel new circle_ci_webhook_api

cd circle_ci_webhook_api
</code></pre>

<p>现在，要设置webhook，您需要创建一个基本的CircleCI配置，并为CI管道设置一个GitHub存储库。在项目的根目录下，创建一个名为<code>.circleci</code>的新文件夹。在<code>.circleci</code>文件夹中，创建一个名为<code>config.yml</code>的新文件。将此添加到文件中:</p>

<pre><code>version: 2
jobs:
  build:
    docker:
      - image: cimg/php:8.0-browsers

    steps:
      - checkout

      - run:
          name: "Prepare Environment"
          command: |
            sudo apt update

      # Download and cache dependencies
      - restore_cache:
          keys:
            # "composer.lock" can be used if it is committed to the repo
            - v1-dependencies-{{ checksum "composer.json" }}
            # fallback to using the latest cache if no exact match is found
            - v1-dependencies-

      - run:
          name: "Install Dependencies"
          command: composer install -n --prefer-dist

      - save_cache:
          key: v1-dependencies-{{ checksum "composer.json" }}
          paths:
            - ./vendor
</code></pre>

<p>下一步是创建控制器。这个控制器将用于处理来自CircleCI的请求，并根据保存到数据库中的内容检索请求的历史记录。要创建一个控制器，运行这个<code>artisan</code>命令:</p>

<pre><code>php artisan make:controller CircleCIController
</code></pre>

<p>在新创建的<code>app/Http/Controllers/CircleCIController.php</code>文件中，添加以下内容:</p>

<pre><code>&lt;?php

namespace App\Http\Controllers;

use App\Models\WebhookNotification;
use Illuminate\Http\{JsonResponse, Response};

class CircleCIController extends Controller {

    public function getAllNotifications()
    : JsonResponse {

        return response()-&gt;json();
    }

    public function handleNotification()
    : JsonResponse {

        return response()
            -&gt;json(null, Response::HTTP_NO_CONTENT);
    }

}
</code></pre>

<p>这段代码片段声明了两个函数。目前，它们只分别返回状态为<code>200</code>和<code>204</code>的JSON响应。</p>

<p>接下来，为您的API添加两条路由。打开<code>routes/api.php</code>并添加以下内容:</p>

<pre><code>Route::post('circleci', [CircleCIController::class, 'handleNotification']);
Route::get('circleci', [CircleCIController::class, 'getAllNotifications']);
</code></pre>

<p>第一条路线是webhook路线。它将处理来自CircleCI的<strong> POST </strong>请求。第二条路径将用于获取CircleCI发送给webhook的通知。因为这些航线已经被注册为API航线，所以完整的URIs航线将被加上<code>api</code> : <code>api/circleci</code>。</p>

<p>导入<code>CircleCIController</code>:</p>

<pre><code>use App\Http\Controllers\CircleCIController;
</code></pre>

<p>现在，您已经准备好为您的应用程序服务了。使用以下命令运行应用程序:</p>

<pre><code>php artisan serve
</code></pre>

<h2>设置ngrok</h2>

<p>出于开发目的，我们需要一种方式将本地应用程序作为webhook公开给CircleCI。我们可以使用<a href="https://ngrok.com/" target="_blank" rel="noreferrer noopener"> ngrok </a>向互联网公开我们正在运行的Laravel应用程序。</p>

<p>下载<a href="https://ngrok.com/download" target="_blank" rel="noreferrer noopener"> ngrok可执行文件</a>并解压。要在您的本地机器上公开一个端口，使用<code>ngrok http</code>命令，指定您想要公开的端口号。我们的Laravel应用程序将在端口8000上运行，因此使用以下命令:</p>

<pre><code>ngrok http 8000
</code></pre>

<p>当您启动ngrok时，它将在您的终端中显示一个UI，其中包含您的隧道的公共URL以及有关通过您的隧道建立的连接的其他状态和度量信息。</p>

<p><img src="../Images/51d034705c7dbe01ecf8dd3a7a63cca6.png" alt="ngrok Running" srcset="https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=449 449w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=898 898w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1347 1347w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=779 779w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1558 1558w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2337 2337w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=750 750w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1500 1500w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2250 2250w" sizes="(min-width: 1200px) 750px,&#10;(min-width: 992px) 779px,&#10;(min-width: 768px) 720px,&#10;(min-width: 480px) 720px,&#10;(min-width: 0px) 449px" data-full-size-src="https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-running.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;fm=jpg" data-original-src="https://circleci.com/blog/media/2022-01-07-ngrok-running.png"/></p>

<h2>设置CircleCI管道</h2>

<p>接下来，在GitHub上建立一个存储库，并将项目链接到CircleCI。参考这篇文章来获得帮助<a href="https://circleci.com/blog/pushing-a-project-to-github/">把你的项目推到GitHub </a>。</p>

<p>登录您的CircleCI帐户。如果你注册了你的GitHub账户，你所有的库都会显示在你项目的仪表盘上。</p>

<p>在您的<code>circle_ci_webhook_api</code>项目旁边，点击<strong>设置项目</strong>。</p>

<p>CircleCI将检测项目中的<code>config.yml</code>文件。点击<strong>使用现有配置</strong>，然后点击<strong>开始建造</strong>。您的第一个构建过程将开始运行并成功完成。</p>

<h2>为项目配置webook</h2>

<p>在<code>circle_ci_webhook_api</code>项目的CircleCI仪表盘上，点击<strong>项目设置</strong>。在工具条中，点击<strong>网页挂钩</strong>，然后点击<strong>添加网页挂钩</strong>。填写表格。</p>

<p><img src="../Images/2120b4d0dbd2d85154dcb32d9f0f5885.png" alt="Configure Webhook" srcset="https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=449 449w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=898 898w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1347 1347w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=779 779w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1558 1558w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2337 2337w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=750 750w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1500 1500w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2250 2250w" sizes="(min-width: 1200px) 750px,&#10;(min-width: 992px) 779px,&#10;(min-width: 768px) 720px,&#10;(min-width: 480px) 720px,&#10;(min-width: 0px) 449px" data-full-size-src="https://production-cci-com.imgix.net/blog/media/2022-01-07-configure-webhook.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;fm=jpg" data-original-src="https://circleci.com/blog/media/2022-01-07-configure-webhook.png"/></p>

<p>在<strong>接收者URL </strong>字段中指定ngrok给出的公共URL。添加一个秘密令牌来验证对webhook的传入请求，并确保只接受来自CircleCI的请求。记下这个秘密令牌，因为您将使用它来验证对接收方URL的传入请求。</p>

<p>点击<strong>添加网页挂钩</strong>保存网页挂钩的详细信息。当一个工作流或作业完成时，一个POST请求将被发送到我们的Laravel应用程序的<code>api/circleci</code>路径。</p>

<h2>设置环境变量</h2>

<p>对于本教程，我们将使用MySQL来管理我们的数据库。在<code>.env</code>文件中，用以下内容更新数据库相关参数:</p>

<pre><code>DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=circle_ci_webhook_api
DB_USERNAME=YOUR_DATABASE_USERNAME
DB_PASSWORD=YOUR_DATABASE_PASSWORD
</code></pre>

<p>使用您喜欢的数据库管理应用程序，创建一个名为<code>circle_ci_webhook_api</code>的新数据库。</p>

<p>您还需要一个环境变量来保存webhook secret令牌。在<code>.env</code>文件中包含以下内容。</p>

<pre><code>CIRCLE_CI_WEBHOOK_SECRET="YOUR_CIRCLE_CI_WEBHOOK_SECRET"
</code></pre>

<h2>创建<code>WebhookNotification</code>模型</h2>

<p>在我们的应用程序中，我们需要一个模型来表示webhook收到的通知的细节。给这个型号取名<code>WebhookNotification</code>。它将包含以下字段:</p>

<ul>
  <li><code>id</code>是数据库中的主键。</li>
  <li><code>notification_id</code>是webhook提供的id，用于唯一标识来自CircleCI的每个通知。</li>
  <li><code>type</code>值为<code>workflow-completed</code>或<code>job-completed</code>。</li>
  <li><code>happened_at</code>是代表事件发生时间的ISO 8601时间戳。</li>
  <li><code>has_vcs_info</code>让您知道通知是否有一个<a href="https://circleci.com/docs/webhooks/#vcs">版本控制</a>映射，用于访问与触发事件的git提交相关的元数据。</li>
  <li>如果通知具有版本控制映射，则代表提交的主题。否则，该值为空。</li>
  <li><code>commit_author</code>代表提交的作者。如果<code>has_vcs_info</code>为假，则该值可以为空。</li>
  <li><code>event_status</code>对应于工作流或作业到达终止状态时的状态。这些值可以是<code>success</code>、<code>failed</code>、<code>error</code>、<code>canceled</code>或<code>unauthorized</code>。</li>
  <li><code>workflow_url</code>包含CircleCI仪表板上工作流程或作业的URL。</li>
</ul>

<p>使用以下命令创建模型:</p>

<pre><code>php artisan make:model WebhookNotification -m
</code></pre>

<p>在新创建的<code>database/migrations/*YYYY_MM_DD_HHMMSS*_create_webhook_notifications_table.php</code>中，更新<code>up</code>函数以匹配该代码块:</p>

<pre><code>public function up() {

        Schema::create('webhook_notifications', function (Blueprint $table) {

            $table-&gt;id();
            $table-&gt;string('notification_id');
            $table-&gt;string('type');
            $table-&gt;string('happened_at');
            $table-&gt;boolean('has_vcs_info');
            $table-&gt;string('commit_subject')-&gt;nullable();
            $table-&gt;string('commit_author')-&gt;nullable();
            $table-&gt;string('event_status');
            $table-&gt;text('workflow_url');
            $table-&gt;timestamps();
        });
    }
</code></pre>

<p>接下来，打开<code>WebhookNotification</code>模型文件:<code>app/Models/WebhookNotification.php</code>。使用以下代码更新它以添加字段作为<code>$fillable</code>属性:</p>

<pre><code>&lt;?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class WebhookNotification extends Model
{
    use HasFactory;

    protected $fillable = [
        'notification_id', 'type', 'happened_at', 'has_vcs_info', 'commit_subject','commit_author',
        'event_status','workflow_url'
    ];
}
</code></pre>

<p>运行迁移来创建<code>webhook_notifications</code>表及其列。</p>

<pre><code>php artisan migrate
</code></pre>

<h2>创建一个助手类来管理CircleCI请求</h2>

<p>为了分离关注点并使我们的控制器更精简，您可以创建一个助手类。helper类验证传入的请求，并解析请求中用于填充<code>WebhookNotification</code>模型的信息。</p>

<p>在项目的<code>app</code>文件夹中，创建一个名为<code>Helpers</code>的新文件夹。在那个文件夹中，创建一个名为<code>CircleCINotificationHelper.php</code>的新文件。用以下代码更新该文件的内容:</p>

<pre><code>&lt;?php

namespace App\Helpers;

use App\Models\WebhookNotification;
use Illuminate\Http\{Request, Response};

class CircleCINotificationHelper {

    public static function handle(Request $request)
    : void {

        $circleCISignature = $request-&gt;headers-&gt;get('circleci-signature');

        self::validate($circleCISignature, $request-&gt;getContent());
        $requestContent = $request-&gt;toArray();
        $hasVCSInfo = isset($requestContent['pipeline']['vcs']);

        $notificationType = $requestContent['type'];

        $notificationDetails = [
            'notification_id' =&gt; $requestContent['id'],
            'type'            =&gt; $notificationType,
            'happened_at'     =&gt; $requestContent['happened_at'],
            'workflow_url'    =&gt; $requestContent['workflow']['url'],
            'has_vcs_info'    =&gt; $hasVCSInfo,
        ];

        if ($hasVCSInfo) {
            $commitDetails = $requestContent['pipeline']['vcs']['commit'];
            $notificationDetails['commit_subject'] = $commitDetails['subject'];
            $notificationDetails['commit_author'] = $commitDetails['author']['name'];
        }

        $notificationDetails['event_status'] = $notificationType === 'job-completed' ?
            $requestContent['job']['status'] :
            $requestContent['workflow']['status'];

        $webhookNotification = new WebhookNotification($notificationDetails);

        $webhookNotification-&gt;save();
    }

    private static function validate(string $signature, string $requestContent)
    : void {

        $receivedSignature = explode('=', $signature)[1];

        $generatedSignature = hash_hmac(
            'sha256',
            $requestContent,
            env('CIRCLE_CI_WEBHOOK_SECRET')
        );

        abort_if(
            $receivedSignature !== $generatedSignature,
            Response::HTTP_UNAUTHORIZED,
            'Invalid Signature Provided'
        );
    }
}
</code></pre>

<p><code>CircleCINotificationHelper</code>只有一个名为<code>handle</code>的公共方法，它接受一个<code>Request</code>对象。</p>

<p>在解析请求的内容之前，首先使用<code>validate</code>函数进行验证检查。这确保了只处理来自CircleCI的请求。为了验证请求，使用配置的签名秘密作为秘密密钥，将<code>circleci-signature</code>头与请求体的HMAC-SHA256摘要进行比较。如果这些值不匹配，该过程被中止，并返回一个<code>401</code>响应。你可以在这里阅读更多关于Webhook有效载荷签名<a href="https://circleci.com/docs/webhooks/#payload-signature">的信息。</a></p>

<p>如果请求签名通过检验，<code>handle</code>方法检索<code>WebhookNotification</code>模型的值，创建一个，并保存到数据库。</p>

<h2>向CircleCIController添加功能</h2>

<p>有了模型和助手，我们就可以在CircleCIController中向前面定义的函数添加功能。打开<code>app/Http/Controllers/CircleCIController.php</code>并将其更新为与此匹配:</p>

<pre><code>&lt;?php

namespace App\Http\Controllers;

use App\Helpers\CircleCINotificationHelper;
use App\Models\WebhookNotification;
use Illuminate\Http\{JsonResponse, Request, Response};

class CircleCIController extends Controller {

    public function getAllNotifications()
    : JsonResponse {

        return response()-&gt;json(WebhookNotification::all());
    }

    public function handleNotification(Request $request)
    : JsonResponse {

        CircleCINotificationHelper::handle($request);

        return response()
            -&gt;json(null, Response::HTTP_NO_CONTENT);
    }

}
</code></pre>

<p>现在已经完成了这些更改，您可以通过提交和推送您的更改到GitHub存储库来触发一个新的事件。</p>

<pre><code>git add .

git commit -m 'Implement Webhook for CircleCI'

git push origin main
</code></pre>

<p>这将触发一个构建过程。当这个过程完成时，一个请求被发送到我们指定的ngrok公共URL。使用ngrok创建的隧道，应用程序接收请求并将通知保存到数据库。您可以在ngrok终端中查看<code>HTTP Requests</code>部分。</p>

<p><img src="../Images/84f0f35283e4c8515fc14229028ae831.png" alt="ngrok build process" srcset="https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=449 449w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=898 898w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1347 1347w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=779 779w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1558 1558w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2337 2337w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=750 750w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1500 1500w,&#10;https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2250 2250w" sizes="(min-width: 1200px) 750px,&#10;(min-width: 992px) 779px,&#10;(min-width: 768px) 720px,&#10;(min-width: 480px) 720px,&#10;(min-width: 0px) 449px" data-full-size-src="https://production-cci-com.imgix.net/blog/media/2022-01-07-ngrok-build-process.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;fm=jpg" data-original-src="https://circleci.com/blog/media/2022-01-07-ngrok-build-process.png"/></p>

<h2>结论</h2>

<p>在本教程中，我们设置了一个Laravel API来与CircleCI webhook通信。虽然我们只是将数据保存到数据库中以供将来可视化/分析，但webhooks为许多依赖于实时数据的操作打开了大门，例如事件检测和响应/管理。与您的团队分享本教程，使用您自己的项目扩展您所学到的内容。</p>

<p>这篇文章的代码可以在<a href="https://github.com/yemiwebby/circle_ci_webhook" target="_blank" rel="noreferrer noopener"> GitHub </a>上找到，CircleCI webhooks的完整文档可以在<a href="https://circleci.com/docs/webhooks/">这里</a>找到。</p>

<p>尽情享受吧！</p>

<hr/>

<p><a href="https://twitter.com/yemiwebby" target="_blank" rel="noreferrer noopener"> Oluyemi </a>是一名拥有电信工程背景的技术爱好者。出于对解决用户日常遇到的问题的浓厚兴趣，他冒险进入编程领域，并从那时起将他解决问题的技能用于构建web和移动软件。Oluyemi是一名热衷于分享知识的全栈软件工程师，他在世界各地的几个博客上发表了大量技术文章和博客文章。由于精通技术，他的爱好包括尝试新的编程语言和框架。</p>


        
          
          
            <hr/>
            <p>Oluyemi是一名拥有电信工程背景的技术爱好者。出于对解决用户日常遇到的问题的浓厚兴趣，他冒险进入编程领域，并从那时起将他的问题解决技能用于构建web和移动软件。Oluyemi是一名热衷于分享知识的全栈软件工程师，他在世界各地的几个博客上发表了大量技术文章和博客文章。作为技术专家，他的爱好包括尝试新的编程语言和框架。</p>

            <p><a href="/blog/author/olususi-oluyemi/" class="arrow-link">阅读更多Olususi Oluyemi的帖子</a></p>
          
        
      </div>
    </div>    
</body>
</html>
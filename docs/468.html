<html>
<head>
<title>Managing reusable pipeline configuration with object parameters | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用对象参数| CircleCI管理可重用管道配置</h1>
<blockquote>原文：<a href="https://circleci.com/blog/parameters-in-pipeline-config/#2021-10-08T09:00:00-07:00">https://circleci.com/blog/parameters-in-pipeline-config/#2021-10-08T09:00:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>CircleCI管道是使用<a href="https://circleci.com/docs/writing-yaml/"> YAML语法</a>定义的，它已经被许多软件工具和解决方案广泛采用。YAML是一种人类可读的声明性<a href="https://en.wikipedia.org/wiki/Data_structure">数据结构</a>，用于<a href="https://circleci.com/docs/config-intro/#getting-started-with-circleci-config">配置文件</a>(类似于CircleCI管道的配置文件)以及存储或传输数据的应用程序中。管道配置文件中的数据指定并控制工作流和作业在平台上触发时的执行方式。配置文件中的这些管道指令往往会变得重复，这可能会导致配置语法量增加。随着时间的推移，这种数量的增加使得配置更难维护。因为YAML是一种数据结构，所以只有最低限度的语法可重用性能力(<a href="https://yaml.org/spec/1.2/spec.html#id2765878">锚和别名</a>)可用于处理增加的数量。锚和别名太有限，不能用于定义CI/CD管道。幸运的是，CircleCI配置<a href="https://circleci.com/docs/pipeline-variables/#pipeline-parameters-in-configuration">参数特性</a>为封装和重用冗余的功能数据提供了强大的功能。</p>

<p>在这篇文章中，我将介绍管道<a href="https://circleci.com/docs/pipeline-variables/#pipeline-parameters-in-configuration">配置参数</a>，并解释在您的管道配置中采用它们的一些好处。</p>

<h2>什么是配置参数？</h2>

<p><a href="https://circleci.com/docs/configuration-reference/#executors-requires-version-21">执行者</a>、<a href="https://circleci.com/docs/configuration-reference/#jobs">作业</a>和<a href="https://circleci.com/docs/configuration-reference/#commands-requires-version-21">命令</a>被认为是流水线配置文件中的对象。像<a href="https://en.wikipedia.org/wiki/Object-oriented_programming">面向对象编程(OOP) </a>范例中的对象一样，管道对象可以被扩展以提供定制的功能。CircleCI配置<a href="https://circleci.com/docs/pipeline-variables/#pipeline-parameters-in-configuration">参数</a>通过提供创建、封装和重用管道配置语法的方法，让开发人员扩展执行器、作业和命令的功能。</p>

<p>执行器、作业和命令是具有各自属性的对象。参数也有自己独特的属性，可以与对象交互。参数的组成和属性包括:</p>

<pre><code>parameters:
  |_ parameter name: (Specify a name the parameter)
    |_ description: (Optional. Describes the parameter)
    |_ type: (Required. datatype string, boolean, integer, enum)
    |_ default: (The default value for the parameter)
</code></pre>

<h2>何时应该在管道配置中使用参数？</h2>

<p>当数据和功能在管道中重复时，使用参数。换句话说，如果您的管道中有任何执行器、作业或命令在您的管道中被多次定义或执行，我建议识别这些模式或元素，并在您的配置文件语法中将它们定义为参数。使用参数使您能够集中管理和维护功能，并极大地减少配置文件中的冗余数据和语法行数。提供可变参数的能力也是一个好处，管道语法的整体可读性也得到了提高。</p>

<h2>如何创建参数？</h2>

<p>如前所述，<a href="https://circleci.com/docs/configuration-reference/#executors-requires-version-21">执行者</a>、<a href="https://circleci.com/docs/configuration-reference/#jobs">作业</a>、<a href="https://circleci.com/docs/configuration-reference/#commands-requires-version-21">命令</a>是可以用参数扩展的配置元素。决定扩展这些元素中的哪一个将取决于您的特定用例。</p>

<p><strong>注意:</strong> <i>参数功能仅在CircleCI及以上版本中可用。必须在配置文件的顶部定义版本，如下所示:</i> <code>version: 2.1</code> <i>，以便平台识别参数。</i></p>

<p>让我给你举一个在<code>jobs:</code>对象中为<a href="https://circleci.com/docs/configuration-reference/#parallelism">并行度</a>量定义参数的例子:</p>

<pre><code>version: 2.1
jobs:
  build_artifact:
    parameters:
      parallelism_qty:
        type: integer
        default: 1
    parallelism: &lt;&lt; parameters.parallelism_qty &gt;&gt;
    machine: true
    steps:
      - checkout
workflows:
  build_workflow:
    jobs:
      - build_artifact:
          parallelism_qty: 2
</code></pre>

<p>在这个例子中，<code>build-artifact:</code>作业有一个用名称<code>parallelism_qty:</code>定义的<code>parameters:</code>键。此参数的数据类型为整数，默认值为1。<a href="https://circleci.com/docs/configuration-reference/#parallelism"> parallelism: </a>键是<code>jobs:</code>对象的一个属性，它定义了在<code>steps:</code>列表中产生和执行命令的执行器数量。在这种情况下，特殊的<code>checkout</code>命令将在所有产生的执行器上执行。作业的<code>parallelism:</code>键已被赋予值` parameters . parallelism _ qty<code>, which references the </code>parallelism _ qty:上面定义的参数定义。此示例显示了参数如何为管道构造增加灵活性，并提供了一种方便的方式来集中管理管道语法中重复出现的功能。</p>

<h2>在作业对象中使用参数</h2>

<p>使用前面的例子，工作流块中的<code>parallelism_qty:</code>参数演示了如何在配置语法中使用参数。因为<code>parallelism_qty:</code>是在作业对象中定义的，所以它可以作为工作流中指定的作业来执行。</p>

<p><code>workflows:</code>块有一个指定了<code>build_artifact:</code>的<code>jobs:</code>列表。它还为<code>parallelism_qty:</code>赋值2个执行器，这将产生2个执行器并执行<code>steps:</code>列表中的命令。如果该值为3，那么build_artifact作业将产生3个执行器，并运行命令3次。</p>

<div class="pull-quote">
  <blockquote>执行器、作业和命令是具有属性的对象，可以通过管道配置语法进行定义、自定义和重用。</blockquote>
</div>

<h2>在管道配置中重用执行器对象</h2>

<p>上一节演示了如何在jobs对象中定义和使用参数。在这一节中，我将描述如何在执行器中使用参数。执行器定义用于执行管道作业和命令的运行时或环境。执行器对象有一组它们自己的独特属性，参数可以与之交互。这是一个定义和实现<a href="https://circleci.com/docs/reusing-config/#authoring-reusable-executors">可重用执行器</a>的例子:</p>

<pre><code>version: 2.1
executors:
  docker-executor:
    docker:
      - image: cimg/ruby:3.0.2-browsers
   ubuntu_20-04-executor:
    machine:
      image: 'ubuntu-2004:202010-01'
jobs:
  run-tests-on-docker:
    executor: docker-executor
    steps:
      - checkout
      - run: ruby unit_test.rb 
  run-tests-on-ubuntu-2004:
    executor: ubuntu_20-04
    steps:
      - checkout
      - run: ruby unit_test.rb 
workflows:
  test-app-on-diff-os:
    jobs:
      - run-tests-on-docker
      - run-tests-on-ubuntu-2004
</code></pre>

<p>这个例子展示了如何在你的管道配置中定义和实现可重用的执行器。我在文件开头使用了<code>executors:</code>键来定义2个执行者，一个名为<code>docker-executor:</code>，一个名为<code>ubuntu_20-04-executor:</code>。第一个指定使用Docker执行器，第二个指定使用Ubuntu 20.04操作系统映像的机器执行器。通过这种方式预定义执行器，开发人员可以创建一个要在管道中使用的执行器资源列表，并集中管理与执行器类型相关的各种属性。例如，<a href="https://circleci.com/docs/reusing-config/#authoring-reusable-executors">码头执行器</a>具有不属于<a href="https://circleci.com/docs/configuration-reference/#machine">机器执行器</a>且不可用的属性，因为机器执行器不属于<code>docker</code>类型。</p>

<div class="pull-quote">
  <blockquote>重用对象将语法量保持在最低限度，同时提供简洁的对象实现，优化代码可读性和功能的集中管理。</blockquote>
</div>

<p><code>jobs:</code>块定义了<code>run-tests-on-docker:</code>和<code>run-tests-on-ubuntu-2004:</code>；两者都有一个指定了值的<code>executor:</code>键，作为该作业的适当执行者。<code>run-tests-on-docker:</code>作业使用<code>docker-executor</code>定义执行其步骤，而<code>run-tests-on-ubuntu-2004:</code>作业根据<code>ubuntu_20-04</code>定义执行。正如您所看到的，在它们自己的节中预定义这些执行器使得config语法更容易阅读，这将使它更容易使用和维护。对执行器的任何更改都可以在各自的定义中进行，并将传播到实现它们的任何作业。这种对定义的执行器的集中管理也可以应用于以类似方式定义的作业和命令对象。</p>

<p>在<code>workflows:</code>块中，<code>test-app-on-diff-os:</code>工作流并行触发两个作业，这两个作业在各自的执行器环境中执行单元测试。当您想了解应用程序在不同操作系统中的行为时，使用不同的执行器运行这些测试是很有帮助的。这种测试是常见的做法。这里的要点是，我只定义了一次执行者，并在多个作业中轻松地实现了它们。</p>

<h2>可重复使用的命令对象</h2>

<p>命令也可以在配置语法中定义和实现，就像执行器和作业一样。尽管命令对象属性不同于执行器和作业，但是它们的定义和实现是相似的。以下是显示可重复使用的命令的示例:</p>

<pre><code>version: 2.1

commands:
  install-wget:
    description: "Install the wget client"
    parameters:
      version:
        type: string
        default: "1.20.3-1ubuntu1"
    steps:
      - run: sudo apt install -y wget=&lt;&lt; parameters.version &gt;&gt;
jobs:
  test-web-site:
    docker:
      - image: "cimg/base:stable"
        auth:
          username: $DOCKERHUB_USER
          password: $DOCKERHUB_PASSWORD
    steps:
      - checkout
      - install-wget:
          version: "1.17.0-1ubuntu1"
      - run: wget --spider https://www.circleci.com
workflows:
  run-tests:
    jobs:
      - test-web-site
</code></pre>

<p>在这个例子中，一个可重用的命令已经由一个作业定义和实现。配置顶部的<code>command:</code>键定义了一个名为<code>install-wget:</code>的命令，该命令安装特定版本的wget客户端。在这种情况下，定义一个参数来指定要安装哪个wget版本号。如果没有指定值，<code>default:</code>键安装<code>1.20.3-1ubuntu1</code>的默认值。<code>steps:</code>键列出了1个<code>run:</code>命令，用于安装在<code>versions:</code>参数中指定的wget版本。<code>versions:</code>参数被<code>&lt;&lt; parameters.version &gt;&gt;</code>变量引用。</p>

<p>如示例所示，作业对象可以实现和使用定义的命令。<code>test-web-site:</code>作业中的步骤节实现了<code>- install-wget:</code>命令。它的<code>version:</code>参数被设置为wget的早期版本，而不是默认的版本值。作业中的最后一个<code>run:</code>命令使用wget测试来自给定URL的响应。这个例子运行一个简单的测试来检查一个网站是否响应请求。</p>

<p>像往常一样，<code>workflows:</code>块触发<code>- test-web-site</code>作业，该作业执行可重用的<code>install-wget</code>命令。就像执行器和作业一样，命令带来了重用代码、集中管理更改以及提高管道配置文件中语法可读性的能力。</p>

<h2>结论</h2>

<p>在这篇文章中，我描述了使用管道参数和可重用管道对象的基础:执行器、作业和命令。关键要点:</p>
<ul>
  <li>执行器、作业和命令被视为具有属性的对象，可以在整个管道配置语法中进行定义、自定义和重用</li>
  <li>重用这些对象有助于保持最少的语法量，同时提供简洁的对象实现，优化代码可读性和功能的集中管理</li>
</ul>

<p>虽然我写这篇文章是为了向您介绍参数和可重用对象的概念，但我还是想鼓励您阅读一下<a href="https://circleci.com/docs/reusing-config/">可重用配置参考指南</a>。它将帮助您更深入地了解这些功能，以便您能够充分利用这些出色的功能。</p>

<p>我很想知道你的想法和观点，所以请发推特给我<a href="https://twitter.com/punkdata"> @punkdata </a>加入讨论。</p>

<p>感谢阅读！</p>



        
          
          
        
      </div>
    </div>    
</body>
</html>
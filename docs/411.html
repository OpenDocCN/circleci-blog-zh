<html>
<head>
<title>Infrastructure as Code, part 3: automate Kubernetes deployments with CI/CD and Terraform | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>基础设施即代码，第3部分:使用CI/CD和Terraform | CircleCI自动化Kubernetes部署</h1>
<blockquote>原文：<a href="https://circleci.com/blog/learn-iac-part3/#2021-11-11T09:00:00-08:00">https://circleci.com/blog/learn-iac-part3/#2021-11-11T09:00:00-08:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>本系列向您展示如何开始使用基础设施即代码(IaC)。目标是通过教程和代码示例帮助开发人员加深对IaC的理解。</p>



<p>在这篇文章中，我将演示如何创建<a href="https://circleci.com/continuous-integration/">持续集成和部署(CI/CD) </a>管道，这些管道自动化了本系列的<a href="https://circleci.com/blog/learn-iac-part1/">第1部分</a>和<a href="https://circleci.com/blog/learn-iac-part02/">第2部分</a>中涉及的<a href="https://www.terraform.io/">地形</a> IaC部署。下面是我们将在这篇文章中完成的事情的快速列表:</p>

<ol>
  <li>为项目构建一个新的<a href="https://circleci.com/docs/configuration-reference/"> CircleCI .config.yml文件</a></li>
  <li>配置新的<a href="https://circleci.com/docs/configuration-reference/#jobs">作业</a>和<a href="https://circleci.com/docs/configuration-reference/#workflows">工作流</a></li>
  <li>自动执行Terraform代码以创建<a href="https://cloud.google.com/kubernetes-engine"> Google Kubernetes引擎(GKE)集群</a>并部署应用程序</li>
</ol>

<p><strong>注意:</strong> <i>在你开始学习这部分教程之前，确保你已经完成了第1部分的<a href="https://circleci.com/blog/learn-iac-part1/">先决条件部分中的所有操作。</a></i></p>

<p>我们将从快速解释什么是CI/CD开始，并回顾本系列教程的前两部分。然后你就可以开始了解<a href="https://github.com/datapunkz/learn_iac">这个代码报告中包含的<a href="https://circleci.com/docs/configuration-reference/"> CircleCI .config.yml文件</a>。</a></p>

<h2>持续集成和持续部署</h2>

<p>CI/CD管道帮助开发人员和团队自动化他们的构建和测试过程。CI/CD创建了有价值的反馈循环，提供了软件开发过程的接近实时的状态。CI/CD自动化还提供了一致的流程执行和准确的结果。这有助于优化这些流程，并有助于提高速度。用CI/CD简化开发实践正在成为团队中的普遍实践。理解如何集成和自动化重复的任务对于构建有价值的CI/CD管道至关重要。</p>

<p>在<a href="https://circleci.com/blog/learn-iac-part1/">第1部分</a>和<a href="https://circleci.com/blog/learn-iac-part02/">第2部分</a>中，我们使用<a href="https://www.terraform.io/"> Terraform </a>创建了一个新的GKE集群和相关的Kubernetes对象，用于部署、执行和服务应用程序。这些地形命令是从我们的终端手动执行的。这在你开发Terraform代码或者修改它的时候很有效，但是我们希望自动执行这些命令。有许多方法可以使它们自动化，但是我们将把重点放在如何从CI/CD管道中完成。</p>

<h2>什么是CircleCI管道？</h2>

<p><a href="https://circleci.com/docs/concepts/#pipelines"> CircleCI pipelines </a>是在您启动项目工作时运行的全套流程。管道包含您的工作流程，进而协调您的工作。这都是在项目配置文件中定义的。在本教程的下一节中，我们将定义一个CI/CD管道来构建我们的项目。</p>

<h3>在CircleCI建立项目</h3>

<p>在我们开始为这个项目构建一个<code>config.yml</code>文件之前，我们需要将这个项目添加到CircleCI中。如果你不熟悉这个过程，你可以在这里使用<a href="https://circleci.com/docs/getting-started/#setting-up-circleci">设置CircleCI指南。一旦您完成了<strong>设置CircleCI </strong>部分，就此停止，以便我们可以配置</a><a href="https://circleci.com/docs/env-vars/#setting-an-environment-variable-in-a-project">项目级环境变量</a>。</p>

<h3>项目级环境变量</h3>

<p>此管道中的某些作业将需要访问身份验证凭据，以便在目标服务上执行命令。在本节中，我们将定义一些作业所需的凭证，并演示如何将它们作为项目级环境变量输入到CircleCI中。对于每个变量，在<strong>名称</strong>字段中输入<code>EnVar Name: </code>值，在<strong>值</strong>字段中输入凭证。以下是我们的管道将需要的凭证及其值的列表:</p>



<p>一旦上面所有的环境变量都就位，我们就可以开始在<code>config.yml file</code>中构建我们的管道。</p>

<h3>CircleCI config.yml</h3>

<p><a href="https://circleci.com/docs/configuration-reference/"> config.yml </a>文件是您定义要处理和执行的CI/CD相关作业的地方。在本节中，我们将为我们的管道定义作业和工作流。</p>

<p>在编辑器中打开<code>.circleci/.config.yml</code>文件，删除其内容并粘贴以下代码:</p>

<pre><code>version: 2.1
jobs:
</code></pre>

<p><code>version:</code>键指定运行该管道时要使用的平台特性。<code>jobs:</code>键代表我们将为该管道定义的单个<a href="https://circleci.com/docs/configuration-reference/#jobs">作业</a>的列表。接下来，我们将创建管道将要执行的作业。</p>

<h3>作业运行测试:</h3>

<p>我鼓励您熟悉本<a href="https://circleci.com/docs/configuration-reference/"> CircleCI参考文档</a>中的特殊按键、功能和特性，这将有助于您获得平台经验。下面是我们将要讨论的工作中每个关键点的概述和解释。</p>

<ul>
  <li><a href="https://circleci.com/docs/jobs-steps/#steps-overview"> <strong> docker: </strong> </a>是一个键，代表我们的作业将要执行的运行时<ul>
      <li><a href="https://circleci.com/docs/jobs-steps/#steps-overview"> <strong>图像:</strong> </a>是一个键，表示Docker容器要用于这个作业</li>
    </ul>
  </li>
  <li><a href="https://circleci.com/docs/jobs-steps/#steps-overview"> <strong>步骤:</strong> </a>是一个键，代表一个作业期间运行的可执行命令的列表或集合<ul>
      <li><a href="https://circleci.com/docs/configuration-reference/#checkoutt"> <strong>签出:</strong> </a>是一个键，是一个特殊的步骤，用来将源代码签出到配置好的路径</li>
      <li><a href="https://circleci.com/docs/configuration-reference/#run"> <strong>运行:</strong> </a>是用来调用所有命令行程序的一个键<ul>
          <li><a href="https://circleci.com/docs/configuration-reference/#run"> <strong>名称:</strong> </a>是一个按键，表示在CircleCI界面中要显示的步骤的标题</li>
          <li><a href="https://circleci.com/docs/configuration-reference/#run"> <strong>命令:</strong> </a>是一个代表命令通过shell运行的键</li>
        </ul>
      </li>
      <li><a href="https://circleci.com/docs/configuration-reference/#store_test_results"><strong>store _ test _ results:</strong></a>是一个键，表示一个特殊的步骤，用于上传和存储一个构建的测试结果<ul>
          <li><a href="https://circleci.com/docs/configuration-reference/#store_test_results"> <strong> path: </strong> </a>是指向包含JUnit XML或Cucumber JSON测试元数据文件子目录的目录的路径(绝对路径，或相对于您的<code>working_directory</code>)</li>
        </ul>
      </li>
      <li><a href="https://circleci.com/docs/configuration-reference/#store_artifacts"> <strong> store_artifacts: </strong> </a>是一个键，表示在web应用程序中或通过API存储可用性工件(例如日志、二进制文件等)的步骤<ul>
          <li><a href="https://circleci.com/docs/configuration-reference/#store_artifacts"> <strong>路径:</strong> </a>是用于保存作业工件的主容器中目录的路径</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>CI/CD的一个有价值的好处是能够对新编写的代码执行<a href="https://en.wikipedia.org/wiki/Test_automation">自动化测试</a>。它通过在每次修改代码时对代码执行测试来帮助识别代码中已知和未知的错误。</p>

<p>我们的下一步是在<code>config.yml</code>文件中定义一个新任务。将以下内容粘贴到文件中:</p>

<pre><code>  run_tests:
    docker:
      - image: circleci/node:12
    steps:
      - checkout
      - run:
          name: Install npm dependencies
          command: |
            npm install --save
      - run:
          name: Run Unit Tests
          command: |
            ./node_modules/mocha/bin/mocha test/ --reporter mochawesome --reporter-options reportDir=test-results,reportFilename=test-results
      - store_test_results:
          path: test-results
</code></pre>
<p>这是我们刚刚添加的内容的明细。</p>

<ul>
  <li><strong> docker: </strong>和<strong> image: </strong>键指定了我们在这项工作中使用的执行者和docker图像</li>
  <li><strong>命令:<code>npm install --save</code> </strong>键安装应用程序中使用的应用程序依赖项</li>
  <li><strong>名称:运行单元测试</strong>执行自动化测试，并将它们保存到名为<code>test-results/</code>的本地目录中</li>
  <li><strong> store_test_results: </strong>是一个特殊的命令，它将<code>test-results/</code>目录结果保存并固定到CircleCI中的构建中</li>
</ul>

<p>这项工作作为一个单元测试功能。它有助于识别代码中的错误。如果这些测试中的任何一个失败，整个管道构建都将失败，并提示开发人员修复错误。目标是通过所有的测试和作业。接下来，我们将创建一个构建Docker映像的作业，并将其推送到<a href="https://hub.docker.com/"> Docker Hub registry </a>。</p>

<h3>工单-构建_docker_image</h3>

<p>在本系列的第2部分中，我们手工创建了一个Docker映像，并将其推送到Docker Hub注册中心。在这项工作中，我们将使用自动化来完成这项任务。将该代码块追加到<code>config.yml</code>文件中:</p>

<pre><code>  build_docker_image:
    docker:
      - image: circleci/node:12
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: false
      - run:
          name: Build Docker image
          command: |
            export TAG=0.2.&lt;&lt; pipeline.number &gt;&gt;
            export IMAGE_NAME=$CIRCLE_PROJECT_REPONAME            
            docker build -t $DOCKER_LOGIN/$IMAGE_NAME -t $DOCKER_LOGIN/$IMAGE_NAME:$TAG .
            echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin
            docker push $DOCKER_LOGIN/$IMAGE_NAME
</code></pre>

<p>这项工作相当简单。你已经遇到了它使用的大多数CircleCI YAML键，所以我将直接跳到<code>name: Build Docker Image</code>命令块。</p>

<ul>
  <li><code>export TAG=0.2.&lt;&lt; pipeline.number &gt;&gt;</code>行定义了一个本地环境变量，该变量使用<a href="https://circleci.com/docs/configuration-reference/#using-pipeline-values"> pipeline.number </a>值将Docker标签值与正在执行的管道号相关联</li>
  <li><code>export IMAGE_NAME=$CIRCLE_PROJECT_REPONAME</code>定义了我们将在命名Docker图像时使用的变量</li>
  <li><code>docker build -t $DOCKER_LOGIN/$IMAGE_NAME -t $DOCKER_LOGIN/$IMAGE_NAME:$TAG .</code>使用我们之前设置的项目级变量和我们指定的本地环境变量的组合来执行Docker构建命令</li>
  <li><code>echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin</code>验证我们的Docker Hub证书以访问平台</li>
  <li><code>docker push $DOCKER_LOGIN/$IMAGE_NAME</code>将新的docker映像上传到Docker Hub注册表</li>
</ul>

<p>这些应该看起来和感觉起来都很熟悉，因为这些命令与您在第2部分中手动运行的命令完全相同。在本例中，我们添加了环境变量命名位。接下来，我们将构建一个作业来执行构建GKE集群的Terraform代码。</p>

<h3>作业- gke_create_cluster</h3>

<p>在这项工作中，我们将自动执行在<code>part03/iac_gke_cluster/</code>目录中找到的Terraform代码。将这个代码块附加到<code>config.yml</code>文件，然后保存它:</p>

<pre><code>  gke_create_cluster:
    docker:
      - image: ariv3ra/terraform-gcp:latest
    environment:
      CLOUDSDK_CORE_PROJECT: cicd-workshops
    steps:
      - checkout
      - run:
          name: Create GKE Cluster
          command: |
            echo $TF_CLOUD_TOKEN | base64 -d &gt; $HOME/.terraformrc
            echo $GOOGLE_CLOUD_KEYS | base64 -d &gt; $HOME/gcloud_keys
            gcloud auth activate-service-account --key-file ${HOME}/gcloud_keys
            cd part03/iac_gke_cluster/
            terraform init
            terraform plan -var credentials=$HOME/gcloud_keys -out=plan.txt
            terraform apply plan.txt
</code></pre>

<p>在这个代码块中需要注意的一点是执行器Docker图像<code>image: ariv3ra/terraform-gcp:latest</code>。这是我创建的一个安装了<a href="https://cloud.google.com/sdk/docs/quickstarts"> Google SDK </a>和<a href="https://www.terraform.io/"> Terraform CLI </a>的图像。如果我们不使用它，我们将需要在这个作业中添加安装步骤，以便每次安装和配置工具。<code>environment: CLOUDSDK_CORE_PROJECT: cicd-workshops</code>键也是一个重要的元素。这设置了我们稍后将执行的<code>gcloud cli</code>命令所需的环境变量值。</p>

<p>代码块中使用的其他元素:</p>

<ul>
  <li><code>echo $TF_CLOUD_TOKEN | base64 -d &gt; $HOME/.terraformrc</code>是解码<code>$TF_CLOUD_TOKEN</code>值的命令，它创建Terraform访问相应Terraform云工作空间上的状态数据所需的<code>./terraformrc</code>文件</li>
  <li><code>echo $GOOGLE_CLOUD_KEYS | base64 -d &gt; $HOME/gcloud_keys</code>是解码<code>$GOOGLE_CLOUD_KEYS</code>值的命令，它创建了<code>glcoud cli</code>访问GCP所需的<code>gcloud_keys</code>文件</li>
  <li><code>gcloud auth activate-service-account --key-file ${HOME}/gcloud_keys</code>是一个命令，它授权使用我们之前解码并生成的<code>gcloud_keys</code>文件访问GCP</li>
</ul>

<p>其余的命令是带有<code>-var</code>参数的<code>terraform cli</code>命令，这些命令指定并覆盖在各自Terraform <code>variables.tf</code>文件中定义的变量的<code>default</code>值。一旦<code>terraform apply plan.txt</code>执行，这个作业将创建一个新的GKE集群。</p>

<h3>Job - gke_deploy_app</h3>

<p>在这项工作中，我们将自动执行在<code>part03/iac_kubernetes_app/</code>目录中找到的Terraform代码。将此代码块追加到config.yml文件，然后保存它:</p>

<pre><code>  gke_deploy_app:
    docker:
      - image: ariv3ra/terraform-gcp:latest
    environment:
      CLOUDSDK_CORE_PROJECT: cicd-workshops
    steps:
      - checkout
      - run:
          name: Deploy App to GKE
          command: |
            export CLUSTER_NAME="cicd-workshops"
            export TAG=0.2.&lt;&lt; pipeline.number &gt;&gt;
            export DOCKER_IMAGE="docker-image=${DOCKER_LOGIN}/${CIRCLE_PROJECT_REPONAME}:$TAG"
            echo $TF_CLOUD_TOKEN | base64 -d &gt; $HOME/.terraformrc
            echo $GOOGLE_CLOUD_KEYS | base64 -d &gt; $HOME/gcloud_keys
            gcloud auth activate-service-account --key-file ${HOME}/gcloud_keys
            gcloud container clusters get-credentials $CLUSTER_NAME --zone="us-east1-d"
            cd part03/iac_kubernetes_app
            terraform init
            terraform plan -var $DOCKER_IMAGE -out=plan.txt
            terraform apply plan.txt
            export ENDPOINT="$(terraform output endpoint)"
            mkdir -p /tmp/gke/ &amp;&amp; echo 'export ENDPOINT='${ENDPOINT} &gt; /tmp/gke/gke-endpoint
      - persist_to_workspace:
          root: /tmp/gke
          paths:
            - "*"
</code></pre>

<p>下面是这个职务代码块的重要元素和一些我们以前没有讨论过的新元素。</p>

<ul>
  <li>定义一个变量，该变量保存我们将要部署到的GCP项目的名称。</li>
  <li><code>gcloud container clusters get-credentials $CLUSTER_NAME --zone="us-east1-d"</code>是一个从我们在上一个作业中创建的GKE集群中检索<code>kubeconfig</code>数据的命令。</li>
  <li><code>terraform plan -var $DOCKER_IMAGE -out=plan.txt</code>是一个命令，覆盖在各个地形<code>variables.tf</code>文件中定义的各个变量的<code>default</code>值。</li>
  <li><code>export ENDPOINT="$(terraform output endpoint)"</code>将Terraform命令生成的输出<code>endpoint</code>值赋给一个本地环境变量，该变量将被保存到一个文件中，并持久保存到<a href="https://circleci.com/docs/configuration-reference/#persist_to_workspace"> CircleCI工作区</a>。然后可以从<a href="https://circleci.com/docs/configuration-reference/#attach_workspace">附属的CircleCI工作区</a>取回、附加并用于后续工作。</li>
</ul>

<h3>作业- gke_destroy_cluster</h3>

<p>这项工作是我们将为此管道建立的最后一个。这将基本上摧毁我们在以前的CI/CD工作中建立的所有资源和基础设施。作为测试的一部分，短暂的资源被用于冒烟测试、集成测试、性能测试和其他类型的测试。当不再需要这些构造时，执行destroy命令的作业对于删除它们非常有用。</p>

<p>在这项工作中，我们将自动执行在<code>part03/iac_kubernetes_app/</code>目录中找到的Terraform代码。将此代码块追加到config.yml文件，然后保存它:</p>

<pre><code>  gke_destroy_cluster:
    docker:
      - image: ariv3ra/terraform-gcp:latest
    environment:
      CLOUDSDK_CORE_PROJECT: cicd-workshops
    steps:
      - checkout
      - run:
          name: Destroy GKE Cluster
          command: |
            export CLUSTER_NAME="cicd-workshops"
            export TAG=0.2.&lt;&lt; pipeline.number &gt;&gt;
            export DOCKER_IMAGE="docker-image=${DOCKER_LOGIN}/${CIRCLE_PROJECT_REPONAME}:$TAG"            
            echo $TF_CLOUD_TOKEN | base64 -d &gt; $HOME/.terraformrc
            echo $GOOGLE_CLOUD_KEYS | base64 -d &gt; $HOME/gcloud_keys
            gcloud auth activate-service-account --key-file ${HOME}/gcloud_keys
            cd part03/iac_kubernetes_app
            terraform init
            gcloud container clusters get-credentials $CLUSTER_NAME --zone="us-east1-d"            
            terraform destroy -var $DOCKER_IMAGE --auto-approve
            cd ../iac_gke_cluster/
            terraform init
            terraform destroy -var credentials=$HOME/gcloud_keys --auto-approve
</code></pre>

<p>该作业代码块的重要元素是<code>terraform destroy -var credentials=$HOME/gcloud_keys --auto-approve</code>命令。该命令执行Terraform命令，该命令销毁分别在<code>part03/iac_gke_cluster</code>和<code>part03/iac_kubernetes_app/</code>目录中使用Terraform代码创建的所有资源。</p>

<p>现在，我们已经定义了管道中的所有<a href="https://circleci.com/docs/configuration-reference/#jobs">作业</a>，我们准备创建<a href="https://circleci.com/docs/configuration-reference/#workflows"> CircleCI工作流</a>，它将协调作业在管道中的执行和处理方式。</p>

<h2>创建CircleCI工作流</h2>

<p>我们的下一步是创建<a href="https://circleci.com/docs/configuration-reference/#workflows">工作流</a>，它定义了如何执行和处理作业。将工作流视为作业的有序列表。您可以使用工作流指定何时以及如何执行这些作业。将此工作流代码块附加到<code>config.yml</code>文件:</p>

<pre><code>workflows:
  build_test:
    jobs:
      - run_tests
      - build_docker_image
      - gke_create_cluster
      - gke_deploy_app:
          requires:
            - run_tests
            - build_docker_image
            - gke_create_cluster
      - approve-destroy:
          type: approval
          requires:
            - gke_create_cluster
            - gke_deploy_app
      - gke_destroy_cluster:
          requires:
            - approve-destroy
</code></pre>

<p>这个代码块代表我们管道的<a href="https://circleci.com/docs/configuration-reference/#workflows">工作流</a>定义。这个街区的情况是这样的:</p>
<ul>
  <li><code>workflows:</code>键指定一个工作流元素</li>
  <li><code>build_test:</code>表示该工作流的名称/标识符</li>
  <li><code>jobs:</code>键代表在<code>config.yml</code>文件中定义的要执行的任务列表</li>
</ul>

<p>在此列表中，您可以指定要在此管道中执行的作业。这是我们的工作清单:</p>

<pre><code>      - run_tests
      - build_docker_image
      - gke_create_cluster
      - gke_deploy_app:
          requires:
            - run_tests
            - build_docker_image
            - gke_create_cluster
      - approve-destroy:
          type: approval
          requires:
            - gke_create_cluster
            - gke_deploy_app
      - gke_destroy_cluster:
          requires:
            - approve-destroy
</code></pre>

<p><code>run_tests</code>、<code>build_docker_image</code>和<code>gke_create_cluster</code>工作流<a href="https://circleci.com/docs/configuration-reference/#jobs-1">作业</a>在<a href="https://circleci.com/docs/configuration-reference/#jobs-1">中并行或并发运行</a>，不像<code>gke_deploy_app:</code>项目有一个<code>requires:</code>键。默认情况下，作业是并行运行的，因此您必须使用一个<code>requires:</code>键和一个在开始指定的作业之前必须完成的作业列表，通过它们的作业名称明确要求任何依赖项。把<code>requires:</code>键想象成建立在其他工作成功的基础上。这些键允许您分割和控制管道的执行。</p>

<p><code>approve-destroy:</code>项指定具有<a href="https://circleci.com/docs/configuration-reference/#type">手动批准步骤</a>的作业。它需要人工干预，必须有人批准执行工作流作业列表中的下一个作业。下一个作业<code>gke_destroy_cluster:</code>依赖于执行前正在完成的<code>approval-destroy:</code>作业。它会破坏管道中先前执行的作业所创建的所有资源。</p>

<h2>完整的. config.yml文件</h2>

<p>完整的<code>config.yml</code>基于这个帖子，可以在<code>.circleci/</code>目录下的<a href="https://github.com/datapunkz/learn_iac">项目代码报告</a>中找到。它在这里供您回顾:</p>

<pre><code>version: 2.1
jobs:
  run_tests:
    docker:
      - image: circleci/node:12
    steps:
      - checkout
      - run:
          name: Install npm dependencies
          command: |
            npm install --save
      - run:
          name: Run Unit Tests
          command: |
            ./node_modules/mocha/bin/mocha test/ --reporter mochawesome --reporter-options reportDir=test-results,reportFilename=test-results
      - store_test_results:
          path: test-results
      - store_artifacts:
          path: test-results
  build_docker_image:
    docker:
      - image: circleci/node:12
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: false
      - run:
          name: Build Docker image
          command: |
            export TAG=0.2.&lt;&lt; pipeline.number &gt;&gt;
            export IMAGE_NAME=$CIRCLE_PROJECT_REPONAME
            docker build -t $DOCKER_LOGIN/$IMAGE_NAME -t $DOCKER_LOGIN/$IMAGE_NAME:$TAG .
            echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin
            docker push $DOCKER_LOGIN/$IMAGE_NAME
  gke_create_cluster:
    docker:
      - image: ariv3ra/terraform-gcp:latest
    environment:
      CLOUDSDK_CORE_PROJECT: cicd-workshops
    steps:
      - checkout
      - run:
          name: Create GKE Cluster
          command: |
            echo $TF_CLOUD_TOKEN | base64 -d &gt; $HOME/.terraformrc
            echo $GOOGLE_CLOUD_KEYS | base64 -d &gt; $HOME/gcloud_keys
            gcloud auth activate-service-account --key-file ${HOME}/gcloud_keys
            cd part03/iac_gke_cluster/
            terraform init
            terraform plan -var credentials=$HOME/gcloud_keys -out=plan.txt
            terraform apply plan.txt
  gke_deploy_app:
    docker:
      - image: ariv3ra/terraform-gcp:latest
    environment:
      CLOUDSDK_CORE_PROJECT: cicd-workshops
    steps:
      - checkout
      - run:
          name: Deploy App to GKE
          command: |
            export CLUSTER_NAME="cicd-workshops"
            export TAG=0.2.&lt;&lt; pipeline.number &gt;&gt;
            export DOCKER_IMAGE="docker-image=${DOCKER_LOGIN}/${CIRCLE_PROJECT_REPONAME}:$TAG"
            echo $TF_CLOUD_TOKEN | base64 -d &gt; $HOME/.terraformrc
            echo $GOOGLE_CLOUD_KEYS | base64 -d &gt; $HOME/gcloud_keys
            gcloud auth activate-service-account --key-file ${HOME}/gcloud_keys
            gcloud container clusters get-credentials $CLUSTER_NAME --zone="us-east1-d"
            cd part03/iac_kubernetes_app
            terraform init
            terraform plan -var $DOCKER_IMAGE -out=plan.txt
            terraform apply plan.txt
            export ENDPOINT="$(terraform output endpoint)"
            mkdir -p /tmp/gke/
            echo 'export ENDPOINT='${ENDPOINT} &gt; /tmp/gke/gke-endpoint
      - persist_to_workspace:
          root: /tmp/gke
          paths:
            - "*"
  gke_destroy_cluster:
    docker:
      - image: ariv3ra/terraform-gcp:latest
    environment:
      CLOUDSDK_CORE_PROJECT: cicd-workshops
    steps:
      - checkout
      - run:
          name: Destroy GKE Cluster
          command: |
            export CLUSTER_NAME="cicd-workshops"
            export TAG=0.2.&lt;&lt; pipeline.number &gt;&gt;
            export DOCKER_IMAGE="docker-image=${DOCKER_LOGIN}/${CIRCLE_PROJECT_REPONAME}:$TAG"            
            echo $TF_CLOUD_TOKEN | base64 -d &gt; $HOME/.terraformrc
            echo $GOOGLE_CLOUD_KEYS | base64 -d &gt; $HOME/gcloud_keys
            gcloud auth activate-service-account --key-file ${HOME}/gcloud_keys
            cd part03/iac_kubernetes_app
            terraform init
            gcloud container clusters get-credentials $CLUSTER_NAME --zone="us-east1-d"            
            terraform destroy -var $DOCKER_IMAGE --auto-approve
            cd ../iac_gke_cluster/
            terraform init
            terraform destroy -var credentials=$HOME/gcloud_keys --auto-approve
workflows:
  build_test:
    jobs:
      - run_tests
      - build_docker_image
      - gke_create_cluster
      - gke_deploy_app:
          requires:
            - run_tests
            - build_docker_image
            - gke_create_cluster
      - approve-destroy:
          type: approval
          requires:
            - gke_create_cluster
            - gke_deploy_app
      - gke_destroy_cluster:
          requires:
            - approve-destroy
</code></pre>

<h2>结论</h2>

<p>恭喜你！您刚刚完成了本系列的第3部分，并通过构建一个新的使用<a href="https://www.terraform.io/"> Terraform </a>执行IaC资源的<code>config.yml</code>文件提升了您的体验。这篇文章解释并演示了<code>config.yml</code>文件中的一些关键元素以及与CircleCI平台相关的内部概念。</p>

<p>在这个系列中，我们涵盖了许多概念和技术，如Docker、GCP、Kubernetes、Terraform和CircleCI，并包含了一些使用它们的实践经验。我们还介绍了如何连接您的项目以使用CircleCI，并利用Terraform代码在目标部署环境中测试您的应用程序。本系列旨在增加您对重要的DevOps概念、技术以及它们如何协同工作的了解。</p>

<p>我鼓励你自己和你的团队去尝试；更改代码，添加新的Terraform提供程序，以及重新配置CI/CD作业和管道。使用您所学到的知识和团队提出的其他想法的组合，互相挑战以完成发布目标。通过实验，你会学到比任何博客文章都多的东西。</p>

<p>感谢您关注本系列。希望你觉得有用。请随时在Twitter <a href="https://twitter.com/punkdata"> @punkdata </a>上寻求反馈。</p>

<p>以下资源将帮助您扩展知识:</p>





        
          
          
        
      </div>
    </div>    
</body>
</html>
<html>
<head>
<title>Manage complex development projects by triggering pipelines from other pipelines | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>通过从其他管道触发管道来管理复杂的开发项目| CircleCI</h1>
<blockquote>原文：<a href="https://circleci.com/blog/triggering-pipelines-from-pipelines/#2021-12-10T02:00:00-08:00">https://circleci.com/blog/triggering-pipelines-from-pipelines/#2021-12-10T02:00:00-08:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>众所周知，软件开发正变得越来越复杂。软件的单个元素，如应用程序、库和服务，是相互联系的，并依赖于许多其他元素。开发团队处理他们开发、维护或依赖的整个服务生态系统，而服务生态系统又依赖于由独立团队维护的其他软件生态系统。维护这个生态系统就像你想象的那样复杂。确保整个系统正常运转，并按照预期保持运转，是一项极具挑战性的工作。</p>

<p>从其他管道触发管道是众多技术之一，可以帮助您管理复杂的相互连接和相互依赖的开发项目。在本教程中，我将介绍一些使用这种技术的用例，以及为什么它会有帮助。我将展示一个如何使用CURL实现管道到管道触发器的例子，您可以跟着我做。</p>

<h2>先决条件</h2>

<p>本中级到高级教程需要对CircleCI及其管道有所了解。如果您使用CircleCI并且有一些已经配置好的项目，这将特别有用。本文涵盖的所有内容将适用于所有的CircleCI计划。</p>

<h2>管道到管道触发器的用例</h2>

<p>考虑从现有管道触发新管道有几个原因。微服务编排就是一个典型的例子。一种常见的模式是在每个版本控制存储库中都有微服务，每个微服务都需要一个单独的CircleCI管道配置。随着一个服务的部署，您可以重新部署依赖于这个新版本的其他服务。或者你可以触发一个扩展的<a href="/blog/unit-testing-vs-integration-testing/">集成测试</a>套件，独立于更广泛的测试和部署流程运行。</p>

<p>如果不使用微服务，可以使用管道到管道触发器来发布和测试与下游使用者集成的库。</p>

<h2>实现管道触发器</h2>

<p>触发管道的一个工作流程遵循以下步骤:</p>
<ul>
  <li>执行第一个管道，进行构建，运行一些测试，并触发部署。</li>
  <li>该过程成功完成后，第一个管道对CircleCI进行API调用，以触发不同项目中的另一个管道。</li>
  <li>第二个管道执行构建、运行测试并触发部署。</li>
</ul>

<p>在这种情况下，第一个管道还可以传递一些管道参数，如部署的名称和版本，以便新触发的管道有一些上下文。</p>

<h2>使用管道触发器协调单独的服务</h2>

<p>要编排两个独立的服务，可以从单个作业中调用CircleCI API。您需要知道项目的名称，以及您希望从该作业中触发的管道。要用API处理管道，您需要组织名称(<code>zmarkan</code>)和项目名称(<code>pinging-me-softly</code>，因为我有古怪的幽默感)。</p>

<p>接下来，获取个人API令牌。您必须拥有对这两个项目的推送访问权限才能工作。您可以将API令牌存储在这个项目环境变量中。为了增加安全性，将其存储在<a href="https://circleci.com/docs/contexts/">环境</a>中。在我的例子中，我使用了一个名为<code>circleci-api</code>的上下文，环境变量的名称为<code>CIRCLE_API_TOKEN</code>。</p>

<p>要触发管道，您需要向项目的管道端点发送POST请求。这是我在本教程中使用的URL:</p>

<pre><code>https://circleci.com/api/v2/project/gh/zmarkan/pinging-me-softly/pipeline
</code></pre>

<p>有效负载必须包含您想要用来触发管道的分支或标记的详细信息，以及您想要传递给它的任何管道参数。</p>

<p>以下是一个作业示例:</p>

<pre><code>  trigger-new-pipeline:
      docker: 
        - image: cimg/base:2021.11
      resource_class: small
      steps:
        - run:
            name: Ping another pipeline
            command: |
              curl --request POST \
                --url https://circleci.com/api/v2/project/gh/zmarkan/pinging-me-softly/pipeline \
                --header "Circle-Token: $CIRCLECI_API_KEY" \
                --header "content-type: application/json" \
                --data '{"branch":"main","parameters":{"image-name":"'$DOCKER_LOGIN"/"$CIRCLE_PROJECT_REPONAME":"0.1.&lt;&lt; pipeline.number &gt;&gt;'"}}'
</code></pre>

<p>该作业使用了<code>cimg/base</code>图像和<code>small</code>资源类，这对于发送一个HTTP请求来说已经足够了。唯一的依赖是所有CircleCI图像附带的卷曲工具，包括<code>cimg/base</code>。</p>

<p>要触发管道，只需运行一个命令:<code>curl</code>。API密钥在<code>Circle-Token</code>头中传递，在包含令牌的环境变量中传递。有效载荷主体是一个JSON对象，它包含一个<code>branch</code>和参数:</p>

<pre><code>  { 
    "branch":"main",
    "parameters": {
        "image-name":"'$DOCKER_LOGIN"/"$CIRCLE_PROJECT_REPONAME":"0.1.&lt;&lt; pipeline/ number&gt;&gt;'"
    }
  }

</code></pre>

<p><code>image-name</code>参数的值是由三个变量构成的字符串:</p>
<ul>
  <li><code>$DOCKER_LOGIN</code>是在该项目或上下文中设置的环境变量。</li>
  <li><code>$CIRCLE_PROJECT_REPONAME</code>是CircleCI中指定这个项目的内置环境变量。</li>
  <li><code>pipeline.number</code>是另一个内置的环境变量。</li>
</ul>

<p>总的来说，这个值提供了我们在上一步中构建的Docker映像的名称。我在<a href="https://app.circleci.com/pipelines/github/zmarkan/pinging-me-softly/9/workflows/b17cb199-cc43-4275-967c-686b47d5824a/jobs/9">中使用了<code>zmarkan/demo-full:0.1.119</code>这个例子</a>。</p>

<h2>处理管道触发器</h2>

<p>CircleCI会自动为您处理管道触发器，就像它处理存储库中新的git提交一样。默认情况下，您的所有工作流都将运行，并且将执行您在API调用中指定的分支或标记的最后一次提交。对于本教程，我指定了<code>main</code>。</p>

<p>您可以在您的作业和工作流中处理您传递的任何参数(在我的例子中是T0)。只需确保在配置的<code>parameters</code>部分声明它们:</p>

<pre><code>  version: 2.1

  parameters:
    image-name:
      type: string
      default: "Not a real image name"

  jobs:
    print-image-name:
      docker: 
        - image: cimg/base:2021.11
      steps:
        - checkout
        - run:
            name: Echo Image name
            command: echo &lt;&lt; pipeline.parameters.image-name &gt;&gt;

  workflows:
    run-workflow:
      jobs:
        - print-image-name

</code></pre>

<p>这个管道示例只有一个工作流。它打印出我们在前面的管道中构建并通过API传递给这个管道的图像的名称。</p>

<h2>结论</h2>

<p>在本文中，我演示了如何使用CircleCI API在第一个项目的管道完成时触发另一个管道。这是一个简单的过程，只需要从正在运行的作业中调用一个API，所有CircleCI用户和组织都可以使用。</p>

<p>这种技术为编排复杂的工作流开辟了新的可能性，包括微服务架构，并将昂贵的集成测试工作从构建和部署场景中分离出来。对于你和你的团队来说，还有很多很多的可能性可以尝试。</p>

<p>如果你对这篇文章有任何问题或建议，或者对未来的文章和指南有什么想法，请通过<a href="https://twitter.com/zmarkan" target="_blank" rel="noreferrer noopener"> Twitter - @zmarkan </a>或<a href="mailto:zan@circleci.com" target="_blank" rel="noreferrer noopener"> email给我</a>联系我。</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>
<html>
<head>
<title>Docker Images - Goss | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>坞站图片-gos |圆形</h1>
<blockquote>原文：<a href="https://circleci.com/blog/testing-docker-images-with-circleci-and-goss/#2018-05-15T03:12:00-07:00">https://circleci.com/blog/testing-docker-images-with-circleci-and-goss/#2018-05-15T03:12:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>测试是任何CI/CD管道的关键部分。大多数团队在应用程序级测试方面做得很好，并且有大量的框架(JUnit、RSpec等。)来支持。但是服务器级测试——服务器配置和服务的验证——经常被忽略。在这篇博文中，我们将探索一种方法来使用Goss对我们的自定义<a href="https://circleci.com/docs/custom-images/"> Docker图像</a>执行测试，作为CircleCI管道的一部分。</p>



<p>首先，<a href="https://github.com/aelsabbahy/goss"> Goss </a>是什么？</p>
<blockquote>
  <p>Goss是一个位于YAML的serverspec替代工具，用于验证服务器的配置。</p>
</blockquote>

<p>在这篇文章中，我们将只涉及几种类型的测试，所以值得探索一下<a href="https://github.com/aelsabbahy/goss/blob/master/docs/manual.md"> Goss手册</a>来学习所有可用的操作。该项目还包括<code>dgoss</code>，它是一个面向<code>goss</code>的Docker包装器。它包括两个基本操作:<code>edit</code>和<code>run</code>。</p>

<h2>先决条件</h2>
<p>为了在本地运行测试，您需要根据您的操作系统使用适当的步骤安装dgoss 。</p>

<p>您还需要一个正在开发的Docker图像。在这篇文章的剩余部分，我将引用我的<a href="https://github.com/eddiewebb/circleci-docker-goss">示例项目</a>，你应该分叉并跟随它！</p>

<h2>创建测试</h2>
<p>正如<a href="https://github.com/aelsabbahy/goss/blob/master/docs/manual.md"> Goss手册</a>所建议的，最简单的开始方式是通过使用<code>goss add &lt;TYPE&gt; &lt;ARGUMENTS&gt;</code>在你想要测试的服务器/容器内部运行。因为我们在容器的侧面运行，所以我们需要首先构建它。</p>

<pre><code>docker build . -t my-image:test
</code></pre>
<p>然后使用上面的标记名，我们可以通过dgoss运行安装了Goss的容器。<code>dgoss edit</code>支持启动图像所需的任何Docker参数。在我的示例项目中，这包括一个修改的入口点。</p>
<pre><code>dgoss edit --entrypoint=/test/gossEntrypoint.sh my-image:test
</code></pre>
<p>您可以运行<code>test/editTests.sh</code>来作为重复这些命令的快捷方式。<img src="../Images/3f9bdaed741881400a78f0cabd032e03.png" alt="CDGossDocker_edit1.gif" data-original-src="https://circleci.com/blog/media/CDGossDocker_edit1.gif"/></p>

<p>一旦进入正在运行的Docker映像，您就可以探索不同的测试，Goss命令会自动将这些测试附加到goss.yaml文件中。退出后，该文件将被复制到您的本地工作站。</p>

<h3>验证文件是否存在</h3>
<p>我们的第一个测试非常简单:确保我们的entrypoint.sh文件在文件系统中。</p>
<pre><code>/goss # goss add file /entrypoint.sh
</code></pre>
<p><img src="../Images/cd0e5100a224aed5585e69b7190c7999.png" alt="CDGossDocker_file1.png" srcset="https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=449 449w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=898 898w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1347 1347w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=779 779w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1558 1558w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2337 2337w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=750 750w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1500 1500w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2250 2250w" sizes="(min-width: 1200px) 750px,&#10;(min-width: 992px) 779px,&#10;(min-width: 768px) 720px,&#10;(min-width: 480px) 720px,&#10;(min-width: 0px) 449px" data-full-size-src="https://production-cci-com.imgix.net/blog/media/CDGossDocker_file1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;fm=jpg" data-original-src="https://circleci.com/blog/media/CDGossDocker_file1.png"/></p>

<p>您可以看到输出指定了位置、类型、所有者和其他关键属性。您现在可以<code>cat goss.yml</code>看到初始的测试结构，但是一个健康的映像不仅仅包括文件的存在，所以让我们再添加一些测试。</p>

<h3>验证命令输出</h3>
<p>我们的Docker映像非常简单，entrypoint只是根据安装在我们的生产环境中的配置文件运行一些简单的逻辑。我们希望确保它按照预期处理这个配置文件。</p>

<p>对于我们的第一个测试，我们希望确保如果没有找到文件，脚本退出时显示一个读取警告。由于这是默认状态，我们可以运行以下命令:</p>
<pre><code>goss add command "/entrypoint.sh /config.txt /schedule.txt"
</code></pre>
<p>引用参数很重要，否则Goss会将它们视为单独的命令。</p>

<p><img src="../Images/3c2bc00a1807ae6709575397858072d3.png" alt="CDGossDockercommand1.png" srcset="https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=449 449w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=898 898w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1347 1347w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=779 779w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1558 1558w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2337 2337w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=750 750w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1500 1500w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2250 2250w" sizes="(min-width: 1200px) 750px,&#10;(min-width: 992px) 779px,&#10;(min-width: 768px) 720px,&#10;(min-width: 480px) 720px,&#10;(min-width: 0px) 449px" data-full-size-src="https://production-cci-com.imgix.net/blog/media/CDGossDockercommand1.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;fm=jpg" data-original-src="https://circleci.com/blog/media/CDGossDockercommand1.png"/></p>

<p>您可以看到Goss期望退出状态为1，这是一条打印到stderr的消息。</p>

<p>我们还有一些更复杂的测试，因为它们修改文件来模拟生产中可能出现的某些条件。对于这些测试，我发现将逻辑封装到它们自己的脚本中，并在文件名中指明明确的意图，更具可读性和可维护性。一个例子可见于<a href="https://github.com/eddiewebb/circleci-docker-goss/blob/master/test/testNonEmptyScheduleModifiesScalerConfig.sh"> <code>testNonEmptyScheduleModifiesScalerConfig.sh</code> </a>。该测试将确保非空调度修改我们的配置。</p>

<p>该目录中的每个测试都设置一些预期的状态，然后像我们上面做的那样调用<code>/entrypoint.sh /config.txt /schedule.txt</code>。</p>

<h3>模式匹配</h3>
<p>有时候输出会有动态内容，幸运的是Goss支持一些基本的模式匹配。例如，上面的测试在测试中使用了当前的日期和时间，并将在输出中打印出来。因为这将根据我们执行测试的时间来改变输出，所以我们使用一个正则表达式来处理这个问题。</p>

<pre><code>/test/testNonEmptyScheduleModifiesScalerConfig.sh:
  exit-status: 0
  stdout:
  - /Matching rule - Day:\s[1-7], Hour:\s[1-2]?[0-9], Type :\sdocker, Count:\s5/
  - Updated docker preallocation count to 5
  - /Matching rule - Day:\s[1-7], Hour:\s[1-2]?[0-9], Type :\smachine, Count:\s5/
  - Updated machine preallocation count to 5
  - schedule updated
  stderr: []
  timeout: 10000
</code></pre>
<p><strong>注意:</strong>需要使用<code>\s</code>，这样yaml就不会将冒号解析为yaml key: value。</p>

<h3>最终规范(goss.yaml)</h3>
<p>当您在运行完所有的<code>goss add</code>步骤后键入<code>exit</code>时，您将看到Goss在停止实例之前将生成的goss.yaml复制回您的本地机器。</p>
<pre><code>/goss # exit
INFO: Copied '/goss/goss.yaml' from container to 'test'
INFO: Deleting container
</code></pre>
<p>该文件是我们已经看到的各个输出的集合，按照它们的类型分组。</p>

<pre><code>file:
  /entrypoint.sh:
    exists: true
    mode: "0755"
    size: 1530
    owner: root
    group: root
    filetype: file
    contains: []
  /schedule.sh:
    exists: false
    contains: []
command:
  /test/testEmptyScheduleIgnored.sh:
    exit-status: 1
    stdout: []
    stderr: []
    timeout: 10000
  /test/testNonEmptyScheduleModifiesScalerConfig.sh:
    exit-status: 0
    stdout:
    - /Matching rule - Day:\s[1-7], Hour:\s[1-2]?[0-9], Type :\sdocker, Count:\s5/
    - Updated docker preallocation count to 5
    - /Matching rule - Day:\s[1-7], Hour:\s[1-2]?[0-9], Type :\smachine, Count:\s5/
    - Updated machine preallocation count to 5
    - schedule updated
    stderr: []
    timeout: 10000
  /test/testNonExistentScheduleIgnored.sh:
    exit-status: 1
    stdout: []
    stderr:
    - 'cat: can''t open ''/schedule.txt'': No such file or directory'
    timeout: 10000

</code></pre>

<h2>运行我们的测试</h2>

<p>现在我们应该有了一个工作的Docker映像(我们希望如此)和一些在goss.yaml中定义的测试，我们想对一个新的映像执行我们的测试。dgoss希望当前目录中有一个名为goss.yaml的文件。因为我把我们的放在了<code>test</code>文件夹中，所以我们需要包含<code>GOSS_FILES_PATH</code>参数。</p>

<pre><code>docker build . -t my-image:test
GOSS_FILES_PATH=test dgoss run --entrypoint=/test/gossEntrypoint.sh my-image:test
# OR provided wrapper for this tutorial
test/runTests.sh
</code></pre>
<p>上面的命令将构建一个新的Docker映像，mount Goss和goss.yaml，并执行我们的测试。</p>

<p><img src="../Images/5f59139c9d4c51677b953ff933c04857.png" alt="CDGossDocker_test1.gif" data-original-src="https://circleci.com/blog/media/CDGossDocker_test1.gif"/></p>

<p>这个输出不是很令人兴奋，但是通过测试应该是这样的。所以，让我们打破一些东西！</p>

<pre><code>#!/bin/bash
#
# Any changes are written to the SCALING_FILE
#
set -euo pipefail

#this won't work..
CMD=`./nonexistentScript.sh`

SCALING_FILE=$1
SCHEDULE_FILE=$2
</code></pre>

<p>当你执行<code>test/runTest.sh</code>时会发生什么？Goss将打印预期的而不是实际的输出，并包括一个错误摘要。它还以非零状态存在，这对我们的下一步很重要:与我们的<a href="https://circleci.com/continuous-integration/">持续集成</a>管道集成！</p>

<h2>在每次提交时运行我们的测试</h2>
<p>我们在本地运行测试很好，但这里的想法是将Docker级别的测试集成到我们的CI/CD管道中，这样我们就不会发布糟糕的映像。</p>

<p><img src="../Images/5461c96f37d75c9fc3ff6b9e32a84203.png" alt="CDGossDocker_passingtests.png" class="img-auto" data-original-src="https://circleci.com/blog/media/CDGossDocker_passingtests.png?imgix=false"/></p>

<p><img src="../Images/357d2d4339634fcac002e8a4f5907df7.png" alt="CDGossDocker_failingtests.png" class="img-auto" data-original-src="https://circleci.com/blog/media/CDGossDocker_failingtests.png?imgix=false"/></p>

<p>CircleCI不提供预装Goss的映像，但安装它只需要一秒钟。您可以查看<a href="https://github.com/eddiewebb/circleci-docker-goss/blob/master/.circleci/config.yml"> sample config.yml </a>了解完整设置。我在这里只包括相关的片段。</p>

<pre><code>jobs:
  test:
    docker:
      - image: circleci/python:2-jessie
    steps:
      - checkout

      - setup_remote_docker:   # (2)
          docker_layer_caching: true # (3)
      - run:
          name: Install goss
          command: |
            # rather than give internet scripts SU rights, we install to local user bin and add to path
            mkdir ~/bin
            export GOSS_DST=~/bin
            export PATH=$PATH:~/bin
            curl -fsSL https://goss.rocks/install | sh
            goss -version
      - run:
          name: Test
          command: |
            # Don't forget path!
            export PATH=$PATH:~/bin
            # Important, change from mount to work on remote docker, see https://github.com/aelsabbahy/goss/pull/271
            # If using machine image you do not need this.
            export GOSS_FILES_STRATEGY=cp
            test/runTests.sh junit
      - store_test_results:
          path: goss

</code></pre>
<h3>试验结果</h3>
<p><strong>注意:</strong>对于CI执行，我们将参数<code>junit</code>传递给我们的测试运行程序。这会将输出格式转换成~/goss/report.xml，并包含在CircleCI的测试摘要中:</p>

<p><img src="../Images/a92e92b98fd69565e7af6bd4ef6d34d9.png" alt="CDGossDocker_testresults.png" srcset="https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=449 449w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=898 898w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1347 1347w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=779 779w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1558 1558w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2337 2337w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=750 750w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1500 1500w,&#10;https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2250 2250w" sizes="(min-width: 1200px) 750px,&#10;(min-width: 992px) 779px,&#10;(min-width: 768px) 720px,&#10;(min-width: 480px) 720px,&#10;(min-width: 0px) 449px" data-full-size-src="https://production-cci-com.imgix.net/blog/media/CDGossDocker_testresults.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;fm=jpg" data-original-src="https://circleci.com/blog/media/CDGossDocker_testresults.png"/></p>

<h2>摘要</h2>
<p>就这样吧！随着这个基本结构的运行，您可以添加更成熟的测试，并将基于Goss的映像测试作为核心步骤包含在您的CI/CD管道中，以保持您团队的代码库从服务到服务器都得到测试。</p>

<p>一定要把那个快乐的绿色状态徽章加到你的回购上，让全世界都知道！</p>

<p><img src="../Images/9607e1f52bd36897e4f7a9508504dbf4.png" alt="Passed_Build.png" class="img-auto" data-original-src="https://circleci.com/blog/media/Passed_Build.png?imgix=false"/></p>

<p>航运愉快！</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>
<html>
<head>
<title>CircleCI config teardown</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>CircleCI配置拆卸</h1>
<blockquote>原文：<a href="https://circleci.com/blog/circleci-config-teardown-how-we-write-our-circleci-config-at-circleci/#2019-10-28T08:00:00-07:00">https://circleci.com/blog/circleci-config-teardown-how-we-write-our-circleci-config-at-circleci/#2019-10-28T08:00:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>虽然每个人都喜欢抱怨YAML(相信我，我们也抱怨它！)，事实是这种简单的语言可以创建强大的管道来完成几乎任何你可以想象的事情。在这篇文章中，我将带您浏览我们自己的构建代理项目的配置文件，并使用它来突出我们的配置格式是如何形成的一些有趣的历史。</p>

<p>构建代理是我们注入到作业中运行它们的可执行文件。它是最终获取配置并执行作业中每一步的程序。CI流程是CircleCI最复杂的流程之一，大多数服务都有一个更基本的3步构建、测试和部署流程。</p>

<p>我没有警告拥有这个代码库的团队我要这么做。他们有点害怕展示他们的配置缺点，但已经决定合作。</p>

<h2>版本</h2>

<p>配置文件中的第一个声明是版本字段。</p>

<pre><code>version: 2.1
</code></pre>

<p>我们当前的配置版本是2.1，我们在2018年11月推出了一系列丰富的新配置功能，主要是<a href="https://circleci.com/orbs/" target="_blank" rel="noreferrer noopener">orb</a>、命令和执行器。</p>

<h2>工作流程</h2>

<p>接下来我们有了<code>workflows</code>定义，我们有了一个单一的工作流。该工作流程的目标是将经过全面测试的Docker映像推送到<a href="https://hub.docker.com" target="_blank" rel="noreferrer noopener"> Docker Hub </a>。</p>

<pre><code>workflows:
  ci:
    jobs:
      - test
      - coverage
      - lint
      - verify_generated
      - test_windows
      - test_mac
      # snip...
</code></pre>

<p>列出的第一组任务没有依赖关系——我们在CircleCI支持的三个平台上运行<code>test</code> (Linux)、<code>test_windows</code>和<code>test_mac</code>进行测试。我们希望在<code>git push</code>之后尽快得到关于任何失败测试的反馈。</p>

<pre><code>workflows:
  ci:
    jobs:
      # snip...
      - docker_image:
          context: org-global
      - test_e2e:
          requires: [docker_image]
      - prod_smoke_tests:
          requires: [docker_image]
      - publish_image:
          filters:
            branches:
              only: master
          context: org-global
          requires:
            - test
            - coverage
            - lint
            - verify_generated
            - test_windows
            - test_mac
            - test_e2e
            - prod_smoke_tests
</code></pre>

<p><img src="../Images/92181a9f3f6b56d2f4f3799c431bdfe8.png" alt="Screenshot 2019-10-25 at 20.52.36.png" srcset="https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=449 449w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=898 898w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1347 1347w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=779 779w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1558 1558w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2337 2337w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=750 750w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1500 1500w,&#10;https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2250 2250w" sizes="(min-width: 1200px) 750px,&#10;(min-width: 992px) 779px,&#10;(min-width: 768px) 720px,&#10;(min-width: 480px) 720px,&#10;(min-width: 0px) 449px" data-full-size-src="https://production-cci-com.imgix.net/blog/media/Screenshot%202019-10-25%20at%2020.52.36.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;fm=jpg" data-original-src="https://circleci.com/blog/media/Screenshot 2019-10-25 at 20.52.36.png"/></p>

<p>然后我们有一组具有依赖关系的作业——第一个作业是<code>docker_image</code>,构建将被测试的Docker映像，然后我们有两个下游作业:<code>test_e2e</code>和<code>prod_smoke_tests</code>,它们依赖于Docker映像，最后，如果所有其他作业都成功，则<code>publish_image</code>作业将发布映像。</p>

<p>其中两个任务使用<a href="https://circleci.com/docs/contexts/" target="_blank" rel="noreferrer noopener">一个<code>context</code>T2，它可以访问访问CircleCI Docker Hub账户所需的秘密。上下文允许您在CircleCI上的项目之间共享凭证，我们的受限上下文允许您将访问权限限制在团队的特定成员。</a></p>

<h2>球</h2>

<pre><code>orbs:
  go: gotest/tools@0.0.10
  codecov: codecov/codecov@1.0.4
  win: circleci/windows@1.0.0
</code></pre>

<p>接下来，我们引入对三个球体的引用。orb是可共享的配置元素包，包括作业、命令和执行器。</p>

<p>我们从三个不同的名称空间引入三种类型的球体:</p>
<ul>
  <li>我们导入的第一个orb是一个社区orb - <a href="https://circleci.com/developer/orbs/orb/gotest/tools" target="_blank" rel="noreferrer noopener"> <code>gotest/tools</code> </a>，它有一些方便的命令用于测试用<code>golang</code>编写的项目。</li>
  <li>我们导入<a href="https://www.codecov.io/" target="_blank" rel="noreferrer noopener"> CodeCov.io </a>,这是一个合作伙伴orb，我们用它来报告我们项目的代码覆盖度量。</li>
  <li>最后是<code>windows</code> orb，这是配置Windows作业所需的第一方orb。</li>
</ul>

<p>这里的导入语法是经过特别选择的，以确保依赖关系的变化不会破坏我们的构建。orb的每个发布版本都是不可变的，所以如果您导入一个具有特定版本的orb，它将永远不会改变(除非您正在使用<a href="https://circleci.com/docs/using-orbs/#orb-versions-development-vs-production" target="_blank" rel="noreferrer noopener">一个dev orb </a>)。</p>

<p>你可以选择放松这些保证——导入<code>codecov/codecov@1.0</code>将会导入最高版本的<code>1.0.x</code>,同样的，<code>codecov/codecov@1</code>将会导入最高版本的<code>1.x.y</code>。</p>

<p>我们还支持一个名为<code>volatile</code>的特殊版本，它将始终导入已经发布的最高版本号的orb。我们特意选择了单词<code>volatile</code>而不是<code>latest</code>,以便在配置文件中清楚地表明这是危险的，并且导入的orb可能会随着构建的不同而变化。</p>

<p>我们还写了一篇关于我们为orbs 所做的设计选择的博客，你可能想看看。</p>

<h2>实施者</h2>

<p>下一部分是我们声明<code>executors</code>的地方，这是在配置文件中的一个地方声明执行环境的方法，以便在作业之间共享它。在配置版本2.1中添加了执行器，以解决我们在检查配置文件中的常见模式时看到的一些问题——YAML锚在作业之间共享配置。我们从用户和自己的项目中看到的YAML锚最常见的用途之一是确保所有工作使用完全相同的Docker图像。</p>

<pre><code>executors:
  default:
    docker:
      - image: circleci/golang:1.11
</code></pre>

<p>通过使用<code>executors</code>块而不是YAML锚，我们的用户获得了更好的体验。执行程序声明的语法是在文件中声明执行程序的地方检查的，而不是在使用它的地方，因此修复错误更加简单。执行者也可以打包成orb，在项目间共享。</p>

<h2>命令</h2>

<p>像executors一样，命令也被设计用来取代CircleCI中YAML锚的一种常见用法——在作业之间共享步骤。在2.0配置中，使用锚在作业之间共享单个步骤已经足够好了。问题在于共享多个步骤——YAML锚没有拼接操作，所以不可能将一系列步骤插入另一个步骤；通过命令，您可以。</p>

<p>我们使用命令的一个简单方法是建立远程Docker连接，并确保在所有使用该命令的作业中使用相同版本的Docker (18.09.3 ):</p>

<pre><code>commands:
  remote_docker:
    steps:
      - setup_remote_docker:
          version: 18.09.3
      - run: docker version
</code></pre>

<p>更高级的命令<code>prep_for_docker_image_tests</code>用于减少<code>prod_smoke_tests</code>和<code>test_e2e</code>测试所需的一组步骤的重复；</p>

<pre><code>  prep_for_docker_image_tests:
    steps:
      - run: mkdir /tmp/dockertag
      - attach_workspace:
          at: /tmp/dockertag
      - run:
          name: verify tag is present
          command: |
            if ! [ -f /tmp/dockertag/docker_image.tag ]; then
              echo "No docker tag found"
              echo "This is likely because the upstream job ran before the PR was created"
              echo ""
              echo "Re-run the workflow now that a PR exists to include the publish image step"
              exit 1
            fi
      - checkout
      - run: mv /tmp/dockertag/docker_image.tag .
</code></pre>

<p>这个命令还有其他一些有趣的配置用法:</p>

<ul>
  <li>我们使用工作区来访问上游作业的数据。在本例中，我们附加了一个工作空间来加载在<code>docker_image</code>任务中创建的Docker图像的标签。</li>
  <li>在<code>verify tag is present</code>步骤中，我们检测到一个问题(作业运行时没有Docker标签)，我们产生一个详细的错误消息告诉用户发生了什么，如何修复它，最后我们调用<code>exit 1</code>使作业失败。如果发生这种情况，错误消息将在CircleCI UI中可见，并以红色突出显示，以便用户容易发现。</li>
  <li>我们既使用了<code>run:</code>的短格式，也使用了长格式。当命令比较简单时，我们使用简短的形式(例如<code>mkdir /tmp/dockertag</code>)，当命令比较长时，我们给它一个描述性的名称来记录更高级别的操作(“验证标签是否存在”)。</li>
</ul>

<h2>乔布斯</h2>

<p>我不会一一列举我们所有的工作，而是将注意力放在它们更有趣的方面。</p>

<h3>验证_生成</h3>

<p>我们有一项工作是验证生成的代码是最新的。我的同行对我们如何安装这些依赖项并不感到特别自豪，但我保证会有缺点。</p>

<pre><code>  verify_generated:
    executor: default
    steps:
      - checkout
      - go/mod-download
      - go/mod-tidy-check
      - run:
          name: install protobuf binaries
          command: |
            mkdir -p /tmp/protoc
            cd /tmp/protoc

            wget https://github.com/protocolbuffers/protobuf/releases/download/v3.3.0/protoc-3.3.0-linux-x86_64.zip
            unzip protoc*.zip
            sudo mv bin/protoc /usr/local/bin/

            wget http://central.maven.org/maven2/io/grpc/protoc-gen-grpc-java/1.3.0/protoc-gen-grpc-java-1.3.0-linux-x86_64.exe
            sudo mv protoc-gen-grpc-java* /usr/local/bin/protoc-gen-grpc-java
            sudo chmod +x /usr/local/bin/protoc-gen-grpc-java

      - run: ./do generate-fakes
      - run: ./do generate-protos
      - run:
          name: Ensure that generated files are in sync
          command: git diff --exit-code
</code></pre>

<p>项目中有一些生成的代码，这是为了生成gRPC互操作代码，并为测试生成一些模拟接口。我们生成代码，并将生成的代码提交给<code>git</code>。这里的作业在CI期间重新生成代码，如果在CI期间生成的代码与提交给CI的代码不同，那么构建将会失败。这允许我们在开发人员忘记提交生成的代码时中断构建。</p>

<h3>测试窗口</h3>

<pre><code>  test_windows:
    executor:
      name: win/vs2019
      shell: bash --login -eo pipefail
    steps:
      - run: git config --global core.autocrlf false
      - checkout
</code></pre>

<p>我们在Windows上构建和测试构建代理。为了使用我们现有代码库的bash架构，我们做了一系列小的配置调整，以确保我们的Windows构建能够顺利运行。Orbs简化了新资源类的引入，因为它们允许我们在不需要大量开发工作的情况下提供配置调整。</p>

<h3>球</h3>

<p>首先，我们能够在八月份<a href="https://circleci.com/blog/windows-general-availability-announcement/" target="_blank" rel="noreferrer noopener">添加Windows支持</a>，而无需在我们的YAML配置中添加任何新语法。我们能够使用orb<code>circleci/windows</code>实现Windows，orb暴露了将在Windows Server 2019上运行作业的<code>executor</code>。在引擎盖下，<code>executor</code>被扩展为一个常规的<code>machine</code>执行器，具有特定的<code>image</code>和<code>resource_class</code>字段，它将shell设置为<code>powershell.exe</code>。</p>

<p>2017年11月，我参与了CircleCI 2.0 上<a href="https://circleci.com/blog/one-more-thing-apple-developers-can-now-build-for-macos-ios-tvos-and-watchos-on-circleci-2-0/" target="_blank" rel="noreferrer noopener"> macOS的发布。当时我们没有orb，所以我们必须在工作声明中添加一个新的<code>macos</code>字段，以允许人们选择macOS。这种改变需要上下改变堆栈，以使一堆服务意识到config中的这个新键。能够在不对配置文件格式进行任何更改的情况下启动Windows对我们内部来说是一个重要的里程碑，因为它验证了我们在2018年所做的大量内部更改和重新分解，使我们能够在服务中更好地分离关注点。</a></p>

<h3>行尾</h3>
<p>工作的第一步是当我们第一次开始在Windows上构建时，我为了解决一个问题而添加的，从那以后我们再也没有删除过。</p>

<pre><code>git config --global core.autocrlf false
</code></pre>

<p>我们有一些测试运行一组作业<code>steps</code>，然后将这些步骤的输出与包含预期输出的文件进行比较。我们用来比较字符串和预期输出文件的库在Windows上运行时有一个错误。通过将<code>core.autocrlf</code>设置为false，我们避免了<code>git</code>在结账时将<code>\n</code>转换为<code>\r\n</code>的默认行为，这解决了这个问题。这解决了眼前的问题，我再也没有回去找到错误是什么。</p>

<h3>贝壳</h3>

<p>我们的Windows映像的默认shell是<code>powershell.exe</code>。我们还提供了<code>cmd.exe</code>、<code>bash.exe</code>，事实上，还有任何其他可以安装在映像上的shell。为了测试<code>build-agent</code>，我们将shell设置为<code>bash --login -eo pipefail</code>，这与我们在Linux和macOS作业上运行的shell相同。我们安装的<code>bash</code>是Windows 自带<a href="https://gitforwindows.org/" target="_blank" rel="noreferrer noopener"> <code>git</code>的<code>bash</code>版本。这允许我们像其他测试工作一样重用相同的脚本和命令。</a></p>

<h2>测试_mac</h2>

<p>我们的macOS测试在一个简洁的配置中使用了大量的CircleCI特性。</p>

<pre><code>  test_mac:
    macos:
      xcode: '10.3.0'
    steps:
      - checkout
      - run:
          name: Setup host
          command: ./scripts/ci/mac-setup
      - go/mod-download:
          prefix: v1-mac
          path: /Users/distiller/go/pkg/mod
      - run:
          name: Install GoLang devtools
          command: ./do install-devtools
      - go/mod-tidy-check
      - run:
          name: Test
          environment:
            GOTESTFLAGS: -coverprofile=coverage.txt
            GOTESTSUM_JUNITFILE: /tmp/test-reports/junit.xml
          command: |
            mkdir -p /tmp/test-reports
            ./do test-all
      - codecov/upload:
          flags: macos
      - store_test_reports
</code></pre>

<p>macos stanza本身非常简单:我们花了两周多的时间来设计它，并精心设计细节。将CircleCI 1.0与CircleCI 2.0进行对比，circle ci 1.0为所需xcode的单一版本提供了空间，circle ci 2.0增加了额外的嵌套级别:</p>

<pre><code> macos:
   xcode: '10.3.0'
</code></pre>

<p>我们这样做是为了确保在<code>macos</code>键下有空间放置<code>xcode</code>旁边的其他键。这允许我们在未来增加配置语法，而不必进行重大更改。</p>

<p>接下来，我们很好地混合了不同类型的命令:</p>

<pre><code class="language-yaml">- checkout
</code></pre>

<p><code>checkout</code>命令是一个内置的步骤，用于从<code>git</code>中签出项目。</p>

<pre><code>- run:
    name: Setup host
    command: ./scripts/ci/mac-setup
</code></pre>

<p>下一步是运行<code>./scripts/ci/mac-setup</code>的<code>run</code>步骤。我们更喜欢将这样的脚本作为文件签入<code>git</code>，而不是在<code>config.yml</code>中保存多行shell命令。将脚本取出并放入它们自己的文件中，可以更容易地处理这些文件:</p>
<ul>
  <li>语法突出显示在编辑器中工作正常</li>
  <li>文件内容从第1列开始，而不是出现在<code>config.yml</code>的第13列</li>
  <li>运行脚本很简单。我们大多数包含shell脚本的repos将使用<a href="https://circleci.com/developer/orbs/orb/circleci/shellcheck" target="_blank" rel="noreferrer noopener"><code>shellcheck</code>orb</a>来自动检查CI中的错误。我强烈推荐你的项目。</li>
</ul>

<pre><code>- go/mod-download:
     prefix: v1-mac
     path: /Users/distiller/go/pkg/mod
</code></pre>

<p>下一步，<code>go/mod-download</code>，是执行来自作为<code>go: gotest/tools@0.0.10</code>导入的<code>gotest/tools</code> orb的命令。我们可以引用orb中带有前缀<code>go/</code>的任何命令。我们向命令传递两个参数，<code>prefix</code>和<code>path</code>。您可以使用我们的CLI工具来扩展命令，就像这样，使用<code>circleci config process</code>命令来查看它们编译成什么。在这种情况下，它扩展为以下内容:</p>

<pre><code>    - run:
        name: Install git
        command: |
          command -v git &amp;&amp; exit
          command -v apk &amp;&amp; apk add --no-cache --no-progress git
    - restore_cache:
        name: Restore go module cache
        keys:
        - v1-mac-{{ arch }}-go-modules-
        - v1-mac-{{ arch }}-go-modules-{{ checksum "go.sum" }}
    - run:
        environment:
          GO111MODULE: 'on'
        command: go mod download
    - save_cache:
        name: Save go module cache
        key: v1-mac-{{ arch }}-go-modules-{{ checksum "go.sum" }}
        paths:
        - /Users/distiller/go/pkg/mod
</code></pre>

<p>这里有趣的一点是，在我们的macOS构建上的用户是<code>distiller</code>，而在我们所有的VMs构建(Linux和Windows)、<a href="https://circleci.com/docs/circleci-images/" target="_blank" rel="noreferrer noopener">和我们的便利Docker映像</a>中，用户总是<code>circleci</code>。原因是CircleCI上最初的macOS(当时的OS X)是由2014年加入CircleCI的Distiller团队<a href="https://circleci.com/blog/announcing-ios-and-android-support/" target="_blank" rel="noreferrer noopener">实现的。为了使Distiller用户平稳过渡到CircleCI 1.0平台，我们将用户名保留为<code>distiller</code>，以匹配Distiller产品。三年后，当我们发布CircleCI 2.0的macOS版本时，我们将用户名保留为<code>distiller</code>，以便为我们的客户实现从1.0到2.0的平稳过渡。5年后，我们在这里，用户名仍然是<i/><code>distiller</code>。</a></p>

<p>下一步在<code>run</code>步骤中很好地使用了<a href="https://circleci.com/docs/env-vars/" target="_blank" rel="noreferrer noopener">环境变量</a>。在config中设置<code>job</code>级别的环境变量是很常见的，但是我发现也可以在特定的<code>run</code>步骤中设置它们，这种情况并不常见。在可能的情况下，我喜欢将选项提取到环境变量中，而不是将长参数列表提取到命令中。在我看来，它使配置更具声明性，更少程序性。</p>

<pre><code>- run:
    name: Test
    environment:
      GOTESTFLAGS: -coverprofile=coverage.txt
      GOTESTSUM_JUNITFILE: /tmp/test-reports/junit.xml
    command: |
      mkdir -p /tmp/test-reports
      ./do test-all
</code></pre>

<p>最后一步是呼叫我们的一个合作伙伴orb:</p>

<pre><code class="language-yaml">- codecov/upload:
    flags: macos
</code></pre>

<p>这个命令将把测试的代码覆盖结果上传到<a href="https://codecov.io/" target="_blank" rel="noreferrer noopener"> CodeCov.io </a>。这里的<code>flags</code>参数允许<a href="https://docs.codecov.io/docs/merging-reports" target="_blank" rel="noreferrer noopener"> Codecode合并多个测试报告</a>。在构建期间，我们在三个平台上运行代码覆盖:</p>



<p>然后，我们使用标志<code>macos</code>、<code>windows</code>和<code>linux</code>上传所有三个测试运行的覆盖率数据。Codecov能够将这三个报告合并成一个报告，为我们提供构建的整体代码覆盖度量。</p>

<p>这张图片显示了我们每月改变<code>.circleci/config.yml</code>的频率:<img src="../Images/9abef1e98f8a347fa259cc52e8e6e836.png" alt="image" data-original-src="https://user-images.githubusercontent.com/448001/66754783-a73bed80-ee8e-11e9-9b28-413bf793b80b.png"/></p>

<h2>产品_烟雾_测试</h2>

<p>这项工作是我最喜欢的工作之一，我们在CircleCI的所有构建中都要做这项工作。</p>

<pre><code>  prod_smoke_tests:
    docker:
      - image: circleci/python:3.6
    steps:
      - prep_for_docker_image_tests
      - run:
          name: install dependencies
          working_directory: e2e/canary
          command: |
            pipenv install --skip-lock
      - run:
          name: Trigger e2e smoke tests
          working_directory: e2e/canary
          command: |
            export CIRCLECI_BUILD_AGENT_IMAGE="$(&lt; ../../docker_image.tag)"
            export CIRCLECI_API_TOKEN="${PICARD_DUMMY_API_TOKEN}"
            mkdir -p /tmp/test-reports
            time pipenv run pytest -n10 --junit-xml=/tmp/test-reports/results.xml ./tests.py
      - store_test_reports
</code></pre>

<p>这里的e2e(端到端)测试是使用<code>pytest</code>从Python中触发的，这允许我们<a href="https://circleci.com/docs/collect-test-data/" target="_blank" rel="noreferrer noopener">收集测试元数据(以“JUnit”XML格式)</a>并直接在作业页面上报告测试失败，而不必通读作业输出。</p>

<p>测试本身在<a href="https://circleci.com" target="_blank" rel="noreferrer noopener">circleci.com</a>上运行了七个生产版本，但是使用了这个版本中新标记的Docker映像，而不是生产中通常使用的版本。我们在Windows、macOS上运行构建，使用Docker，使用Linux VM，以及一些特定的功能和故障模式测试。所有这些测试都必须通过，工作流才能成功。</p>

<p>我们的<code>test_e2e</code>工作是类似的——它在<code>build-agent</code>和一些与之通信的上游服务之间运行一系列集成测试。</p>

<p>这意味着，我们只有在证明所生产的工件(新的<code>build-agent</code>)能够在所有平台上运行生产中的构建之后，才会将拉请求报告为绿色。当我部署时，这样的测试给了我很多信心。</p>

<h2>下一步是什么</h2>

<p>我们一直在努力改进我们的配置格式。我们目前在预览版中有我们的<a href="https://github.com/CircleCI-Public/api-preview-docs/blob/master/docs/pipeline-parameters.md" target="_blank" rel="noreferrer noopener">管道参数API，它允许你用暴露给我们的配置处理系统的特定参数来触发项目执行。</a></p>

<p>我们希望在我们的<a href="https://ideas.circleci.com/" target="_blank" rel="noreferrer noopener">想法页面</a>上听到您关于配置CircleCI的想法和反馈。</p>

<p>感谢您的关注。要我以后再解释另一个配置文件吗？<a href="https://twitter.com/atmarc?lang=en" target="_blank" rel="noreferrer noopener">@ Twitter上的我</a>提名一个。</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>
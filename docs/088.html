<html>
<head>
<title>How to build a CI/CD pipeline with Docker | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用Docker | CircleCI构建CI/CD管道</h1>
<blockquote>原文：<a href="https://circleci.com/blog/build-cicd-piplines-using-docker/#2021-04-30T15:30:00-07:00">https://circleci.com/blog/build-cicd-piplines-using-docker/#2021-04-30T15:30:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>一年中，我在会议和其他活动中与我的许多工程师同事交谈。我喜欢演示的一件事是他们如何毫不费力地将<a href="/continuous-integration/">持续集成</a>/持续部署(CI/CD)管道实现到代码库中。在这篇文章中，我将介绍一些演示代码和我在演示中使用的CircleCI配置。遵循这些步骤将向您展示如何将<a href="https://circleci.com/blog/what-is-a-ci-cd-pipeline/"> CI/CD管道</a>实现到您的代码库中。</p>

<p>这篇文章将涵盖:</p>

<ul>
  <li>Python Flask应用程序的简单单元测试</li>
  <li>如何在项目中使用CircleCI配置文件在代码库中实现CI/CD管道</li>
  <li>建立码头工人形象</li>
  <li>将Docker图像推送到<a href="https://hub.docker.com"> Docker Hub </a></li>
  <li>启动一个部署脚本，该脚本将在数字海洋服务器上运行Docker容器中的应用程序</li>
</ul>

<h2>先决条件</h2>

<p>在我们开始之前，您需要:</p>


<p>完成所有先决条件后，您就可以开始下一部分了。</p>

<h2>使用示例应用程序</h2>

<p>在这篇文章中，我将使用一个简单的Python <a href="http://flask.pocoo.org/"> Flask </a>，你可以在这里和本地<code>git clone</code>找到这个项目的完整<a href="https://github.com/punkdata/python-circleci-docker">源代码。该应用程序是一个简单的web服务器，当向它发出请求时，它会呈现html。Flask应用程序位于<code>hello_world.py</code>文件中:</a></p>

<pre><code>from flask import Flask

app = Flask(__name__)

def wrap_html(message):
    html = """
        &lt;html&gt;
        &lt;body&gt;
            &lt;div style='font-size:120px;'&gt;
            &lt;center&gt;
                &lt;image height="200" width="800" src="https://infosiftr.com/wp-content/uploads/2018/01/unnamed-2.png"&gt;
                &lt;br&gt;
                {0}&lt;br&gt;
            &lt;/center&gt;
            &lt;/div&gt;
        &lt;/body&gt;
        &lt;/html&gt;""".format(message)
    return html

@app.route('/')
def hello_world():
    message = 'Hello DockerCon 2018!'
    html = wrap_html(message)
    return html

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
</code></pre>

<p>这段代码中的关键是去掉<code>hello_world()</code>函数中的<code>message</code>变量。此变量指定一个字符串值，并将在单元测试中测试此变量的值是否匹配。</p>

<h2>测试代码</h2>

<p>代码必须经过测试，以确保向公众发布高质量、稳定的代码。Python附带了一个名为<a href="https://docs.python.org/2/library/unittest.html"> unittest </a>的测试框架，我将在本教程中使用它。现在我们有了一个完整的Flask应用程序，它需要一个配套的单元测试来测试应用程序并确保它按照设计的那样运行。单元测试文件<code>test_hello_world.py</code>是我们hello_world.py应用程序的单元测试。现在，让我们浏览一下代码。</p>

<pre><code>import hello_world
import unittest

class TestHelloWorld(unittest.TestCase):

    def setUp(self):
        self.app = hello_world.app.test_client()
        self.app.testing = True

    def test_status_code(self):
        response = self.app.get('/')
        self.assertEqual(response.status_code, 200)
    
    def test_message(self):
        response = self.app.get('/')
        message = hello_world.wrap_html('Hello DockerCon 2018!')
        self.assertEqual(response.data, message)

if __name__ == '__main__':
    unittest.main()
</code></pre>

<pre><code>import hello_world
import unittest
</code></pre>

<p>使用<code>import</code>语句导入<code>hello_world</code>应用程序使得测试可以访问<code>hello_world.py</code>中的代码。接下来，导入<code>unittest</code>模块，并开始为应用程序定义测试覆盖。</p>

<p><code>class TestHelloWorld(unittest.TestCase):</code>testhello world从基类<code>unittest.Test</code>实例化而来，基类是测试的最小单元。它检查对一组特定输入的特定响应。unittest框架提供了一个基类TestCase，您将使用它来创建新的测试用例。</p>

<pre><code>def setUp(self):
        self.app = hello_world.app.test_client()
        self.app.testing = True
</code></pre>

<p>调用类级方法<code>setUp()</code>来准备测试夹具。在调用测试方法之前立即调用它。在这个例子中，我们创建并定义了一个名为<code>app</code>的变量，并从hello_world.py代码中将它实例化为<code>app.test_client()</code>对象。</p>

<pre><code>def test_status_code(self):
    response = self.app.get('/')
    self.assertEqual(response.status_code, 200)
</code></pre>

<p>方法<code>test_status_code()</code>在代码中指定了一个实际的测试用例。这个测试用例向Flask应用程序发出一个<code>get</code>请求，并在<code>response</code>变量中捕获应用程序的响应。<code>self.assertEqual(response.status_code, 200)</code>将<code>response.status_code</code>结果的值与<code>200</code>的期望值进行比较，这表示<code>get</code>请求成功。如果服务器响应的status_code不是200，测试将失败。</p>

<pre><code>def test_message(self):
    response = self.app.get('/')
    message = hello_world.wrap_html('Hello DockerCon 2018!')
    self.assertEqual(response.data, message)
</code></pre>

<p>另一个方法<code>test_message()</code>，指定了一个不同的测试用例。这个测试用例被设计来检查在hello_world.py代码的<code>hello_world()</code>方法中定义的<code>message</code>变量的值。像前面的测试一样，对应用程序进行了一个<strong> get </strong>调用，结果被捕获到一个<code>response</code>变量中:</p>

<pre><code>message = hello_world.wrap_html('Hello DockerCon 2018!')
</code></pre>

<p>按照hello_world应用程序中的定义，<code>message</code>变量被赋予从<code>hello_world.wrap_html()</code> helper方法得到的html。字符串<code>Hello DockerCon 2018</code>被提供给<code>wrap_html()</code>方法，然后在html中注入并返回。<code>test_message()</code>验证应用程序中的消息变量是否与测试用例中的预期字符串匹配。如果字符串不匹配，测试将失败。</p>

<h2>实施CI/CD管道</h2>

<p>既然我们已经清楚了应用程序及其单元测试，那么是时候将CI/CD管道实现到代码库中了。使用CircleCI实现CI/CD管道非常简单，但是在继续之前，请确保执行以下操作:</p>



<h3>设置CI/CD管道</h3>

<p>一旦您的项目在CircleCI平台中建立，任何向上游推送的提交都将被检测到，CircleCI将执行您的<code>config.yml</code>文件中定义的作业。</p>

<p>在repo的根目录中创建一个新目录，并在这个新目录中添加一个yaml文件。新资产必须遵循项目的git存储库中的这些命名模式-目录:<code>.circleci/</code>文件:<code>config.yml</code>。这个目录和文件基本上定义了CircleCI平台的CI/CD管道和配置。</p>

<h3>配置文件</h3>

<p>config.yml文件是所有CI/CD奇迹发生的地方。在显示示例文件的代码块之后，我将简要解释语法中发生了什么。</p>

<pre><code>version: 2
jobs:
  build:
    docker:
      - image: circleci/python:2.7.14
        environment:
          FLASK_CONFIG: testing
    steps:
      - checkout
      - run:
          name: Setup VirtualEnv
          command: |
            echo 'export TAG=0.1.${CIRCLE_BUILD_NUM}' &gt;&gt; $BASH_ENV
            echo 'export IMAGE_NAME=python-circleci-docker' &gt;&gt; $BASH_ENV 
            virtualenv helloworld
            . helloworld/bin/activate
            pip install --no-cache-dir -r requirements.txt
      - run:
          name: Run Tests
          command: |
            . helloworld/bin/activate
            python test_hello_world.py
      - setup_remote_docker:
          docker_layer_caching: true
      - run:
          name: Build and push Docker image
          command: |
            . helloworld/bin/activate
            pyinstaller -F hello_world.py
            docker build -t ariv3ra/$IMAGE_NAME:$TAG .
            echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin
            docker push ariv3ra/$IMAGE_NAME:$TAG
      - run:
          name: Deploy app to Digital Ocean Server via Docker
          command: |
            ssh -o StrictHostKeyChecking=no root@hello.dpunks.org "/bin/bash ./deploy_app.sh ariv3ra/$IMAGE_NAME:$TAG"
</code></pre>

<p><code>jobs:</code>键代表将要运行的任务列表。作业封装了要执行的操作。如果您只有一个作业要运行，那么您必须给它一个键名<code>build:</code>。这里有更多关于<a href="https://circleci.com/docs/configuration-reference/#jobs">工作和建造的细节。</a></p>

<p><code>build:</code>键由几个元素组成:</p>



<p><code>docker:</code>键告诉CircleCI使用一个<a href="https://circleci.com/docs/configuration-reference/#docker"> Docker执行器</a>，这意味着我们的构建将使用Docker容器来执行。</p>

<p><code>image: circleci/python:2.7.14</code>指定构建必须使用的Docker映像。</p>

<h4>步骤:</h4>

<p><code>steps:</code>键是一个集合，它指定了将在这个构建中执行的所有命令。发生的第一个动作是<code>- checkout</code>命令，它在执行环境中执行代码的git克隆。</p>

<p><code>- run:</code>键指定在构建中执行的命令。运行键有一个<code>name:</code>参数，您可以在这里标记一组命令。例如，<code>name: Run Tests</code>对测试相关的动作进行分组。这种分组有助于在CircleCI仪表板中组织和显示构建数据。</p>

<p><strong>注:</strong> <i>每个<code>run</code>块相当于单独的、个体的壳或端子。已配置或已执行的命令将不会在以后的运行块中持续。</i>使用文档的<a href="https://circleci.com/docs/migration/#tips-for-setting-up-circleci-20">提示&amp;技巧部分</a>中的<code>$BASH_ENV</code>解决方法。</p>

<pre><code>- run:
    name: Setup VirtualEnv
    command: |
      echo 'export TAG=0.1.${CIRCLE_BUILD_NUM}' &gt;&gt; $BASH_ENV
      echo 'export IMAGE_NAME=python-circleci-docker' &gt;&gt; $BASH_ENV 
      virtualenv helloworld
      . helloworld/bin/activate
      pip install --no-cache-dir -r requirements.txt
</code></pre>

<p>这个运行块的<code>command:</code>键有一个要执行的命令列表。这些命令设置了<code>$TAG</code> &amp; <code>IMAGE_NAME</code>自定义环境变量，这些变量将在整个构建过程中使用。剩下的命令设置<a href="https://virtualenv.pypa.io/en/stable/"> python virtualenv </a>并安装在<code>requirements.txt</code>文件中指定的python依赖项。</p>

<pre><code>- run:
    name: Run Tests
    command: |
      . helloworld/bin/activate
      python test_hello_world.py
</code></pre>

<p>在这个运行块中，命令对我们的应用程序执行测试。如果这些测试失败，整个构建将会失败。开发人员需要修改他们的代码并重新提交。</p>

<pre><code>- setup_remote_docker:
    docker_layer_caching: true
</code></pre>

<p>这个运行块指定了<a href="https://circleci.com/docs/glossary/#remote-docker"> setup_remote_docker: </a>键，这是一个支持从docker executor作业中构建、运行和推送映像到Docker注册表的特性。当docker_layer_caching设置为true时，CircleCI将尝试重用在之前的作业或工作流中构建的docker图像(层)。也就是说，您在之前的作业中构建的每个图层都可以在远程环境中访问。但是，在某些情况下，即使配置指定docker_layer_caching: true，您的作业也可能在干净的环境中运行。</p>

<p><code>setup_remote_docker:</code>特性是必需的，因为我们正在为我们的应用程序构建Docker映像，并将该映像推送到Docker Hub。</p>

<pre><code>- run:
    name: Build and push Docker image
    command: |
      . helloworld/bin/activate
      pyinstaller -F hello_world.py
      docker build -t ariv3ra/$IMAGE_NAME:$TAG .
      echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin
      docker push ariv3ra/$IMAGE_NAME:$TAG
</code></pre>

<p><strong>构建和推送Docker映像</strong>运行块指定了使用pyinstaller将应用程序打包成一个二进制文件的命令。然后继续进行Docker映像构建过程。</p>

<pre><code>docker build -t ariv3ra/$IMAGE_NAME:$TAG .
echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin
docker push ariv3ra/$IMAGE_NAME:$TAG
</code></pre>

<p>这些命令基于repo中包含的<code>Dockerfile</code>构建docker映像。构建Docker映像的说明可以在这里找到:<a href="https://docs.docker.com/engine/reference/builder/"> Dockerfile </a>。</p>

<pre><code>FROM python:2.7.14

RUN mkdir /opt/hello_word/
WORKDIR /opt/hello_word/

COPY requirements.txt .
COPY dist/hello_world /opt/hello_word/

EXPOSE 80

CMD [ "./hello_world" ]
</code></pre>

<p><code>echo $DOCKER_PWD | docker login -u $DOCKER_LOGIN --password-stdin</code>命令使用CircleCI仪表板中设置的$DOCKER_LOGIN和$DOCKER_PWD环境变量作为登录凭证&amp;将此映像推送到Docker Hub。</p>

<pre><code>- run:
    name: Deploy app to Digital Ocean Server via Docker
    command: |
      ssh -o StrictHostKeyChecking=no root@hello.dpunks.org "/bin/bash ./deploy_app.sh ariv3ra/$IMAGE_NAME:$TAG"
</code></pre>

<p>最后一个运行块将我们的新代码部署到运行在数字海洋平台上的实时服务器上，确保您已经在远程服务器上创建了部署脚本。ssh命令访问远程服务器并执行<code>deploy_app.sh</code>脚本，包括<strong> ariv3ra/$IMAGE_NAME:$TAG </strong>，它指定要从Docker Hub拉取和部署的映像。</p>

<p>作业成功完成后，新的应用程序应该在config.yml文件中指定的目标服务器上运行。</p>

<h2>摘要</h2>

<p>本教程的目标是指导您在代码中实现CI/CD管道。虽然这个示例是使用Python技术构建的，但是一般的构建、测试和部署概念可以使用您喜欢的任何语言或框架轻松实现。您可以扩展本教程中的简单示例，并根据您自己的管道进行定制。CircleCI有很棒的<a href="https://circleci.com/docs/">文档</a>请确保研究我们的文档网站。如果你真的遇到困难，你可以联系https://discuss.circleci.com/社区/论坛网站<a href="https://discuss.circleci.com/">上的CircleCI社区。</a></p>

<p>阅读更多信息:</p>




        
          
          
        
      </div>
    </div>    
</body>
</html>
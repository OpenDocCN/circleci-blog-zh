<html>
<head>
<title>Managing code signing on CircleCI using the runner | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用runner | CircleCI管理CircleCI上的代码签名</h1>
<blockquote>原文：<a href="https://circleci.com/blog/code-signing-with-runner/#2021-11-29T12:00:00-08:00">https://circleci.com/blog/code-signing-with-runner/#2021-11-29T12:00:00-08:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>代码签名是测试和分发桌面和移动应用程序的重要部分。它确保最终用户的系统可以验证您的应用程序的合法性。由于对签名证书安全性的需要，它们存储在本地，而不上传到云中。这个约束可能会阻止您的团队完全自动化您的CI/CD管道。幸运的是，使用runner，您的团队可以在您控制的机器上保持证书安全，同时仍然允许CircleCI作业对您的包进行签名。</p>

<h2>什么是代码签名？</h2>

<p>代码签名在移动应用领域很常见，谷歌Play商店和App Store要求每个发布的应用都使用它。代码签名向用户保证他们下载的应用程序将被他们想要安装的设备信任。</p>

<h3>桌面应用程序的代码签名</h3>

<p>代码签名可用于桌面二进制文件，但不太常见。在Windows上运行未签名的二进制文件时，您可能会得到一个提示，询问您是否信任发行者。操作系统会提醒您这是一个未签名的应用程序。该应用程序可能值得信任，也可能不值得信任，因此您可以将该提示用作警告标志。</p>

<p>有两种方法可以管理应用程序的代码签名:</p>
<ul>
  <li>将签名嵌入到二进制文件中，以便操作系统可以对其进行验证；这是macOS、Windows和移动操作系统使用的。</li>
  <li>提供二进制文件的<i>散列</i>的签名；用于Linux。</li>
</ul>

<p>这两种方法都可以用来验证下载的文件是否正确。</p>

<h2>保护私有证书的安全</h2>

<p>最佳实践是尽可能保证这个私有证书的安全，不要把它放在网上或云中。因此，在CircleCI中存储私有证书不是一个好主意，无论是在安全上下文中还是在环境变量中。不建议将证书或私有GPG密钥上载到CircleCI。</p>

<p>然而，当涉及到测试时，有一个例外。在CI/CD过程中，本地创建的证书可以用于上传和测试，只要该证书没有被其他机器分发和信任。当您使用runner来保证您的团队控制的机器上的证书安全时，这个异常使得对您的CI/CD管道执行端到端测试成为可能。</p>

<h2>在您的机器上设置转轮</h2>

<p>在你自己的机器上安装runner很简单，目前在Ubuntu、macOS和Windows上都支持。您可以在<a href="https://circleci.com/docs/runner-installation/index.html/">安装CircleCI转轮</a>中找到多个平台的说明。</p>

<p>您还需要将私有证书安装到您用来签名的平台所要求的位置。以下是说明:</p>



<p>完成这些步骤后，您就可以开始使用CircleCI runner为您的应用程序签名了。</p>

<h2>使用签名哈希在Linux上签名</h2>

<p>Linux不使用签名二进制文件的概念。相反，用户依赖于文件散列和签名。</p>

<p>第一步是计算要分发的文件的文件哈希。您可以使用各种强度的SHA和，包括SHA1(不推荐)、SHA256或SHA512哈希。对于本教程，我们将使用SHA512。</p>

<pre><code>$ sha512sum xyz.exe
cf83e...927da3e  xyz.exe
</code></pre>

<p>将结果保存为<code>SHA512SUMS</code>。如果您想在一个签名中包含多个文件，只需将它们的文件名传递给<code>sha512sum</code>命令。每个文件的散列将被打印到单独的一行。不要编辑输出，否则以后将无法验证散列。</p>

<p>现在你可以签名了。如果您已经生成了一个私有GPG密钥，那么签名非常简单:</p>

<pre><code>$ gpg --sign SHA512SUMS --output SHA512SUMS.sig
</code></pre>

<p>这段代码输出文件<code>SHA512SUMS.sig</code>，该文件已经使用您的密钥进行了签名。用您的二进制文件分发这个<code>.sig</code>文件，并指示用户在安装您的公钥后验证输出。您可以在这里查看<a href="https://www.gnupg.org/gph/en/manual/x56.html" target="_blank" rel="noreferrer noopener">的说明</a>。</p>

<pre><code>$ gpg --decrypt SHA512SUMS.sig &gt; SHA512SUMS
gpg: Signature made Tue 22 Jun 13:53:56 2021 BST
gpg:                using RSA key 1234XYZ
gpg: Good signature from "CircleCI &lt;contact@circleci.com&gt;" [ultimate]
$ sha512sum --check SHA512SUMS
xyz.exe: OK
</code></pre>

<h2>macOS上的代码签名</h2>

<p>和Linux一样，macOS也可以使用文件哈希和签名。与签署团队的macOS或iOS应用程序文件相比，这有点乏味。反过来，macOS会自动验证它们。</p>

<p>确保构建应用程序所需的所有证书和配置文件都安装在本地runner机器上。这些证书和配置文件必须安装在为运行程序守护程序配置的同一用户下。最简单的方法是在机器上用Xcode构建一次项目。这允许Xcode创建和安装它需要的证书和描述文件。</p>

<p>runner launch守护进程需要添加一个额外的选项，以便可以通过作业访问keychains:</p>

<pre><code>&lt;key&gt;SessionCreate&lt;/key&gt;
&lt;true/&gt;
</code></pre>

<p>另一个关键步骤是确保新的苹果全球开发者关系证书在runner机器上可用。作为跑步者用户，你可以在这里下载它<a href="https://www.apple.com/certificateauthority/AppleWWDRCAG3.cer" target="_blank" rel="noreferrer noopener"/></p>

<p>以在CircleCI上构建应用程序但不创建签名的<code>.ipa</code>文件的方式构建您的工作流程。相反，它应该创建一个供以后使用的<code>.xcarchive</code>文件。尝试构建<code>.ipa</code>文件将会失败，因为在云作业中没有代码签名资产。</p>

<p>该归档保存到运行程序作业中拉入的工作区。runner作业获取这个归档文件，跳过再次构建项目，并通过gym运行它，gym使用安装在runner机器上的代码签名资产将它导出为一个签名的<code>.ipa</code>文件。这将代码签名资产安全地保存在您的团队控制的机器上。</p>

<h2>Windows上的代码签名</h2>

<p>如果你安装了Visual Studio，你可以使用微软的一个特殊的签名工具<code>SignTool.exe</code>。签署文件只需要一个有效的证书(可以是自签名的)并执行<code>SignTool.exe</code>:</p>

<pre><code>SignTool.exe sign /a /fd SHA256 xyz.exe
</code></pre>

<p>不像在Linux进程中，不会创建其他文件。相反，签名嵌入在文件本身中。</p>

<p>如果要对文件进行签名以进行更广泛的分发，请确保用于签名文件的证书受到广泛信任。要么购买由可信机构签名的证书，要么自己生成并分发证书。但是，除了内部使用之外，不建议使用自签名。正如我在前面的教程中所描述的，Windows用一个提示来标记未签名的二进制文件的执行，以继续处理一个不可信的文件。如果找到有效的签名，操作系统会显示详细信息，以便用户查看。</p>

<h2>使用runner将签名添加到CircleCI配置中</h2>

<p>您知道如何对二进制文件进行签名，或者提供一种可信的方法来验证二进制文件是否正确。现在，您可以将它整合到您的CircleCI配置中。第一步是用证书或私有GPG密钥验证运行者是否正确安装在机器上。</p>

<p>在本例中，我们将使用Windows Server 2019虚拟机和runner通过CircleCI创建可执行文件。如果你愿意，你可以为其他用例修改这个过程。</p>

<p>以下是配置示例:</p>

<pre><code>version: 2.1
orbs:
  msix: circleci/microsoft-msix@1.1
jobs:
  build:
  	docker:
  		- image: cimg/go:stable
  	steps:
  		- checkout
  		- run:
  			command: GOOS=windows GOARCH=amd64 go build -o your-package.exe
  			name: Build application for Windows
  		- persist_to_workspace:
  			root: .
  			paths: your-package.exe
  sign:
	shell: powershell
    machine: true
    resource_class: your-namespace/windows-vm
    steps:
      - attach_workspace:
      		at: .
      - msix/sign:
          package-name: your-package
workflows:
  demo:
    jobs:
      - build
      - sign:
      		requires: ["build"]
</code></pre>

<p>这个工作流程的第一步是在CircleCI上执行密集的构建过程。保存到工作区，将二进制文件传输到runner机器。这种方法使您自己的基础结构很小，但是足够强大，可以控制您的签名密钥或证书。</p>

<h2>结论</h2>

<p>代码签名对于分发应用程序变得越来越重要。一些系统拒绝执行未经可信方签名的二进制文件。由于有了runner，很容易将CircleCI Cloud的速度与在自己控制的机器上运行敏感工作负载的安全性结合起来。我希望这篇教程对你有所帮助，我也希望你能受到启发，带领你的团队完成更多与跑步者的代码签名的应用。</p>



        
          
          
        
      </div>
    </div>    
</body>
</html>
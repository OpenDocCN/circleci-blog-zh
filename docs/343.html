<html>
<head>
<title>How to Build Immutable Infrastructure with Packer and CircleCI Workflows - CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用Packer和CircleCI工作流构建不可变的基础设施</h1>
<blockquote>原文：<a href="https://circleci.com/blog/how-to-build-immutable-infrastructure-with-packer-and-circleci-workflows/#2017-12-12T08:44:00-08:00">https://circleci.com/blog/how-to-build-immutable-infrastructure-with-packer-and-circleci-workflows/#2017-12-12T08:44:00-08:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        
          <p class="italic"><strong>来自出版商的说明:</strong>您已经找到了我们的一些旧内容，这些内容可能已经过时和/或不正确。尝试在<a href="https://circleci.com/docs/" target="_blank">我们的文档</a>或<a href="https://circleci.com/blog/">博客</a>中搜索最新信息。</p>
          <hr/>
        

        <p>HashiCorp <a href="https://www.hashicorp.com/blog/hashicorp-terraform-enterprise-general-availability">最近宣布</a>他们将放弃Atlas，并将Terraform Enterprise作为独立产品提供给客户。在本帖中，我们将概述如何使用Packer和CircleCI复制您的Atlas管道，并举例说明Packer作业配置、AMI生成、使用Terraform管理变更以及在S3存储工件。在CircleCI，我们使用AMIs作为不可变基础设施的一部分。能够在我们的持续部署管道中的单点将配置和变更管理应用到AMI是非常有益的。不可变的基础设施允许我们以尽可能快且可证明的方式纵向扩展以满足需求——如果我们的扩展请求必须等待供应过程完成，我们将不得不过度供应以处理峰值。</p>

<p>一旦您有了以这种方式生成的ami，您现在也可以通过使用Terraform(或Chef、Puppet等)等工具将您的网络基础设施移入代码中而受益。).让您的基础设施以代码的形式存在，可以让它受益于作为持续集成和部署管道的一部分的变更管理。</p>

<p>在这个过程的每一步，我们都应该以可审计和可再现的方式进行变更，以生成现在可以根据需要进行测试、验证和部署的工件。管道步骤不再需要同步或紧密耦合。我们还获得了改变管道中任何工具的能力，只要它匹配它生成的任何工件的需求。</p>

<p>既然我们已经讨论了为什么要这样做，让我们来看看如何做。在我们的示例中，我们将引用这些工具:</p>

<ul>
  <li>Docker，它允许您测试和微调每个打包定义</li>
  <li>Packer，它允许您从一个源配置创建多个机器映像</li>
  <li>AWS命令行(或类似的)允许您部署新AMI的实例</li>
</ul>

<p>我们将有一个基本AMI和一个雪花AMI，它们的源是基本AMI。我们还将为两者生成清单json文件，并将它们推送到S3。</p>

<p>我们假设您对Packer有一定的了解，并且至少已经阅读了<a href="https://www.packer.io/intro/getting-started/install.html"> HashiCorp Packer入门</a>文档。</p>

<p>基本AMI的封隔器配置相当标准，您可以在https://github.com/CircleCI-Public/circleci-packer.看到完整的配置</p>

<p>下面的例子有几个项目可以使调试和测试您的打包程序配置更容易，例如，我们使用一个<code>inline</code> provisioner进行循环，直到我们看到云初始化阶段完成，否则我们可能会在操作系统完全初始化之前安装到操作系统上。</p>

<p>我们还定义了<code>user</code>变量，包括<code>ami_sha</code>变量，它将从Packer配置的Git SHA中获取值。这由<a href="https://github.com/CircleCI-Public/circleci-packer/blob/master/scripts/common.sh#L2"> tag_exists() </a> shell函数用来检查正在生成的AMI是否已经存在。</p>

<pre><code class="language-bash">
"provisioners": [
  {
     "inline": [
       "while [ ! -f /var/lib/cloud/instance/boot-finished ]; do echo 'Waiting for cloud-init...'; sleep 1; done"
     ],
     "type": "shell"
   },
   {
     "scripts": [
       "./base/tasks/baseline.sh",
       "./base/tasks/cleanup.sh",
       "./base/tasks/debug.sh"
     ],
     "type": "shell"
   }
 ],
 "variables": {
   "ami_name": "baseline-ubuntu-1604",
   "ami_base": "ami-aa2ea6d0",
   "ami_sha":  "{{env `SHA`}}"
 }
 
</code></pre>

<p>供应的实际工作由三个任务脚本控制，它们为Ubuntu准备APT环境，将区域设置为UTC(唯一的真实时区)，然后执行始终存在的<code>apt-get upgrade</code>。因为我们在基线AMI <em>和</em>中执行这些基本任务，所以当基线AMI发生变化时，我们的依赖AMI会自动生成，我们的下游AMI的任务脚本可以针对该AMI，这改善了我们的干燥(不要重复自己)态度。通过在我们的Packer配置中包含一个<code>Docker</code>构建器，我们还从Packer中获得了不仅生成AMI而且生成Docker容器的能力。</p>

<p>我们可以更深入地研究Packer提供的不同旋钮和杠杆，但他们的文档在这方面做得很好，所以我宁愿深入研究build.sh脚本中的“粘合”代码，它使菊花链ami成为可能。</p>

<p>您可能已经知道，我们使用Git SHA作为我们的标记来识别对AMI的打包器配置的更改是否会生成AMI。在<code>common.sh</code>中，我们有<a href="https://github.com/CircleCI-Public/circleci-packer/blob/master/scripts/common.sh#L31"> get_base_ami() </a>，它以两种方式寻找基本ami。首先，它将查看我们是否可以在先前运行生成的manifest.json文件中找到它，或者它将在AWS AMI列表中查找Git SHA。如果找到了AMI，我们可以从AMI的标签中寻找CircleCI工件ID。</p>

<p>这样，当基础AMI的CircleCI工作流中的变化触发了我们的依赖CircleCI工作流步骤时，我们能够检索生成的基础AMI，并将其插入到我们的Packer构建中。</p>

<p>Packer是一个非常灵活的工具，可以通过CircleCI工作流的配置定义针对多个环境，这种组合为我们不可变的基础架构创建了一个持续集成和部署管道。通过在bash脚本中拥有我们AMI一代的“业务逻辑”,可以沿着持续集成管道进行管理，我们已经满足了AMI一代的可审计和可自动化变更管理流程的需求。</p>

<p>我希望这个公认简单的例子有助于指出这个工具组合如何将一个重要的过程从繁琐的手动转移到DevOps任务列表的自动部分。</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>
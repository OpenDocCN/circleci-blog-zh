<html>
<head>
<title>Building a Docker image on CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在CircleCI上建立Docker形象</h1>
<blockquote>原文：<a href="https://circleci.com/blog/how-to-build-a-docker-image-on-circleci-2-0/#2021-04-30T17:28:00-07:00">https://circleci.com/blog/how-to-build-a-docker-image-on-circleci-2-0/#2021-04-30T17:28:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>在CircleCI中，开发人员可以自由组合任意图像，如乐高积木，以创建他们首选的<a href="https://circleci.com/continuous-integration/"> CI </a>容器环境。比如CircleCI原生支持<a href="https://www.docker.com/"> Docker </a>。您可以将应用程序作为<a href="https://circleci.com/docs/circleci-images/"> Docker映像</a>进行构建、推送和部署。CircleCI使用Docker容器中的Docker构建Docker映像，</p>

<p>在本帖中，我将简要描述<a href="https://circleci.com/docs/building-docker-images/">如何在CircleCI中构建Docker图像</a>，包括<a href="https://circleci.com/docs/docker-layer-caching/">图像层</a>缓存。</p>

<h2>TL；速度三角形定位法(dead reckoning)</h2>

<p>在项目的根目录中，在名为<code>.circleci</code>的目录中创建一个<code>config.yml</code>:</p>

<pre><code>version: 2
jobs:
  build:
    working_directory: /app
    docker:
      - image: docker:17.05.0-ce-git
    steps:
      - checkout
      - setup_remote_docker
      - run:
          name: Install dependencies
          command: |
            apk add --no-cache \
              py-pip=9.0.0-r1
            pip install \
              docker-compose==1.12.0 \
              awscli==1.11.76
      - restore_cache:
          keys:
            - v1-{{ .Branch }}
          paths:
            - /caches/app.tar
      - run:
          name: Load Docker image layer cache
          command: |
            set +o pipefail
            docker load -i /caches/app.tar | true
      - run:
          name: Build application Docker image
          command: |
            docker build --cache-from=app -t app .
      - run:
          name: Save Docker image layer cache
          command: |
            mkdir -p /caches
            docker save -o /caches/app.tar app
      - save_cache:
          key: v1-{{ .Branch }}-{{ epoch }}
          paths:
            - /caches/app.tar
      - run:
          name: Run tests
          command: |
            docker-compose -f ./docker-compose.test.yml up
      - deploy:
          name: Push application Docker image
          command: |
            if [ "${CIRCLE_BRANCH}" == "master" ]; then
              login="$(aws ecr get-login)"
              ${login}
              docker tag app "${ECR_ENDPOINT}/app:${CIRCLE_SHA1}"
              docker push "${ECR_ENDPOINT}/app:${CIRCLE_SHA1}"
            fi
</code></pre>

<p>根据项目的不同，一些细节可能会有所变化。如果您想亲自尝试这些步骤，我准备了一个<a href="https://github.com/builtinnya/circleci-2.0-beta-docker-example">示例项目</a>，您可以使用这个配置文件。</p>

<p>该项目使用<a href="https://expressjs.com/"> Express </a>在node.js中编写，并简单地返回“Hello World”，用<a href="https://facebook.github.io/jest/"> Jest </a>和<a href="https://github.com/visionmedia/supertest"> supertest </a>进行测试。为了将Docker图像(ECR)推送到<a href="https://aws.amazon.com/jp/ecr/"> Amazon EC2容器注册表</a>，我使用了一个<a href="https://www.terraform.io/"> Terraform </a>脚本。</p>

<p>在每一节之后，我将提供它是如何工作的一个细目分类。</p>

<h2>顶层结构</h2>

<pre><code>version: 2
jobs:
  build:
    working_directory: /app
    docker:
      ...
    steps:
      ...
</code></pre>

<p>在CircleCI中，我们可以自由定义每个作业的<em>步骤</em>，包括存储库签出和缓存相关的处理。这给了我们很大的自由，不仅对于CI容器环境，而且对于步骤。所有细节都可以在<a href="https://circleci.com/docs/">官方文件</a>中找到。</p>

<h2>执行者坞站</h2>

<pre><code>docker:
  - image: docker:17.05.0-ce-git
</code></pre>

<p>在本节中，我们定义前面提到的CI环境。这个环境是我们的步骤将被执行的地方。</p>

<p>我们想要的是一个安装Docker并有Git的Docker映像。这些要求通过使用<code>docker:17.05.0-ce-git</code>来满足，它是一个<a href="https://hub.docker.com/_/docker/" target="_blank" rel="noreferrer noopener">官方Docker图像</a>。</p>

<p>当一个图像有后缀“-git”时，意味着git是预装的。通过使用这个映像，您可以确保您始终使用最新的<a href="https://circleci.com/docs/building-docker-images/"> Docker客户端</a>。</p>

<h2>检验</h2>

<pre><code>steps:
  - checkout
</code></pre>

<p>第一步，<code>checkout</code>，是检查源代码的特殊步骤；这将被下载到由<code>working_directory</code>指定的目录。</p>

<h2>设置远程停靠站</h2>

<pre><code>- setup_remote_docker
</code></pre>

<p>这一步可以帮助你避免Docker-in-Docker问题。事实上，我们正在设置一个与CI(或<em>主</em>)容器隔离的<a href="https://circleci.com/docs/building-docker-images/" target="_blank" rel="noreferrer noopener">环境，然后使用远程主机的Docker引擎。</a></p>

<h2>安装所需的库</h2>

<pre><code>- run:
    name: Install dependencies
    command: |
      apk add --no-cache \
        py-pip=9.0.0-r1
      pip install \
        docker-compose==1.12.0 \
        awscli==1.11.76
</code></pre>

<p>在这里，我们安装了<a href="https://www.python.org/" target="_blank" rel="noreferrer noopener"> Python </a>、<a href="https://pip.pypa.io/en/stable/" target="_blank" rel="noreferrer noopener"> pip </a>、<a href="https://docs.docker.com/compose/" target="_blank" rel="noreferrer noopener"> Docker Compose </a>，以及<a href="https://aws.amazon.com/cli/" target="_blank" rel="noreferrer noopener"> AWS CLI </a>。</p>

<p>在实际项目中，我建议提前在映像中安装这些依赖项。</p>

<h2>构建和缓存Docker图像</h2>

<pre><code>- restore_cache:
    keys:
      - v1-{{ .Branch }}
    paths:
      - /caches/app.tar
  - run:
    name: Load Docker image layer cache
    command: |
      set +o pipefail
      docker load -i /caches/app.tar | true
  - run:
    name: Build application Docker image
    command: |
      docker build --cache-from=app -t app .
  - run:
    name: Save Docker image layer cache
    command: |
      mkdir -p /caches
      docker save -o /caches/app.tar app
  - save_cache:
    key: v1-{{ .Branch }}-{{ epoch }}
    paths:
      - /caches/app.tar
</code></pre>

<p>这是这篇文章的核心。基本上，我们正在做以下工作:</p>

<ol>
  <li>
    <p>当有以<code>v1-{{ &lt;branch name&gt; }}</code>为后缀的缓存时，CircleCI会将你的目录恢复到<code>/caches/app.tar</code>。<code>app.tar</code>是以前构建的Docker映像文件。</p>
  </li>
  <li>
    <p>当<code>/caches/app.tar</code>存在时，Docker将加载它，允许我们重用以前构建的图像。</p>
  </li>
  <li>
    <p>当你<a href="https://circleci.com/docs/building-docker-images/">构建一个Docker映像</a>时，你需要指定<code>--cache-from=&lt;image name&gt;</code>。</p>
  </li>
  <li>
    <p>我们将保存我们在<code>/caches/app.tar</code>中构建的Docker映像。</p>
  </li>
  <li>
    <p>最后，我们缓存<code>/caches/app.tar</code>以便在下一次构建中重用它。我们使用<code>v1-{{ &lt;branch name&gt; }}-{{ &lt;Unix epoch time&gt; }}</code>作为<a href="https://circleci.com/docs/caching/">缓存键</a>。</p>
  </li>
</ol>

<p>我们必须这样做的原因是因为远程Docker引擎默认情况下不做层缓存。虽然有一个<a href="https://circleci.com/docs/docker-layer-caching/" target="_blank" rel="noreferrer noopener">函数来执行这个层缓存</a>，但是我们必须请求CircleCI支持来启用2.0公测版中的缓存特性。这也有可能成为正式版本中的付费功能。</p>

<p>您可以参考示例项目的<a href="https://circleci.com/gh/builtinnya/circleci-2.0-beta-docker-example/tree/master">构建历史</a>来查看通过缓存图像层实际可以获得多少速度提升。例如，<a href="https://circleci.com/gh/builtinnya/circleci-2.0-beta-docker-example/12">版本#12 </a>有缓存，而<a href="https://circleci.com/gh/builtinnya/circleci-2.0-beta-docker-example/13">版本#13 </a>没有缓存。在这个例子中，我们看到速度增加了大约22秒。</p>

<h2>运行测试</h2>

<pre><code>- run:
    name: Run tests
    command: |
      docker-compose -f ./docker-compose.test.yml up
</code></pre>

<p>对于这个项目，我用Docker Compose运行测试，并且测试只在应用程序容器中运行。如果您需要一个数据库容器，使用Docker Compose很容易设置一个。</p>

<h2>推送Docker图像</h2>

<pre><code>- deploy:
    name: Push application Docker image
    command: |
      if [ "$ {CIRCLE_BRANCH}" == "master" ]; then
        login="$(aws ecr get-login)"
        ${login}
        docker tag app "${ECR_ENDPOINT}/app:${CIRCLE_SHA1}"
        docker push "${ECR_ENDPOINT}/app:${CIRCLE_SHA1}"
      fi
</code></pre>

<p>仅为主分支(在本例中称为“主”)构建Docker映像并将其推送到ECR存储库。我们从之前安装的AWS CLI获取登录信息。在一个真实的项目中，您通常会在推送映像后使用<code>ecs-deploy</code>进行部署。</p>

<h2>结论</h2>

<p>CircleCI允许您使用远程Docker引擎来构建Docker映像。即使在我的例子中构建速度的提高很小，我仍然知道缓存Docker图像层是可以做到的。根据项目的不同，构建速度的提高可能会更大。</p>

<p>阅读更多信息:</p>


<p>Naoto Yokoyama是一名自由职业的全栈工程师。你可以在<a href="https://twitter.com/builtinnya" target="_blank" rel="noreferrer noopener"> Twitter </a>、<a href="https://github.com/builtinnya" target="_blank" rel="noreferrer noopener"> GitHub </a>或者他们的<a href="http://lambdar.hatenablog.com/" target="_blank" rel="noreferrer noopener">博客</a>上与他们取得联系。</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>
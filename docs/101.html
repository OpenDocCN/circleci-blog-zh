<html>
<head>
<title>Building for Windows using the MSIX orb | CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用MSIX orb | CircleCI为Windows构建</h1>
<blockquote>原文：<a href="https://circleci.com/blog/building-msix-installers-on-circleci/#2021-11-23T12:00:00-08:00">https://circleci.com/blog/building-msix-installers-on-circleci/#2021-11-23T12:00:00-08:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>MSIX orb 是CircleCI的第一个“Windows专用”orb。当微软向我们提出建立一个orb来帮助Windows开发人员在我们的平台上进行开发的机会时，我们非常热情。我们的大多数orb和一般工作负载都围绕着Linux，并利用Bash。然而，我们认识到为在Windows 上构建应用程序提供良好的<a href="https://circleci.com/blog/cicd-for-dotnet/"> CI/CD解决方案的迫切需要，并且随着PowerShell在Linux中的使用稳步增长，是时候冒险了。</a></p>

<p>MSIX orb有两种不同的方法来构建新的MSIX/Appx安装程序格式:使用Visual Studio和手动创建文件。Visual Studio解决方案文件是Visual Studio中的一个项目设置，它链接到其他Visual Studio项目，并包含使用正确的元数据构建安装程序包<a href="https://docs.microsoft.com/en-us/windows/msix/desktop/vs-package-overview" target="_blank" rel="noreferrer noopener">所需的配置。这是使用这个球体和技术最直接的方式。手动选项更麻烦，因为它涉及创建必要的元数据和映射文件，以正确打包预编译的二进制文件。</a></p>

<p>在本教程中，我们将介绍使用Visual Studio解决方案文件构建包，并在最后为手动方法提供一些资源。</p>

<h2>关于代码签名，您需要知道什么</h2>

<p>代码签名允许用户和操作系统验证特定二进制代码或代码位的作者。有些东西是否被签名并不明显，所以操作系统警告未签名的二进制文件是很常见的。根据您的系统，您可能还会收到关于未签名的软件包和应用程序的警告。该警告提示您确认是否要继续安装或使用该特定软件包。</p>

<p>代码签名是MSIX和Appx包的必需步骤。它通常涉及一个昂贵但被广泛信任的证书或一个较小的本地创建的证书。除非明确安装，否则本地创建的证书可能不可信。对于本教程，我们将使用一个较小的本地创建的证书，原因有两个:</p>
<ul>
  <li>上传广泛信任的私有证书的私有部分不是一种好的做法。</li>
  <li>本地创建的证书更容易获得并用于测试。</li>
</ul>

<p>虽然有安全的方法可以做到这一点，但对私有证书最常见的建议是要么选择可信的专用服务，要么完全远离互联网。本地创建的证书是自签名的，如果它被泄露或被第三方获得，也不会成为重大事件。</p>

<p>您可以按照微软文档中的步骤<a href="https://docs.microsoft.com/en-us/windows/msix/package/create-certificate-package-signing" target="_blank" rel="noreferrer noopener">生成自签名证书</a>。创建证书后，使用同一链接中的说明导出证书。我们需要将导出的证书上传到CircleCI。</p>

<p>我们的下一步是将证书转换成基于文本的格式，因为环境变量是显式文本。我们可以使用base64编码来做到这一点。把base64编解码想象成脱水的食物，后期再补水。这种编码保留了文件内容，同时也将其视为文本。当我们需要原始文件时，可以对其进行解码。</p>

<p>使用以下PowerShell代码片段:</p>

<pre><code>[Convert]::ToBase64String([IO.File]::ReadAllBytes($FileName))
</code></pre>

<p>用导出的证书文件的名称替换<code>$FileName</code>。这个代码片段返回一个字符串，您可以将它添加到CircleCI上下文中。您将在稍后的管道中使用它。把这个命名为<code>MSIX_SIGNING_CERTIFICATE</code>。</p>

<p>您还需要添加用于将证书导出到相同安全上下文的密码。因为这个证书仅用于测试目的，只要它没有被安装在任何其他机器上，你就不需要担心它被泄露<i>。把这个命名为<code>MSIX_CERTIFICATE_PASSWORD</code>。</i></p>

<h2>使用MSIX球体</h2>

<p>MSIX orb极大地简化了构建基于解决方案的项目。这种极简的配置应该足以让你开始:</p>

<pre><code># .circleci/config.yml
version: 2.1

orbs:
  # We pin the minor version but leave out the patch version
  # to automatically accept non-breaking improvements.
  msix: circleci/microsoft-msix@1.1
  # Gives us easy access to Windows execution environments.
  win: circleci/windows@2.4.0
jobs:
  using-sln:
    executor:
      name: win/default
    steps:
      - checkout
      - msix/pack

workflows:
  demo:
    jobs:
      - using-sln
</code></pre>

<p><code>msix/pack</code>命令获取您的<code>.sln</code>项目并构建它，自动引入您的签名证书。它将最终结果发布为CircleCI工件，您可以下载并手动验证。如果您需要调整行为，有几个参数可用，但我们已经确定了大多数情况下的最佳默认值。</p>

<p>因为这是一个命令，所以您还可以通过将生成的文件保存到工作区或者上传到您自己的工件服务器来重用它。</p>

<h2>不使用Visual Studio构建MSIX</h2>

<p>可以使用通过其他方式构建的、具有MSIX可执行文件格式的现有可执行文件。然而，它需要手动创建元数据，你可以在微软的文档中了解更多关于<a href="https://docs.microsoft.com/en-us/windows/msix/desktop/desktop-to-uwp-manual-conversion" target="_blank" rel="noreferrer noopener">的信息。</a></p>

<p>当您使用这种方法时，在配置上有几个关键的区别:</p>
<ul>
  <li>您需要手动定义清单和映射文件，因为这两者都没有标准的文件名。</li>
  <li>您的安装程序需要使用<code>msix/sign</code>命令手动签名。</li>
</ul>

<pre><code>version: 2.1

orbs:
  msix: circleci/microsoft-msix@1.0
  win: circleci/windows@2.4.0
jobs:
  using-sln:
    executor:
      name: win/default
    steps:
      - checkout
      - msix/pack:
          using-sln: false
          mapping-file: mapping.txt
          manifest-file: appxmanifest.xml
      - msix/sign:
          import-cert: true

workflows:
  build:
    jobs:
      - using-sln
</code></pre>

<p>在这个代码片段中，打包一个非Visual Studio解决方案项目需要更多的手动操作，但是它受orb支持。</p>

<p>对于这两种方法，在orb源代码库中有一些可用的资源。这些资源主要用于集成测试，但是它们也展示了orb的功能。</p>

<h2>继续使用CircleCI构建Windows</h2>

<p>我和我的工程师同事对使用PowerShell编写脚本的体验非常满意。对我们来说，默认情况下，它被证明比Bash更健壮。我们的团队对MSIX球体的最终结果感到满意，我们希望您和您的团队会发现它很有用。它不是一个通用的执行环境，所以我们不依赖它来运行其他orb。然而，我们将继续投入时间，并希望建立更多的orb，为Windows执行器提供更好的原生支持。我们致力于改善团队在我们的平台上构建Windows操作系统的体验。</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>
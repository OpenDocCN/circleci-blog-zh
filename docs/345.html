<html>
<head>
<title>3 Ways to Design Services for Continuous Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>为持续部署设计服务的3种方式</h1>
<blockquote>原文：<a href="https://circleci.com/blog/how-to-design-services-for-continuous-deployment-3-best-practices/#2018-03-26T05:47:00-07:00">https://circleci.com/blog/how-to-design-services-for-continuous-deployment-3-best-practices/#2018-03-26T05:47:00-07:00</a></blockquote><div><div class="post-content col-xs-12 col-md-10 col-lg-8">
        

        <p>持续交付的好处在其他地方得到了很好的证明<a href="https://circleci.com/blog/a-brief-history-of-devops-part-iv-continuous-delivery-and-continuous-deployment/">。在这篇文章中，我想分享一些我们在CircleCI使用的实践，以确保我们的服务可以安全地持续部署。</a></p>

<p>我们的堆栈由部署在Kubernetes上的服务组成。每个服务主要包含在自己的git存储库中，并独立于其他服务进行部署。当我们部署新版本的服务时，新代码由Kubernetes一个一个地推出。这意味着在任何时候，都可以同时有多个版本的代码投入生产。</p>

<p>以下是我们发现对我们团队很有效的实践列表。</p>

<ol>
  <li>防止部署不完整的代码</li>
  <li>知道何时部署代码</li>
  <li>确保消息已送达<br/> <br/> <h2> 1。防止被破坏的代码被部署</h2></li>
</ol>

<p>一些bug确实通过了测试，并被部署到生产中。根据我的经验，单元测试中经常出现的一类错误是(经过良好测试的)软件组件在应用程序的顶层配置或组合不正确。</p>

<p>由于我们使用Kubernetes进行部署，我们可以在部署时使用它的强大功能为我们提供额外的安全网，帮助我们从生产流量中捕捉这些类型的错误。</p>

<p>我们的Kubernetes设置通常会一个接一个地部署新的pod。考虑一个运行在3个pod上的服务。当部署服务的新版本时，一个pod开始运行新代码。一旦这个单元是健康的，一个旧单元被终止，第二个新单元被启动。像这样一个接一个地滚动pod可以确保我们在部署代码时，在生产中始终有3个健康的pod。如果一个新的吊舱无法启动，Kubernetes将尝试重新启动新的吊舱，一遍又一遍，而留下其余3个吊舱在原地。</p>

<p>我们可以利用这种行为。如果我们对服务进行编码以在初始化期间验证它们的配置，并且<strong>没有捕捉到任何异常</strong>，那么服务将无法启动，并且，Kubernetes将阻止该代码版本接收生产中的流量。</p>

<p>例如，假设我们的服务有一个用于连接redis服务器的连接池。除了在启动时配置连接池，我们可以从连接池中获取一个连接并运行一个简单的语句，比如<code>ECHO "Hello World!"</code>，并确保不捕捉任何异常——如果服务失败，就让它崩溃吧！</p>

<p>除此之外，Kubernetes有两种用于监控pod状态的探针——“活性”和“准备就绪”探针。“就绪”探测用于让Kubernetes知道服务何时完全启动并准备好接受传入的请求。</p>

<p>Kubernetes不会将流量路由到pod，直到就绪性探测报告成功。这意味着我们用就绪探测器测试的应用越多，Kubernetes就越能保护我们不被部署错误。我最近写了一个新的服务，必须能够与RabbitMQ和AWS S3通信。通过确保与RabbitMQ的连接已连接，并且服务可以在返回成功的就绪探测之前将文件放入S3，我确信我的服务配置正确。</p>

<h2>2.知道何时部署代码</h2>

<p>如果全天都在部署新版本的服务，我们必须让团队看到我们的部署。我们一起使用CircleCI、Rollbar和Slack来确保我们知道代码何时被部署。</p>

<p>我们使用CircleCI来构建和部署我们的服务(当然)，我们使用<a href="https://rollbar.com/docs/deploy-tracking/"> Rollbar的部署跟踪</a> API来跟踪部署(<a href="https://docs.sentry.io/learn/releases/"> Sentry也有类似的功能</a>)。我们在每次部署时运行如下脚本:</p>

<pre><code>curl https://api.rollbar.com/api/1/deploy/
  --form access_token=$ROLLBAR_ACCESS_TOKEN
  --form environment=production
  --form revision=$CIRCLE_SHA1
  --form local_username=$CIRCLE_USERNAME
</code></pre>

<p>这给了我们两个好处。首先，Rollbar知道我们的发布。这种报告，加上我们快速部署较小变更的CD实践，这意味着我们可以轻松地将报告给滚动条的异常与导致异常首次发生的PR相关联。</p>

<p>第二个好处是，我们可以启用Rollbar的Slack集成，每次部署团队拥有的服务时，每个团队都可以在Slack中得到通知。</p>

<p>在这里，您可以看到一些松弛的流量，我部署了一个包含bug的服务的新版本，紧接着是一个新的异常类的松弛通知。</p>

<p>让这些警报出现在Slack中确实有助于我随时跟踪谁在部署。</p>

<p><img src="../Images/0bbc304cecad2e239a8884467efa9cc0.png" alt="rollbar.png" srcset="https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=449 449w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=898 898w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1347 1347w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=720 720w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1440 1440w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2160 2160w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=779 779w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1558 1558w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2337 2337w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=750 750w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=1500 1500w,&#10;https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;w=2250 2250w" sizes="(min-width: 1200px) 750px,&#10;(min-width: 992px) 779px,&#10;(min-width: 768px) 720px,&#10;(min-width: 480px) 720px,&#10;(min-width: 0px) 449px" data-full-size-src="https://production-cci-com.imgix.net/blog/media/rollbar.png?ixlib=rb-3.2.1&amp;auto=format&amp;fit=max&amp;q=60&amp;ch=DPR%2CWidth%2CViewport-Width%2CSave-Data&amp;fm=jpg" data-original-src="https://circleci.com/blog/media/rollbar.png"/></p>

<h2>3.确保消息得到传递</h2>

<p>我们在CircleCI大量使用RabbitMQ进行服务间的异步通信。典型的消息类似于运行特定项目构建的指令。</p>

<p>我们在生产环境中运行的任何服务都可能随时被终止，危险在于服务可能会消耗消息队列中的消息，并在有机会采取所需的操作之前被关闭。这与消息丢失具有相同的效果。考虑到这一点，我们推迟确认收到消息，直到我们执行了所需的操作。</p>

<p>在运行构建的情况下，这意味着我们将消息出队，在数据库中创建一个记录来表示构建，然后确认收到消息。现在的危险是，在数据库中创建记录之后，但在确认消息之前，服务可能会被终止。如果发生这种情况，RabbitMQ会将消息重新排队，并再次尝试传递到队列的另一个使用者。</p>

<p>这导致消息可能会多次到达，并且消息可能会无序到达。</p>

<p>在我们的示例中，如果运行构建的消息被重新交付给第二个消费者，那么该构建的记录将已经存在于数据库中。为了检测这一点，我们需要在每个消息中包含一个惟一的标识符，可能是一个构建ID。我们可以将这个构建ID和惟一性约束一起添加到数据库的构建记录中。这种约束使我们无法在数据库中创建多条记录。</p>

<p>从RabbitMQ消费时，我们使用以下模式:</p>

<p>我们确保所有的交换和队列都被声明为持久的，并且禁用自动删除。我们确保标记为持久的消息。我们在队列消费者中禁用消息的自动确认，而选择手动确认或否定消息。我们为消息添加了一些惟一的ID或幂等键，这样消费者就可以在需要时删除消息中的重复项。将去杜平消息的责任传递到尽可能远的下游，使我们的服务尽可能简单。</p>

<h2>结论</h2>

<p>在设计服务时，预先考虑CD过程以及它将如何影响您的代码是值得的。部署小的变更，并且尽可能频繁地部署。使用您的部署工具来进一步降低风险。请注意旧的pod的终止以及新的pod的部署，并注意确保您的飞行消息被可靠地传递。</p>

<p>通过使这些实践成为你工作流程的一部分，你正在采取措施使你的连续交付过程尽可能的平稳和安全。</p>


        
          
          
        
      </div>
    </div>    
</body>
</html>